
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Strings - Go - W3cubDocs</title>
  
  <meta name="description" content=" Package strings implements simple functions to manipulate UTF-8 encoded strings. ">
  <meta name="keywords" content="package, strings, -, go">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/go/strings/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/go.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/go/" class="_nav-link" title="" style="margin-left:0;">Go</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _go">
				
				
<h1> Package strings  </h1>    <ul id="short-nav">
<li><code>import "strings"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p> Package strings implements simple functions to manipulate UTF-8 encoded strings. </p> <p> For information about UTF-8 strings in Go, see <a href="https://blog.golang.org/strings" target="_blank">https://blog.golang.org/strings</a>. </p>      <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#Compare">func Compare(a, b string) int</a></li>
<li><a href="#Contains">func Contains(s, substr string) bool</a></li>
<li><a href="#ContainsAny">func ContainsAny(s, chars string) bool</a></li>
<li><a href="#ContainsRune">func ContainsRune(s string, r rune) bool</a></li>
<li><a href="#Count">func Count(s, substr string) int</a></li>
<li><a href="#EqualFold">func EqualFold(s, t string) bool</a></li>
<li><a href="#Fields">func Fields(s string) []string</a></li>
<li><a href="#FieldsFunc">func FieldsFunc(s string, f func(rune) bool) []string</a></li>
<li><a href="#HasPrefix">func HasPrefix(s, prefix string) bool</a></li>
<li><a href="#HasSuffix">func HasSuffix(s, suffix string) bool</a></li>
<li><a href="#Index">func Index(s, substr string) int</a></li>
<li><a href="#IndexAny">func IndexAny(s, chars string) int</a></li>
<li><a href="#IndexByte">func IndexByte(s string, c byte) int</a></li>
<li><a href="#IndexFunc">func IndexFunc(s string, f func(rune) bool) int</a></li>
<li><a href="#IndexRune">func IndexRune(s string, r rune) int</a></li>
<li><a href="#Join">func Join(a []string, sep string) string</a></li>
<li><a href="#LastIndex">func LastIndex(s, substr string) int</a></li>
<li><a href="#LastIndexAny">func LastIndexAny(s, chars string) int</a></li>
<li><a href="#LastIndexByte">func LastIndexByte(s string, c byte) int</a></li>
<li><a href="#LastIndexFunc">func LastIndexFunc(s string, f func(rune) bool) int</a></li>
<li><a href="#Map">func Map(mapping func(rune) rune, s string) string</a></li>
<li><a href="#Repeat">func Repeat(s string, count int) string</a></li>
<li><a href="#Replace">func Replace(s, old, new string, n int) string</a></li>
<li><a href="#ReplaceAll">func ReplaceAll(s, old, new string) string</a></li>
<li><a href="#Split">func Split(s, sep string) []string</a></li>
<li><a href="#SplitAfter">func SplitAfter(s, sep string) []string</a></li>
<li><a href="#SplitAfterN">func SplitAfterN(s, sep string, n int) []string</a></li>
<li><a href="#SplitN">func SplitN(s, sep string, n int) []string</a></li>
<li><a href="#Title">func Title(s string) string</a></li>
<li><a href="#ToLower">func ToLower(s string) string</a></li>
<li><a href="#ToLowerSpecial">func ToLowerSpecial(c unicode.SpecialCase, s string) string</a></li>
<li><a href="#ToTitle">func ToTitle(s string) string</a></li>
<li><a href="#ToTitleSpecial">func ToTitleSpecial(c unicode.SpecialCase, s string) string</a></li>
<li><a href="#ToUpper">func ToUpper(s string) string</a></li>
<li><a href="#ToUpperSpecial">func ToUpperSpecial(c unicode.SpecialCase, s string) string</a></li>
<li><a href="#ToValidUTF8">func ToValidUTF8(s, replacement string) string</a></li>
<li><a href="#Trim">func Trim(s string, cutset string) string</a></li>
<li><a href="#TrimFunc">func TrimFunc(s string, f func(rune) bool) string</a></li>
<li><a href="#TrimLeft">func TrimLeft(s string, cutset string) string</a></li>
<li><a href="#TrimLeftFunc">func TrimLeftFunc(s string, f func(rune) bool) string</a></li>
<li><a href="#TrimPrefix">func TrimPrefix(s, prefix string) string</a></li>
<li><a href="#TrimRight">func TrimRight(s string, cutset string) string</a></li>
<li><a href="#TrimRightFunc">func TrimRightFunc(s string, f func(rune) bool) string</a></li>
<li><a href="#TrimSpace">func TrimSpace(s string) string</a></li>
<li><a href="#TrimSuffix">func TrimSuffix(s, suffix string) string</a></li>
<li><a href="#Builder">type Builder</a></li>
<li> <a href="#Builder.Cap">func (b *Builder) Cap() int</a>
</li>
<li> <a href="#Builder.Grow">func (b *Builder) Grow(n int)</a>
</li>
<li> <a href="#Builder.Len">func (b *Builder) Len() int</a>
</li>
<li> <a href="#Builder.Reset">func (b *Builder) Reset()</a>
</li>
<li> <a href="#Builder.String">func (b *Builder) String() string</a>
</li>
<li> <a href="#Builder.Write">func (b *Builder) Write(p []byte) (int, error)</a>
</li>
<li> <a href="#Builder.WriteByte">func (b *Builder) WriteByte(c byte) error</a>
</li>
<li> <a href="#Builder.WriteRune">func (b *Builder) WriteRune(r rune) (int, error)</a>
</li>
<li> <a href="#Builder.WriteString">func (b *Builder) WriteString(s string) (int, error)</a>
</li>
<li><a href="#Reader">type Reader</a></li>
<li> <a href="#NewReader">func NewReader(s string) *Reader</a>
</li>
<li> <a href="#Reader.Len">func (r *Reader) Len() int</a>
</li>
<li> <a href="#Reader.Read">func (r *Reader) Read(b []byte) (n int, err error)</a>
</li>
<li> <a href="#Reader.ReadAt">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</a>
</li>
<li> <a href="#Reader.ReadByte">func (r *Reader) ReadByte() (byte, error)</a>
</li>
<li> <a href="#Reader.ReadRune">func (r *Reader) ReadRune() (ch rune, size int, err error)</a>
</li>
<li> <a href="#Reader.Reset">func (r *Reader) Reset(s string)</a>
</li>
<li> <a href="#Reader.Seek">func (r *Reader) Seek(offset int64, whence int) (int64, error)</a>
</li>
<li> <a href="#Reader.Size">func (r *Reader) Size() int64</a>
</li>
<li> <a href="#Reader.UnreadByte">func (r *Reader) UnreadByte() error</a>
</li>
<li> <a href="#Reader.UnreadRune">func (r *Reader) UnreadRune() error</a>
</li>
<li> <a href="#Reader.WriteTo">func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</a>
</li>
<li><a href="#Replacer">type Replacer</a></li>
<li> <a href="#NewReplacer">func NewReplacer(oldnew ...string) *Replacer</a>
</li>
<li> <a href="#Replacer.Replace">func (r *Replacer) Replace(s string) string</a>
</li>
<li> <a href="#Replacer.WriteString">func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)</a>
</li>
<li><a href="#pkg-note-BUG">Bugs</a></li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_Builder">Builder</a></dd> <dd><a class="exampleLink" href="#example_Compare">Compare</a></dd> <dd><a class="exampleLink" href="#example_Contains">Contains</a></dd> <dd><a class="exampleLink" href="#example_ContainsAny">ContainsAny</a></dd> <dd><a class="exampleLink" href="#example_ContainsRune">ContainsRune</a></dd> <dd><a class="exampleLink" href="#example_Count">Count</a></dd> <dd><a class="exampleLink" href="#example_EqualFold">EqualFold</a></dd> <dd><a class="exampleLink" href="#example_Fields">Fields</a></dd> <dd><a class="exampleLink" href="#example_FieldsFunc">FieldsFunc</a></dd> <dd><a class="exampleLink" href="#example_HasPrefix">HasPrefix</a></dd> <dd><a class="exampleLink" href="#example_HasSuffix">HasSuffix</a></dd> <dd><a class="exampleLink" href="#example_Index">Index</a></dd> <dd><a class="exampleLink" href="#example_IndexAny">IndexAny</a></dd> <dd><a class="exampleLink" href="#example_IndexByte">IndexByte</a></dd> <dd><a class="exampleLink" href="#example_IndexFunc">IndexFunc</a></dd> <dd><a class="exampleLink" href="#example_IndexRune">IndexRune</a></dd> <dd><a class="exampleLink" href="#example_Join">Join</a></dd> <dd><a class="exampleLink" href="#example_LastIndex">LastIndex</a></dd> <dd><a class="exampleLink" href="#example_LastIndexAny">LastIndexAny</a></dd> <dd><a class="exampleLink" href="#example_LastIndexByte">LastIndexByte</a></dd> <dd><a class="exampleLink" href="#example_LastIndexFunc">LastIndexFunc</a></dd> <dd><a class="exampleLink" href="#example_Map">Map</a></dd> <dd><a class="exampleLink" href="#example_NewReplacer">NewReplacer</a></dd> <dd><a class="exampleLink" href="#example_Repeat">Repeat</a></dd> <dd><a class="exampleLink" href="#example_Replace">Replace</a></dd> <dd><a class="exampleLink" href="#example_ReplaceAll">ReplaceAll</a></dd> <dd><a class="exampleLink" href="#example_Split">Split</a></dd> <dd><a class="exampleLink" href="#example_SplitAfter">SplitAfter</a></dd> <dd><a class="exampleLink" href="#example_SplitAfterN">SplitAfterN</a></dd> <dd><a class="exampleLink" href="#example_SplitN">SplitN</a></dd> <dd><a class="exampleLink" href="#example_Title">Title</a></dd> <dd><a class="exampleLink" href="#example_ToLower">ToLower</a></dd> <dd><a class="exampleLink" href="#example_ToLowerSpecial">ToLowerSpecial</a></dd> <dd><a class="exampleLink" href="#example_ToTitle">ToTitle</a></dd> <dd><a class="exampleLink" href="#example_ToTitleSpecial">ToTitleSpecial</a></dd> <dd><a class="exampleLink" href="#example_ToUpper">ToUpper</a></dd> <dd><a class="exampleLink" href="#example_ToUpperSpecial">ToUpperSpecial</a></dd> <dd><a class="exampleLink" href="#example_Trim">Trim</a></dd> <dd><a class="exampleLink" href="#example_TrimFunc">TrimFunc</a></dd> <dd><a class="exampleLink" href="#example_TrimLeft">TrimLeft</a></dd> <dd><a class="exampleLink" href="#example_TrimLeftFunc">TrimLeftFunc</a></dd> <dd><a class="exampleLink" href="#example_TrimPrefix">TrimPrefix</a></dd> <dd><a class="exampleLink" href="#example_TrimRight">TrimRight</a></dd> <dd><a class="exampleLink" href="#example_TrimRightFunc">TrimRightFunc</a></dd> <dd><a class="exampleLink" href="#example_TrimSpace">TrimSpace</a></dd> <dd><a class="exampleLink" href="#example_TrimSuffix">TrimSuffix</a></dd> </dl> </div> <h3>Package files</h3> <p>  <a href="https://golang.org/src/strings/builder.go" target="_blank">builder.go</a> <a href="https://golang.org/src/strings/compare.go" target="_blank">compare.go</a> <a href="https://golang.org/src/strings/reader.go" target="_blank">reader.go</a> <a href="https://golang.org/src/strings/replace.go" target="_blank">replace.go</a> <a href="https://golang.org/src/strings/search.go" target="_blank">search.go</a> <a href="https://golang.org/src/strings/strings.go" target="_blank">strings.go</a>  </p>   <h2 id="Compare">func Compare<a href="https://golang.org/src/strings/compare.go?s=490:519#L3" class="source" target="_blank">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func Compare(a, b string) int</pre> <p> Compare returns an integer comparing two strings lexicographically. The result will be 0 if a==b, -1 if a &lt; b, and +1 if a &gt; b. </p> <p> Compare is included only for symmetry with package bytes. It is usually clearer and always faster to use the built-in string comparison operators ==, &lt;, &gt;, and so on. </p>    <h4 id="example_Compare"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.Compare("a", "b"))
	fmt.Println(strings.Compare("a", "a"))
	fmt.Println(strings.Compare("b", "a"))
}
</pre>   <h2 id="Contains">func Contains<a href="https://golang.org/src/strings/strings.go?s=2326:2362#L88" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Contains(s, substr string) bool</pre> <p> Contains reports whether substr is within s. </p>    <h4 id="example_Contains"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.Contains("seafood", "foo"))
	fmt.Println(strings.Contains("seafood", "bar"))
	fmt.Println(strings.Contains("seafood", ""))
	fmt.Println(strings.Contains("", ""))
}
</pre>   <h2 id="ContainsAny">func ContainsAny<a href="https://golang.org/src/strings/strings.go?s=2476:2514#L93" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ContainsAny(s, chars string) bool</pre> <p> ContainsAny reports whether any Unicode code points in chars are within s. </p>    <h4 id="example_ContainsAny"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.ContainsAny("team", "i"))
	fmt.Println(strings.ContainsAny("fail", "ui"))
	fmt.Println(strings.ContainsAny("ure", "ui"))
	fmt.Println(strings.ContainsAny("failure", "ui"))
	fmt.Println(strings.ContainsAny("foo", ""))
	fmt.Println(strings.ContainsAny("", ""))
}
</pre>   <h2 id="ContainsRune">func ContainsRune<a href="https://golang.org/src/strings/strings.go?s=2622:2662#L98" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ContainsRune(s string, r rune) bool</pre> <p> ContainsRune reports whether the Unicode code point r is within s. </p>    <h4 id="example_ContainsRune"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	// Finds whether a string contains a particular Unicode code point.
	// The code point for the lowercase letter "a", for example, is 97.
	fmt.Println(strings.ContainsRune("aardvark", 97))
	fmt.Println(strings.ContainsRune("timeout", 97))
}
</pre>   <h2 id="Count">func Count<a href="https://golang.org/src/strings/strings.go?s=1986:2018#L68" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Count(s, substr string) int</pre> <p> Count counts the number of non-overlapping instances of substr in s. If substr is an empty string, Count returns 1 + the number of Unicode code points in s. </p>    <h4 id="example_Count"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.Count("cheese", "e"))
	fmt.Println(strings.Count("five", "")) // before &amp; after each rune
}
</pre>   <h2 id="EqualFold">func EqualFold<a href="https://golang.org/src/strings/strings.go?s=24676:24708#L963" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func EqualFold(s, t string) bool</pre> <p> EqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under Unicode case-folding. </p>    <h4 id="example_EqualFold"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.EqualFold("Go", "go"))
}
</pre>   <h2 id="Fields">func Fields<a href="https://golang.org/src/strings/strings.go?s=8396:8426#L319" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Fields(s string) []string</pre> <p> Fields splits the string s around each instance of one or more consecutive white space characters, as defined by unicode.IsSpace, returning a slice of substrings of s or an empty slice if s contains only white space. </p>    <h4 id="example_Fields"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Printf("Fields are: %q", strings.Fields("  foo bar  baz   "))
}
</pre>   <h2 id="FieldsFunc">func FieldsFunc<a href="https://golang.org/src/strings/strings.go?s=9792:9845#L373" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func FieldsFunc(s string, f func(rune) bool) []string</pre> <p> FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c) and returns an array of slices of s. If all code points in s satisfy f(c) or the string is empty, an empty slice is returned. FieldsFunc makes no guarantees about the order in which it calls f(c). If f does not return consistent results for a given c, FieldsFunc may crash. </p>    <h4 id="example_FieldsFunc"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
	"unicode"
)

func main() {
	f := func(c rune) bool {
		return !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c)
	}
	fmt.Printf("Fields are: %q", strings.FieldsFunc("  foo1;bar2,baz3...", f))
}
</pre>   <h2 id="HasPrefix">func HasPrefix<a href="https://golang.org/src/strings/strings.go?s=11153:11190#L438" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func HasPrefix(s, prefix string) bool</pre> <p> HasPrefix tests whether the string s begins with prefix. </p>    <h4 id="example_HasPrefix"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.HasPrefix("Gopher", "Go"))
	fmt.Println(strings.HasPrefix("Gopher", "C"))
	fmt.Println(strings.HasPrefix("Gopher", ""))
}
</pre>   <h2 id="HasSuffix">func HasSuffix<a href="https://golang.org/src/strings/strings.go?s=11314:11351#L443" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func HasSuffix(s, suffix string) bool</pre> <p> HasSuffix tests whether the string s ends with suffix. </p>    <h4 id="example_HasSuffix"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.HasSuffix("Amigo", "go"))
	fmt.Println(strings.HasSuffix("Amigo", "O"))
	fmt.Println(strings.HasSuffix("Amigo", "Ami"))
	fmt.Println(strings.HasSuffix("Amigo", ""))
}
</pre>   <h2 id="Index">func Index<a href="https://golang.org/src/strings/strings.go?s=25852:25884#L1017" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Index(s, substr string) int</pre> <p> Index returns the index of the first instance of substr in s, or -1 if substr is not present in s. </p>    <h4 id="example_Index"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.Index("chicken", "ken"))
	fmt.Println(strings.Index("chicken", "dmr"))
}
</pre>   <h2 id="IndexAny">func IndexAny<a href="https://golang.org/src/strings/strings.go?s=4328:4362#L168" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func IndexAny(s, chars string) int</pre> <p> IndexAny returns the index of the first instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s. </p>    <h4 id="example_IndexAny"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.IndexAny("chicken", "aeiouy"))
	fmt.Println(strings.IndexAny("crwth", "aeiouy"))
}
</pre>   <h2 id="IndexByte">func IndexByte<a href="https://golang.org/src/strings/strings.go?s=3564:3600#L140" class="source" target="_blank">Source</a>  <span title="Added in Go 1.2">1.2</span> </h2> <pre data-language="go">func IndexByte(s string, c byte) int</pre> <p> IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s. </p>    <h4 id="example_IndexByte"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.IndexByte("golang", 'g'))
	fmt.Println(strings.IndexByte("gophers", 'h'))
	fmt.Println(strings.IndexByte("golang", 'x'))
}
</pre>   <h2 id="IndexFunc">func IndexFunc<a href="https://golang.org/src/strings/strings.go?s=18737:18784#L752" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func IndexFunc(s string, f func(rune) bool) int</pre> <p> IndexFunc returns the index into s of the first Unicode code point satisfying f(c), or -1 if none do. </p>    <h4 id="example_IndexFunc"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
	"unicode"
)

func main() {
	f := func(c rune) bool {
		return unicode.Is(unicode.Han, c)
	}
	fmt.Println(strings.IndexFunc("Hello, 世界", f))
	fmt.Println(strings.IndexFunc("Hello, world", f))
}
</pre>   <h2 id="IndexRune">func IndexRune<a href="https://golang.org/src/strings/strings.go?s=3860:3896#L148" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func IndexRune(s string, r rune) int</pre> <p> IndexRune returns the index of the first instance of the Unicode code point r, or -1 if rune is not present in s. If r is utf8.RuneError, it returns the first instance of any invalid UTF-8 byte sequence. </p>    <h4 id="example_IndexRune"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.IndexRune("chicken", 'k'))
	fmt.Println(strings.IndexRune("chicken", 'd'))
}
</pre>   <h2 id="Join">func Join<a href="https://golang.org/src/strings/strings.go?s=10765:10805#L415" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Join(a []string, sep string) string</pre> <p> Join concatenates the elements of a to create a single string. The separator string sep is placed between elements in the resulting string. </p>    <h4 id="example_Join"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	s := []string{"foo", "bar", "baz"}
	fmt.Println(strings.Join(s, ", "))
}
</pre>   <h2 id="LastIndex">func LastIndex<a href="https://golang.org/src/strings/strings.go?s=2802:2838#L103" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LastIndex(s, substr string) int</pre> <p> LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s. </p>    <h4 id="example_LastIndex"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.Index("go gopher", "go"))
	fmt.Println(strings.LastIndex("go gopher", "go"))
	fmt.Println(strings.LastIndex("go gopher", "rodent"))
}
</pre>   <h2 id="LastIndexAny">func LastIndexAny<a href="https://golang.org/src/strings/strings.go?s=4869:4907#L196" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LastIndexAny(s, chars string) int</pre> <p> LastIndexAny returns the index of the last instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s. </p>    <h4 id="example_LastIndexAny"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.LastIndexAny("go gopher", "go"))
	fmt.Println(strings.LastIndexAny("go gopher", "rodent"))
	fmt.Println(strings.LastIndexAny("go gopher", "fail"))
}
</pre>   <h2 id="LastIndexByte">func LastIndexByte<a href="https://golang.org/src/strings/strings.go?s=5419:5459#L224" class="source" target="_blank">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func LastIndexByte(s string, c byte) int</pre> <p> LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s. </p>    <h4 id="example_LastIndexByte"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.LastIndexByte("Hello, world", 'l'))
	fmt.Println(strings.LastIndexByte("Hello, world", 'o'))
	fmt.Println(strings.LastIndexByte("Hello, world", 'x'))
}
</pre>   <h2 id="LastIndexFunc">func LastIndexFunc<a href="https://golang.org/src/strings/strings.go?s=18931:18982#L758" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LastIndexFunc(s string, f func(rune) bool) int</pre> <p> LastIndexFunc returns the index into s of the last Unicode code point satisfying f(c), or -1 if none do. </p>    <h4 id="example_LastIndexFunc"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
	"unicode"
)

func main() {
	fmt.Println(strings.LastIndexFunc("go 123", unicode.IsNumber))
	fmt.Println(strings.LastIndexFunc("123 go", unicode.IsNumber))
	fmt.Println(strings.LastIndexFunc("go", unicode.IsNumber))
}
</pre>   <h2 id="Map">func Map<a href="https://golang.org/src/strings/strings.go?s=11634:11684#L450" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Map(mapping func(rune) rune, s string) string</pre> <p> Map returns a copy of the string s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the string with no replacement. </p>    <h4 id="example_Map"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	rot13 := func(r rune) rune {
		switch {
		case r &gt;= 'A' &amp;&amp; r &lt;= 'Z':
			return 'A' + (r-'A'+13)%26
		case r &gt;= 'a' &amp;&amp; r &lt;= 'z':
			return 'a' + (r-'a'+13)%26
		}
		return r
	}
	fmt.Println(strings.Map(rot13, "'Twas brillig and the slithy gopher..."))
}
</pre>   <h2 id="Repeat">func Repeat<a href="https://golang.org/src/strings/strings.go?s=12987:13026#L513" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Repeat(s string, count int) string</pre> <p> Repeat returns a new string consisting of count copies of the string s. </p> <p> It panics if count is negative or if the result of (len(s) * count) overflows. </p>    <h4 id="example_Repeat"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println("ba" + strings.Repeat("na", 2))
}
</pre>   <h2 id="Replace">func Replace<a href="https://golang.org/src/strings/strings.go?s=23551:23597#L918" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Replace(s, old, new string, n int) string</pre> <p> Replace returns a copy of the string s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string. If n &lt; 0, there is no limit on the number of replacements. </p>    <h4 id="example_Replace"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.Replace("oink oink oink", "k", "ky", 2))
	fmt.Println(strings.Replace("oink oink oink", "oink", "moo", -1))
}
</pre>   <h2 id="ReplaceAll">func ReplaceAll<a href="https://golang.org/src/strings/strings.go?s=24486:24528#L957" class="source" target="_blank">Source</a>  <span title="Added in Go 1.12">1.12</span> </h2> <pre data-language="go">func ReplaceAll(s, old, new string) string</pre> <p> ReplaceAll returns a copy of the string s with all non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string. </p>    <h4 id="example_ReplaceAll"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.ReplaceAll("oink oink oink", "oink", "moo"))
}
</pre>   <h2 id="Split">func Split<a href="https://golang.org/src/strings/strings.go?s=7505:7539#L298" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Split(s, sep string) []string</pre> <p> Split slices s into all substrings separated by sep and returns a slice of the substrings between those separators. </p> <p> If s does not contain sep and sep is not empty, Split returns a slice of length 1 whose only element is s. </p> <p> If sep is empty, Split splits after each UTF-8 sequence. If both s and sep are empty, Split returns an empty slice. </p> <p> It is equivalent to SplitN with a count of -1. </p>    <h4 id="example_Split"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Printf("%q\n", strings.Split("a,b,c", ","))
	fmt.Printf("%q\n", strings.Split("a man a plan a canal panama", "a "))
	fmt.Printf("%q\n", strings.Split(" xyz ", ""))
	fmt.Printf("%q\n", strings.Split("", "Bernardo O'Higgins"))
}
</pre>   <h2 id="SplitAfter">func SplitAfter<a href="https://golang.org/src/strings/strings.go?s=8004:8043#L310" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func SplitAfter(s, sep string) []string</pre> <p> SplitAfter slices s into all substrings after each instance of sep and returns a slice of those substrings. </p> <p> If s does not contain sep and sep is not empty, SplitAfter returns a slice of length 1 whose only element is s. </p> <p> If sep is empty, SplitAfter splits after each UTF-8 sequence. If both s and sep are empty, SplitAfter returns an empty slice. </p> <p> It is equivalent to SplitAfterN with a count of -1. </p>    <h4 id="example_SplitAfter"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Printf("%q\n", strings.SplitAfter("a,b,c", ","))
}
</pre>   <h2 id="SplitAfterN">func SplitAfterN<a href="https://golang.org/src/strings/strings.go?s=6998:7045#L284" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func SplitAfterN(s, sep string, n int) []string</pre> <p> SplitAfterN slices s into substrings after each instance of sep and returns a slice of those substrings. </p> <p> The count determines the number of substrings to return: </p> <pre data-language="go">n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.
n == 0: the result is nil (zero substrings)
n &lt; 0: all substrings
</pre> <p> Edge cases for s and sep (for example, empty strings) are handled as described in the documentation for SplitAfter. </p>    <h4 id="example_SplitAfterN"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Printf("%q\n", strings.SplitAfterN("a,b,c", ",", 2))
}
</pre>   <h2 id="SplitN">func SplitN<a href="https://golang.org/src/strings/strings.go?s=6461:6503#L272" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func SplitN(s, sep string, n int) []string</pre> <p> SplitN slices s into substrings separated by sep and returns a slice of the substrings between those separators. </p> <p> The count determines the number of substrings to return: </p> <pre data-language="go">n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.
n == 0: the result is nil (zero substrings)
n &lt; 0: all substrings
</pre> <p> Edge cases for s and sep (for example, empty strings) are handled as described in the documentation for Split. </p>    <h4 id="example_SplitN"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Printf("%q\n", strings.SplitN("a,b,c", ",", 2))
	z := strings.SplitN("a,b,c", ",", 0)
	fmt.Printf("%q (nil = %v)\n", z, z == nil)
}
</pre>   <h2 id="Title">func Title<a href="https://golang.org/src/strings/strings.go?s=17489:17516#L704" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Title(s string) string</pre> <p> Title returns a copy of the string s with all Unicode letters that begin words mapped to their Unicode title case. </p> <p> BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly. </p>    <h4 id="example_Title"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	// Compare this example to the ToTitle example.
	fmt.Println(strings.Title("her royal highness"))
	fmt.Println(strings.Title("loud noises"))
	fmt.Println(strings.Title("хлеб"))
}
</pre>   <h2 id="ToLower">func ToLower<a href="https://golang.org/src/strings/strings.go?s=14252:14281#L574" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ToLower(s string) string</pre> <p> ToLower returns s with all Unicode letters mapped to their lower case. </p>    <h4 id="example_ToLower"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.ToLower("Gopher"))
}
</pre>   <h2 id="ToLowerSpecial">func ToLowerSpecial<a href="https://golang.org/src/strings/strings.go?s=15314:15373#L615" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ToLowerSpecial(c unicode.SpecialCase, s string) string</pre> <p> ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their lower case using the case mapping specified by c. </p>    <h4 id="example_ToLowerSpecial"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
	"unicode"
)

func main() {
	fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, "Önnek İş"))
}
</pre>   <h2 id="ToTitle">func ToTitle<a href="https://golang.org/src/strings/strings.go?s=14871:14900#L605" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ToTitle(s string) string</pre> <p> ToTitle returns a copy of the string s with all Unicode letters mapped to their Unicode title case. </p>    <h4 id="example_ToTitle"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	// Compare this example to the Title example.
	fmt.Println(strings.ToTitle("her royal highness"))
	fmt.Println(strings.ToTitle("loud noises"))
	fmt.Println(strings.ToTitle("хлеб"))
}
</pre>   <h2 id="ToTitleSpecial">func ToTitleSpecial<a href="https://golang.org/src/strings/strings.go?s=15563:15622#L621" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ToTitleSpecial(c unicode.SpecialCase, s string) string</pre> <p> ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their Unicode title case, giving priority to the special casing rules. </p>    <h4 id="example_ToTitleSpecial"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
	"unicode"
)

func main() {
	fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, "dünyanın ilk borsa yapısı Aizonai kabul edilir"))
}
</pre>   <h2 id="ToUpper">func ToUpper<a href="https://golang.org/src/strings/strings.go?s=13665:13694#L544" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ToUpper(s string) string</pre> <p> ToUpper returns s with all Unicode letters mapped to their upper case. </p>    <h4 id="example_ToUpper"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.ToUpper("Gopher"))
}
</pre>   <h2 id="ToUpperSpecial">func ToUpperSpecial<a href="https://golang.org/src/strings/strings.go?s=15080:15139#L609" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ToUpperSpecial(c unicode.SpecialCase, s string) string</pre> <p> ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their upper case using the case mapping specified by c. </p>    <h4 id="example_ToUpperSpecial"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
	"unicode"
)

func main() {
	fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, "örnek iş"))
}
</pre>   <h2 id="ToValidUTF8">func ToValidUTF8<a href="https://golang.org/src/strings/strings.go?s=15805:15851#L627" class="source" target="_blank">Source</a>  <span title="Added in Go 1.13">1.13</span> </h2> <pre data-language="go">func ToValidUTF8(s, replacement string) string</pre> <p> ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences replaced by the replacement string, which may be empty. </p> <h2 id="Trim">func Trim<a href="https://golang.org/src/strings/strings.go?s=21049:21090#L830" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Trim(s string, cutset string) string</pre> <p> Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed. </p>    <h4 id="example_Trim"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Print(strings.Trim("¡¡¡Hello, Gophers!!!", "!¡"))
}
</pre>   <h2 id="TrimFunc">func TrimFunc<a href="https://golang.org/src/strings/strings.go?s=18529:18578#L746" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func TrimFunc(s string, f func(rune) bool) string</pre> <p> TrimFunc returns a slice of the string s with all leading and trailing Unicode code points c satisfying f(c) removed. </p>    <h4 id="example_TrimFunc"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
	"unicode"
)

func main() {
	fmt.Print(strings.TrimFunc("¡¡¡Hello, Gophers!!!", func(r rune) bool {
		return !unicode.IsLetter(r) &amp;&amp; !unicode.IsNumber(r)
	}))
}
</pre>   <h2 id="TrimLeft">func TrimLeft<a href="https://golang.org/src/strings/strings.go?s=21347:21392#L841" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func TrimLeft(s string, cutset string) string</pre> <p> TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed. </p> <p> To remove a prefix, use TrimPrefix instead. </p>    <h4 id="example_TrimLeft"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Print(strings.TrimLeft("¡¡¡Hello, Gophers!!!", "!¡"))
}
</pre>   <h2 id="TrimLeftFunc">func TrimLeftFunc<a href="https://golang.org/src/strings/strings.go?s=17938:17991#L723" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func TrimLeftFunc(s string, f func(rune) bool) string</pre> <p> TrimLeftFunc returns a slice of the string s with all leading Unicode code points c satisfying f(c) removed. </p>    <h4 id="example_TrimLeftFunc"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
	"unicode"
)

func main() {
	fmt.Print(strings.TrimLeftFunc("¡¡¡Hello, Gophers!!!", func(r rune) bool {
		return !unicode.IsLetter(r) &amp;&amp; !unicode.IsNumber(r)
	}))
}
</pre>   <h2 id="TrimPrefix">func TrimPrefix<a href="https://golang.org/src/strings/strings.go?s=22869:22909#L896" class="source" target="_blank">Source</a>  <span title="Added in Go 1.1">1.1</span> </h2> <pre data-language="go">func TrimPrefix(s, prefix string) string</pre> <p> TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged. </p>    <h4 id="example_TrimPrefix"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	var s = "¡¡¡Hello, Gophers!!!"
	s = strings.TrimPrefix(s, "¡¡¡Hello, ")
	s = strings.TrimPrefix(s, "¡¡¡Howdy, ")
	fmt.Print(s)
}
</pre>   <h2 id="TrimRight">func TrimRight<a href="https://golang.org/src/strings/strings.go?s=21656:21702#L852" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func TrimRight(s string, cutset string) string</pre> <p> TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed. </p> <p> To remove a suffix, use TrimSuffix instead. </p>    <h4 id="example_TrimRight"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Print(strings.TrimRight("¡¡¡Hello, Gophers!!!", "!¡"))
}
</pre>   <h2 id="TrimRightFunc">func TrimRightFunc<a href="https://golang.org/src/strings/strings.go?s=18186:18240#L733" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func TrimRightFunc(s string, f func(rune) bool) string</pre> <p> TrimRightFunc returns a slice of the string s with all trailing Unicode code points c satisfying f(c) removed. </p>    <h4 id="example_TrimRightFunc"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
	"unicode"
)

func main() {
	fmt.Print(strings.TrimRightFunc("¡¡¡Hello, Gophers!!!", func(r rune) bool {
		return !unicode.IsLetter(r) &amp;&amp; !unicode.IsNumber(r)
	}))
}
</pre>   <h2 id="TrimSpace">func TrimSpace<a href="https://golang.org/src/strings/strings.go?s=21924:21955#L861" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func TrimSpace(s string) string</pre> <p> TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode. </p>    <h4 id="example_TrimSpace"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.TrimSpace(" \t\n Hello, Gophers \n\t\r\n"))
}
</pre>   <h2 id="TrimSuffix">func TrimSuffix<a href="https://golang.org/src/strings/strings.go?s=23107:23147#L905" class="source" target="_blank">Source</a>  <span title="Added in Go 1.1">1.1</span> </h2> <pre data-language="go">func TrimSuffix(s, suffix string) string</pre> <p> TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged. </p>    <h4 id="example_TrimSuffix"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	var s = "¡¡¡Hello, Gophers!!!"
	s = strings.TrimSuffix(s, ", Gophers!!!")
	s = strings.TrimSuffix(s, ", Marmots!!!")
	fmt.Print(s)
}
</pre>   <h2 id="Builder">type Builder<a href="https://golang.org/src/strings/builder.go?s=386:479#L5" class="source" target="_blank">Source</a>  <span title="Added in Go 1.10">1.10</span> </h2> <p> A Builder is used to efficiently build a string using Write methods. It minimizes memory copying. The zero value is ready to use. Do not copy a non-zero Builder. </p> <pre data-language="go">type Builder struct {
    // contains filtered or unexported fields
}
</pre>    <h4 id="example_Builder"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	var b strings.Builder
	for i := 3; i &gt;= 1; i-- {
		fmt.Fprintf(&amp;b, "%d...", i)
	}
	b.WriteString("ignition")
	fmt.Println(b.String())

}
</pre>   <h3 id="Builder.Cap">func (*Builder) Cap<a href="https://golang.org/src/strings/builder.go?s=1761:1788#L46" class="source" target="_blank">Source</a>  <span title="Added in Go 1.12">1.12</span> </h3> <pre data-language="go">func (b *Builder) Cap() int</pre> <p> Cap returns the capacity of the builder's underlying byte slice. It is the total space allocated for the string being built and includes any bytes already written. </p> <h3 id="Builder.Grow">func (*Builder) Grow<a href="https://golang.org/src/strings/builder.go?s=2344:2373#L65" class="source" target="_blank">Source</a>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (b *Builder) Grow(n int)</pre> <p> Grow grows b's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to b without another allocation. If n is negative, Grow panics. </p> <h3 id="Builder.Len">func (*Builder) Len<a href="https://golang.org/src/strings/builder.go?s=1537:1564#L41" class="source" target="_blank">Source</a>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (b *Builder) Len() int</pre> <p> Len returns the number of accumulated bytes; b.Len() == len(b.String()). </p> <h3 id="Builder.Reset">func (*Builder) Reset<a href="https://golang.org/src/strings/builder.go?s=1853:1878#L49" class="source" target="_blank">Source</a>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (b *Builder) Reset()</pre> <p> Reset resets the Builder to be empty. </p> <h3 id="Builder.String">func (*Builder) String<a href="https://golang.org/src/strings/builder.go?s=1379:1412#L36" class="source" target="_blank">Source</a>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (b *Builder) String() string</pre> <p> String returns the accumulated string. </p> <h3 id="Builder.Write">func (*Builder) Write<a href="https://golang.org/src/strings/builder.go?s=2591:2637#L77" class="source" target="_blank">Source</a>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (b *Builder) Write(p []byte) (int, error)</pre> <p> Write appends the contents of p to b's buffer. Write always returns len(p), nil. </p> <h3 id="Builder.WriteByte">func (*Builder) WriteByte<a href="https://golang.org/src/strings/builder.go?s=2791:2832#L85" class="source" target="_blank">Source</a>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (b *Builder) WriteByte(c byte) error</pre> <p> WriteByte appends the byte c to b's buffer. The returned error is always nil. </p> <h3 id="Builder.WriteRune">func (*Builder) WriteRune<a href="https://golang.org/src/strings/builder.go?s=3017:3065#L93" class="source" target="_blank">Source</a>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (b *Builder) WriteRune(r rune) (int, error)</pre> <p> WriteRune appends the UTF-8 encoding of Unicode code point r to b's buffer. It returns the length of r and a nil error. </p> <h3 id="Builder.WriteString">func (*Builder) WriteString<a href="https://golang.org/src/strings/builder.go?s=3425:3477#L110" class="source" target="_blank">Source</a>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (b *Builder) WriteString(s string) (int, error)</pre> <p> WriteString appends the contents of s to b's buffer. It returns the length of s and a nil error. </p> <h2 id="Reader">type Reader<a href="https://golang.org/src/strings/reader.go?s=446:576#L7" class="source" target="_blank">Source</a>  </h2> <p> A Reader implements the io.Reader, io.ReaderAt, io.Seeker, io.WriterTo, io.ByteScanner, and io.RuneScanner interfaces by reading from a string. The zero value for Reader operates like a Reader of an empty string. </p> <pre data-language="go">type Reader struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewReader">func NewReader<a href="https://golang.org/src/strings/reader.go?s=3567:3599#L144" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func NewReader(s string) *Reader</pre> <p> NewReader returns a new Reader reading from s. It is similar to bytes.NewBufferString but more efficient and read-only. </p> <h3 id="Reader.Len">func (*Reader) Len<a href="https://golang.org/src/strings/reader.go?s=653:679#L15" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Reader) Len() int</pre> <p> Len returns the number of bytes of the unread portion of the string. </p> <h3 id="Reader.Read">func (*Reader) Read<a href="https://golang.org/src/strings/reader.go?s=1042:1092#L28" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Reader) Read(b []byte) (n int, err error)</pre> <h3 id="Reader.ReadAt">func (*Reader) ReadAt<a href="https://golang.org/src/strings/reader.go?s=1215:1278#L38" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</pre> <h3 id="Reader.ReadByte">func (*Reader) ReadByte<a href="https://golang.org/src/strings/reader.go?s=1526:1567#L53" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Reader) ReadByte() (byte, error)</pre> <h3 id="Reader.ReadRune">func (*Reader) ReadRune<a href="https://golang.org/src/strings/reader.go?s=1846:1904#L72" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Reader) ReadRune() (ch rune, size int, err error)</pre> <h3 id="Reader.Reset">func (*Reader) Reset<a href="https://golang.org/src/strings/reader.go?s=3381:3413#L140" class="source" target="_blank">Source</a>  <span title="Added in Go 1.7">1.7</span> </h3> <pre data-language="go">func (r *Reader) Reset(s string)</pre> <p> Reset resets the Reader to be reading from s. </p> <h3 id="Reader.Seek">func (*Reader) Seek<a href="https://golang.org/src/strings/reader.go?s=2495:2557#L100" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Reader) Seek(offset int64, whence int) (int64, error)</pre> <p> Seek implements the io.Seeker interface. </p> <h3 id="Reader.Size">func (*Reader) Size<a href="https://golang.org/src/strings/reader.go?s=984:1013#L26" class="source" target="_blank">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (r *Reader) Size() int64</pre> <p> Size returns the original length of the underlying string. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method. </p> <h3 id="Reader.UnreadByte">func (*Reader) UnreadByte<a href="https://golang.org/src/strings/reader.go?s=1678:1713#L63" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Reader) UnreadByte() error</pre> <h3 id="Reader.UnreadRune">func (*Reader) UnreadRune<a href="https://golang.org/src/strings/reader.go?s=2155:2190#L87" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Reader) UnreadRune() error</pre> <h3 id="Reader.WriteTo">func (*Reader) WriteTo<a href="https://golang.org/src/strings/reader.go?s=2975:3033#L121" class="source" target="_blank">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</pre> <p> WriteTo implements the io.WriterTo interface. </p> <h2 id="Replacer">type Replacer<a href="https://golang.org/src/strings/replace.go?s=318:421#L4" class="source" target="_blank">Source</a>  </h2> <p> Replacer replaces a list of strings with replacements. It is safe for concurrent use by multiple goroutines. </p> <pre data-language="go">type Replacer struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewReplacer">func NewReplacer<a href="https://golang.org/src/strings/replace.go?s=916:960#L22" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func NewReplacer(oldnew ...string) *Replacer</pre> <p> NewReplacer returns a new Replacer from a list of old, new string pairs. Replacements are performed in the order they appear in the target string, without overlapping matches. The old string comparisons are done in argument order. </p> <p> NewReplacer panics if given an odd number of arguments. </p>    <h4 id="example_NewReplacer"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"strings"
)

func main() {
	r := strings.NewReplacer("&lt;", "&amp;lt;", "&gt;", "&amp;gt;")
	fmt.Println(r.Replace("This is &lt;b&gt;HTML&lt;/b&gt;!"))
}
</pre>   <h3 id="Replacer.Replace">func (*Replacer) Replace<a href="https://golang.org/src/strings/replace.go?s=2497:2540#L85" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Replacer) Replace(s string) string</pre> <p> Replace returns a copy of s with all replacements performed. </p> <h3 id="Replacer.WriteString">func (*Replacer) WriteString<a href="https://golang.org/src/strings/replace.go?s=2655:2727#L91" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)</pre> <p> WriteString writes s to w with all replacements performed. </p> <h2 id="pkg-note-BUG">Bugs</h2> <ul> <li>
<a href="https://golang.org/src/strings/strings.go?s=17390:17488#L703" style="float: left;" target="_blank">☞</a> <p> The rule Title uses for word boundaries does not handle Unicode punctuation properly. </p> </li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://golang.org/pkg/strings/" class="_attribution-link" target="_blank">https://golang.org/pkg/strings/</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
