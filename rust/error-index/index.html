
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Compiler Errors - Rust - W3cubDocs</title>
  
  <meta name="description" content="This error suggests that the expression arm corresponding to the noted pattern will never be reached as for all possible values of the expression &hellip;">
  <meta name="keywords" content="rust, compiler, error, index, errors, -">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/rust/error-index/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rust">
				
				
<h1>Rust Compiler Error Index</h1> <h3 id="E0001" class="section-header">E0001</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>This error suggests that the expression arm corresponding to the noted pattern will never be reached as for all possible values of the expression being matched, one of the preceding patterns will match.</p> <p>This means that perhaps some of the preceding patterns are too general, this one is too specific or the ordering is incorrect.</p> <p>For example, the following <code>match</code> block has too many arms:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
match Some(0) {
    Some(bar) =&gt; {/* ... */}
    x =&gt; {/* ... */} // This handles the `None` case
    _ =&gt; {/* ... */} // All possible cases have already been handled
}</pre></div> <p><code>match</code> blocks have their patterns matched in order, so, for example, putting a wildcard arm above a more specific arm will make the latter arm irrelevant.</p> <p>Ensure the ordering of the match arm is correct and remove any superfluous arms.</p>  <h3 id="E0002" class="section-header">E0002</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-1" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>This error indicates that an empty match expression is invalid because the type it is matching on is non-empty (there exist values of this type). In safe code it is impossible to create an instance of an empty type, so empty match expressions are almost never desired. This error is typically fixed by adding one or more cases to the match expression.</p> <p>An example of an empty type is <code>enum Empty { }</code>. So, the following will work:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Empty {}

fn foo(x: Empty) {
    match x {
        // empty
    }
}</pre></div> <p>However, this won't:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo(x: Option&lt;String&gt;) {
    match x {
        // empty
    }
}</pre></div>  <h3 id="E0004" class="section-header">E0004</h3> <p>This error indicates that the compiler cannot guarantee a matching pattern for one or more possible inputs to a match expression. Guaranteed matches are required in order to assign values to match expressions, or alternatively, determine the flow of execution. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Terminator {
    HastaLaVistaBaby,
    TalkToMyHand,
}

let x = Terminator::HastaLaVistaBaby;

match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered
    Terminator::TalkToMyHand =&gt; {}
}</pre></div> <p>If you encounter this error you must alter your patterns so that every possible value of the input type is matched. For types with a small number of variants (like enums) you should probably cover all cases explicitly. Alternatively, the underscore <code>_</code> wildcard pattern can be added after all other patterns to match "anything else". Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Terminator {
    HastaLaVistaBaby,
    TalkToMyHand,
}

let x = Terminator::HastaLaVistaBaby;

match x {
    Terminator::TalkToMyHand =&gt; {}
    Terminator::HastaLaVistaBaby =&gt; {}
}

// or:

match x {
    Terminator::TalkToMyHand =&gt; {}
    _ =&gt; {}
}</pre></div>  <h3 id="E0005" class="section-header">E0005</h3> <p>Patterns used to bind names must be irrefutable, that is, they must guarantee that a name will be extracted in all cases. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = Some(1);
let Some(y) = x;
// error: refutable pattern in local binding: `None` not covered</pre></div> <p>If you encounter this error you probably need to use a <code>match</code> or <code>if let</code> to deal with the possibility of failure. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = Some(1);

match x {
    Some(y) =&gt; {
        // do something
    },
    None =&gt; {}
}

// or:

if let Some(y) = x {
    // do something
}</pre></div>  <h3 id="E0007" class="section-header">E0007</h3> <p>This error indicates that the bindings in a match arm would require a value to be moved into more than one location, thus violating unique ownership. Code like the following is invalid as it requires the entire <code>Option&lt;String&gt;</code> to be moved into a variable called <code>op_string</code> while simultaneously requiring the inner <code>String</code> to be moved into a variable called <code>s</code>.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = Some("s".to_string());

match x {
    op_string @ Some(s) =&gt; {}, // error: cannot bind by-move with sub-bindings
    None =&gt; {},
}</pre></div> <p>See also the error E0303.</p>  <h3 id="E0008" class="section-header">E0008</h3> <p>Names bound in match arms retain their type in pattern guards. As such, if a name is bound by move in a pattern, it should also be moved to wherever it is referenced in the pattern guard code. Doing so however would prevent the name from being available in the body of the match arm. Consider the following:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
match Some("hi".to_string()) {
    Some(s) if s.len() == 0 =&gt; {}, // use s.
    _ =&gt; {},
}</pre></div> <p>The variable <code>s</code> has type <code>String</code>, and its use in the guard is as a variable of type <code>String</code>. The guard code effectively executes in a separate scope to the body of the arm, so the value would be moved into this anonymous scope and therefore becomes unavailable in the body of the arm.</p> <p>The problem above can be solved by using the <code>ref</code> keyword.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
match Some("hi".to_string()) {
    Some(ref s) if s.len() == 0 =&gt; {},
    _ =&gt; {},
}</pre></div> <p>Though this example seems innocuous and easy to solve, the problem becomes clear when it encounters functions which consume the value:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct A{}

impl A {
    fn consume(self) -&gt; usize {
        0
    }
}

fn main() {
    let a = Some(A{});
    match a {
        Some(y) if y.consume() &gt; 0 =&gt; {}
        _ =&gt; {}
    }
}</pre></div> <p>In this situation, even the <code>ref</code> keyword cannot solve it, since borrowed content cannot be moved. This problem cannot be solved generally. If the value can be cloned, here is a not-so-specific solution:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[derive(Clone)]
struct A{}

impl A {
    fn consume(self) -&gt; usize {
        0
    }
}

fn main() {
    let a = Some(A{});
    match a{
        Some(ref y) if y.clone().consume() &gt; 0 =&gt; {}
        _ =&gt; {}
    }
}</pre></div> <p>If the value will be consumed in the pattern guard, using its clone will not move its ownership, so the code works.</p>  <h3 id="E0009" class="section-header">E0009</h3> <p>In a pattern, all values that don't implement the <code>Copy</code> trait have to be bound the same way. The goal here is to avoid binding simultaneously by-move and by-ref.</p> <p>This limitation may be removed in a future version of Rust.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct X { x: (), }

let x = Some((X { x: () }, X { x: () }));
match x {
    Some((y, ref z)) =&gt; {}, // error: cannot bind by-move and by-ref in the
                            //        same pattern
    None =&gt; panic!()
}</pre></div> <p>You have two solutions:</p> <p>Solution #1: Bind the pattern's values the same way.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct X { x: (), }

let x = Some((X { x: () }, X { x: () }));
match x {
    Some((ref y, ref z)) =&gt; {},
    // or Some((y, z)) =&gt; {}
    None =&gt; panic!()
}</pre></div> <p>Solution #2: Implement the <code>Copy</code> trait for the <code>X</code> structure.</p> <p>However, please keep in mind that the first solution should be preferred.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[derive(Clone, Copy)]
struct X { x: (), }

let x = Some((X { x: () }, X { x: () }));
match x {
    Some((y, ref z)) =&gt; {},
    None =&gt; panic!()
}</pre></div>  <h3 id="E0010" class="section-header">E0010</h3> <p>The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(box_syntax)]

const CON : Box&lt;i32&gt; = box 0;</pre></div>  <h3 id="E0013" class="section-header">E0013</h3> <p>Static and const variables can refer to other const variables. But a const variable cannot refer to a static variable. For example, <code>Y</code> cannot refer to <code>X</code> here:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
static X: i32 = 42;
const Y: i32 = X;</pre></div> <p>To fix this, the value can be extracted as a const and then used:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
const A: i32 = 42;
static X: i32 = A;
const Y: i32 = A;</pre></div>  <h3 id="E0015" class="section-header">E0015</h3> <p>The only functions that can be called in static or constant expressions are <code>const</code> functions, and struct/enum constructors. <code>const</code> functions are only available on a nightly compiler. Rust currently does not support more general compile-time function execution.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
const FOO: Option&lt;u8&gt; = Some(1); // enum constructor
struct Bar {x: u8}
const BAR: Bar = Bar {x: 1}; // struct constructor</pre></div> <p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md" target="_blank">RFC 911</a> for more details on the design of <code>const fn</code>s.</p>  <h3 id="E0017" class="section-header">E0017</h3> <p>References in statics and constants may only refer to immutable values. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
static X: i32 = 1;
const C: i32 = 2;

// these three are not allowed:
const CR: &amp;mut i32 = &amp;mut C;
static STATIC_REF: &amp;'static mut i32 = &amp;mut X;
static CONST_REF: &amp;'static mut i32 = &amp;mut C;</pre></div> <p>Statics are shared everywhere, and if they refer to mutable data one might violate memory safety since holding multiple mutable references to shared data is not allowed.</p> <p>If you really want global mutable state, try using <code>static mut</code> or a global <code>UnsafeCell</code>.</p>  <h3 id="E0019" class="section-header">E0019</h3> <p>A function call isn't allowed in the const's initialization expression because the expression's value must be known at compile-time. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Test {
    V1
}

impl Test {
    fn test(&amp;self) -&gt; i32 {
        12
    }
}

fn main() {
    const FOO: Test = Test::V1;

    const A: i32 = FOO.test(); // You can't call Test::func() here!
}</pre></div> <p>Remember: you can't use a function call inside a const's initialization expression! However, you can totally use it anywhere else:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Test {
    V1
}

impl Test {
    fn func(&amp;self) -&gt; i32 {
        12
    }
}

fn main() {
    const FOO: Test = Test::V1;

    FOO.func(); // here is good
    let x = FOO.func(); // or even here!
}</pre></div>  <h3 id="E0023" class="section-header">E0023</h3> <p>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant. This error indicates that a pattern attempted to extract an incorrect number of fields from a variant.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Fruit {
    Apple(String, String),
    Pear(u32),
}</pre></div> <p>Here the <code>Apple</code> variant has two fields, and should be matched against like so:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Fruit {
    Apple(String, String),
    Pear(u32),
}

let x = Fruit::Apple(String::new(), String::new());

// Correct.
match x {
    Fruit::Apple(a, b) =&gt; {},
    _ =&gt; {}
}</pre></div> <p>Matching with the wrong number of fields has no sensible interpretation:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Fruit {
    Apple(String, String),
    Pear(u32),
}

let x = Fruit::Apple(String::new(), String::new());

// Incorrect.
match x {
    Fruit::Apple(a) =&gt; {},
    Fruit::Apple(a, b, c) =&gt; {},
}</pre></div> <p>Check how many fields the enum was declared with and ensure that your pattern uses the same number.</p>  <h3 id="E0025" class="section-header">E0025</h3> <p>Each field of a struct can only be bound once in a pattern. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    a: u8,
    b: u8,
}

fn main(){
    let x = Foo { a:1, b:2 };

    let Foo { a: x, a: y } = x;
    // error: field `a` bound multiple times in the pattern
}</pre></div> <p>Each occurrence of a field name binds the value of that field, so to fix this error you will have to remove or alter the duplicate uses of the field name. Perhaps you misspelled another field name? Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    a: u8,
    b: u8,
}

fn main(){
    let x = Foo { a:1, b:2 };

    let Foo { a: x, b: y } = x; // ok!
}</pre></div>  <h3 id="E0026" class="section-header">E0026</h3> <p>This error indicates that a struct pattern attempted to extract a non-existent field from a struct. Struct fields are identified by the name used before the colon <code>:</code> so struct patterns should resemble the declaration of the struct type being matched.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// Correct matching.
struct Thing {
    x: u32,
    y: u32
}

let thing = Thing { x: 1, y: 2 };

match thing {
    Thing { x: xfield, y: yfield } =&gt; {}
}</pre></div> <p>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly.</p> <p>Change this:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Thing {
    x: u32,
    y: u32
}

let thing = Thing { x: 0, y: 0 };

match thing {
    Thing { x, z } =&gt; {}
}</pre></div> <p>To this:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Thing {
    x: u32,
    y: u32
}

let thing = Thing { x: 0, y: 0 };

match thing {
    Thing { x, y: z } =&gt; {}
}</pre></div>  <h3 id="E0027" class="section-header">E0027</h3> <p>This error indicates that a pattern for a struct fails to specify a sub-pattern for every one of the struct's fields. Ensure that each field from the struct's definition is mentioned in the pattern, or use <code>..</code> to ignore unwanted fields.</p> <p>For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Dog {
    name: String,
    age: u32,
}

let d = Dog { name: "Rusty".to_string(), age: 8 };

// This is incorrect.
match d {
    Dog { age: x } =&gt; {}
}</pre></div> <p>This is correct (explicit):</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Dog {
    name: String,
    age: u32,
}

let d = Dog { name: "Rusty".to_string(), age: 8 };

match d {
    Dog { name: ref n, age: x } =&gt; {}
}

// This is also correct (ignore unused fields).
match d {
    Dog { age: x, .. } =&gt; {}
}</pre></div>  <h3 id="E0029" class="section-header">E0029</h3> <p>In a match expression, only numbers and characters can be matched against a range. This is because the compiler checks that the range is non-empty at compile-time, and is unable to evaluate arbitrary comparison functions. If you want to capture values of an orderable type between two end-points, you can use a guard.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let string = "salutations !";

// The ordering relation for strings can't be evaluated at compile time,
// so this doesn't work:
match string {
    "hello" ..= "world" =&gt; {}
    _ =&gt; {}
}

// This is a more general version, using a guard:
match string {
    s if s &gt;= "hello" &amp;&amp; s &lt;= "world" =&gt; {}
    _ =&gt; {}
}</pre></div>  <h3 id="E0030" class="section-header">E0030</h3> <p>When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.</p> <p>For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
match 5u32 {
    // This range is ok, albeit pointless.
    1 ..= 1 =&gt; {}
    // This range is empty, and the compiler can tell.
    1000 ..= 5 =&gt; {}
}</pre></div>  <h3 id="E0033" class="section-header">E0033</h3> <p>This error indicates that a pointer to a trait type cannot be implicitly dereferenced by a pattern. Every trait defines a type, but because the size of trait implementors isn't fixed, this type has no compile-time size. Therefore, all accesses to trait types must be through pointers. If you encounter this error you should try to avoid dereferencing the pointer.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let trait_obj: &amp;SomeTrait = &amp;"some_value";

// This tries to implicitly dereference to create an unsized local variable.
let &amp;invalid = trait_obj;

// You can call methods without binding to the value being pointed at.
trait_obj.method_one();
trait_obj.method_two();</pre></div> <p>You can read more about trait objects in the <a href="../reference/types/#trait-objects">Trait Objects</a> section of the Reference.</p>  <h3 id="E0034" class="section-header">E0034</h3> <p>The compiler doesn't know what method to call because more than one method has the same prototype. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Test;

trait Trait1 {
    fn foo();
}

trait Trait2 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }
impl Trait2 for Test { fn foo() {} }

fn main() {
    Test::foo() // error, which foo() to call?
}</pre></div> <p>To avoid this error, you have to keep only one of them and remove the others. So let's take our example and fix it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Test;

trait Trait1 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }

fn main() {
    Test::foo() // and now that's good!
}</pre></div> <p>However, a better solution would be using fully explicit naming of type and trait:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Test;

trait Trait1 {
    fn foo();
}

trait Trait2 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }
impl Trait2 for Test { fn foo() {} }

fn main() {
    &lt;Test as Trait1&gt;::foo()
}</pre></div> <p>One last example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait F {
    fn m(&amp;self);
}

trait G {
    fn m(&amp;self);
}

struct X;

impl F for X { fn m(&amp;self) { println!("I am F"); } }
impl G for X { fn m(&amp;self) { println!("I am G"); } }

fn main() {
    let f = X;

    F::m(&amp;f); // it displays "I am F"
    G::m(&amp;f); // it displays "I am G"
}</pre></div>  <h3 id="E0038" class="section-header">E0038</h3> <p>Trait objects like <code>Box&lt;Trait&gt;</code> can only be constructed when certain requirements are satisfied by the trait in question.</p> <p>Trait objects are a form of dynamic dispatch and use a dynamically sized type for the inner type. So, for a given trait <code>Trait</code>, when <code>Trait</code> is treated as a type, as in <code>Box&lt;Trait&gt;</code>, the inner type is 'unsized'. In such cases the boxed pointer is a 'fat pointer' that contains an extra pointer to a table of methods (among other things) for dynamic dispatch. This design mandates some restrictions on the types of traits that are allowed to be used in trait objects, which are collectively termed as 'object safety' rules.</p> <p>Attempting to create a trait object for a non object-safe trait will trigger this error.</p> <p>There are various rules:</p> <h3 id="the-trait-cannot-require-self-sized" class="section-header">The trait cannot require <code>Self: Sized</code>
</h3> <p>When <code>Trait</code> is treated as a type, the type does not implement the special <code>Sized</code> trait, because the type does not have a known size at compile time and can only be accessed behind a pointer. Thus, if we have a trait like the following:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo where Self: Sized {

}</pre></div> <p>We cannot create an object of type <code>Box&lt;Foo&gt;</code> or <code>&amp;Foo</code> since in this case <code>Self</code> would not be <code>Sized</code>.</p> <p>Generally, <code>Self: Sized</code> is used to indicate that the trait should not be used as a trait object. If the trait comes from your own crate, consider removing this restriction.</p> <h3 id="method-references-the-self-type-in-its-arguments-or-return-type" class="section-header">Method references the <code>Self</code> type in its arguments or return type</h3> <p>This happens when a trait has a method like the following:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn foo(&amp;self) -&gt; Self;
}

impl Trait for String {
    fn foo(&amp;self) -&gt; Self {
        "hi".to_owned()
    }
}

impl Trait for u8 {
    fn foo(&amp;self) -&gt; Self {
        1
    }
}</pre></div> <p>(Note that <code>&amp;self</code> and <code>&amp;mut self</code> are okay, it's additional <code>Self</code> types which cause this problem.)</p> <p>In such a case, the compiler cannot predict the return type of <code>foo()</code> in a situation like the following:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Trait {
    fn foo(&amp;self) -&gt; Self;
}

fn call_foo(x: Box&lt;Trait&gt;) {
    let y = x.foo(); // What type is y?
    // ...
}</pre></div> <p>If only some methods aren't object-safe, you can add a <code>where Self: Sized</code> bound on them to mark them as explicitly unavailable to trait objects. The functionality will still be available to all other implementers, including <code>Box&lt;Trait&gt;</code> which is itself sized (assuming you <code>impl Trait for Box&lt;Trait&gt;</code>).</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn foo(&amp;self) -&gt; Self where Self: Sized;
    // more functions
}</pre></div> <p>Now, <code>foo()</code> can no longer be called on a trait object, but you will now be allowed to make a trait object, and that will be able to call any object-safe methods. With such a bound, one can still call <code>foo()</code> on types implementing that trait that aren't behind trait objects.</p> <h3 id="method-has-generic-type-parameters" class="section-header">Method has generic type parameters</h3> <p>As mentioned before, trait objects contain pointers to method tables. So, if we have:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn foo(&amp;self);
}

impl Trait for String {
    fn foo(&amp;self) {
        // implementation 1
    }
}

impl Trait for u8 {
    fn foo(&amp;self) {
        // implementation 2
    }
}
// ...</pre></div> <p>At compile time each implementation of <code>Trait</code> will produce a table containing the various methods (and other items) related to the implementation.</p> <p>This works fine, but when the method gains generic parameters, we can have a problem.</p> <p>Usually, generic parameters get <em>monomorphized</em>. For example, if I have</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    // ...
}</pre></div> <p>The machine code for <code>foo::&lt;u8&gt;()</code>, <code>foo::&lt;bool&gt;()</code>, <code>foo::&lt;String&gt;()</code>, or any other type substitution is different. Hence the compiler generates the implementation on-demand. If you call <code>foo()</code> with a <code>bool</code> parameter, the compiler will only generate code for <code>foo::&lt;bool&gt;()</code>. When we have additional type parameters, the number of monomorphized implementations the compiler generates does not grow drastically, since the compiler will only generate an implementation if the function is called with unparametrized substitutions (i.e., substitutions where none of the substituted types are themselves parametrized).</p> <p>However, with trait objects we have to make a table containing <em>every</em> object that implements the trait. Now, if it has type parameters, we need to add implementations for every type that implements the trait, and there could theoretically be an infinite number of types.</p> <p>For example, with:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn foo&lt;T&gt;(&amp;self, on: T);
    // more methods
}

impl Trait for String {
    fn foo&lt;T&gt;(&amp;self, on: T) {
        // implementation 1
    }
}

impl Trait for u8 {
    fn foo&lt;T&gt;(&amp;self, on: T) {
        // implementation 2
    }
}

// 8 more implementations</pre></div> <p>Now, if we have the following code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn call_foo(thing: Box&lt;Trait&gt;) {
    thing.foo(true); // this could be any one of the 8 types above
    thing.foo(1);
    thing.foo("hello");
}</pre></div> <p>We don't just need to create a table of all implementations of all methods of <code>Trait</code>, we need to create such a table, for each different type fed to <code>foo()</code>. In this case this turns out to be (10 types implementing <code>Trait</code>)*(3 types being fed to <code>foo()</code>) = 30 implementations!</p> <p>With real world traits these numbers can grow drastically.</p> <p>To fix this, it is suggested to use a <code>where Self: Sized</code> bound similar to the fix for the sub-error above if you do not intend to call the method with type parameters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn foo&lt;T&gt;(&amp;self, on: T) where Self: Sized;
    // more methods
}</pre></div> <p>If this is not an option, consider replacing the type parameter with another trait object (e.g., if <code>T: OtherTrait</code>, use <code>on: Box&lt;OtherTrait&gt;</code>). If the number of types you intend to feed to this method is limited, consider manually listing out the methods of different types.</p> <h3 id="method-has-no-receiver" class="section-header">Method has no receiver</h3> <p>Methods that do not take a <code>self</code> parameter can't be called since there won't be a way to get a pointer to the method table for them.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn foo() -&gt; u8;
}</pre></div> <p>This could be called as <code>&lt;Foo as Foo&gt;::foo()</code>, which would not be able to pick an implementation.</p> <p>Adding a <code>Self: Sized</code> bound to these methods will generally make this compile.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn foo() -&gt; u8 where Self: Sized;
}</pre></div> <h3 id="the-trait-cannot-contain-associated-constants" class="section-header">The trait cannot contain associated constants</h3> <p>Just like static functions, associated constants aren't stored on the method table. If the trait or any subtrait contain an associated constant, they cannot be made into an object.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    const X: i32;
}

impl Foo {}</pre></div> <p>A simple workaround is to use a helper method instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn x(&amp;self) -&gt; i32;
}</pre></div> <h3 id="the-trait-cannot-use-self-as-a-type-parameter-in-the-supertrait-listing" class="section-header">The trait cannot use <code>Self</code> as a type parameter in the supertrait listing</h3> <p>This is similar to the second sub-error, but subtler. It happens in situations like the following:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Super&lt;A&gt; {}

trait Trait: Super&lt;Self&gt; {
}

struct Foo;

impl Super&lt;Foo&gt; for Foo{}

impl Trait for Foo {}</pre></div> <p>Here, the supertrait might have methods as follows:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Super&lt;A&gt; {
    fn get_a(&amp;self) -&gt; A; // note that this is object safe!
}</pre></div> <p>If the trait <code>Foo</code> was deriving from something like <code>Super&lt;String&gt;</code> or <code>Super&lt;T&gt;</code> (where <code>Foo</code> itself is <code>Foo&lt;T&gt;</code>), this is okay, because given a type <code>get_a()</code> will definitely return an object of that type.</p> <p>However, if it derives from <code>Super&lt;Self&gt;</code>, even though <code>Super</code> is object safe, the method <code>get_a()</code> would return an object of unknown type when called on the function. <code>Self</code> type parameters let us make object safe traits no longer safe, so they are forbidden when specifying supertraits.</p> <p>There's no easy fix for this, generally code will need to be refactored so that you no longer need to derive from <code>Super&lt;Self&gt;</code>.</p>  <h3 id="E0040" class="section-header">E0040</h3> <p>It is not allowed to manually call destructors in Rust. It is also not necessary to do this since <code>drop</code> is called automatically whenever a value goes out of scope.</p> <p>Here's an example of this error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    x: i32,
}

impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!("kaboom");
    }
}

fn main() {
    let mut x = Foo { x: -7 };
    x.drop(); // error: explicit use of destructor method
}</pre></div>  <h3 id="E0044" class="section-header">E0044</h3> <p>You can't use type or const parameters on foreign items. Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
extern { fn some_func&lt;T&gt;(x: T); }</pre></div> <p>To fix this, replace the generic parameter with the specializations that you need:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
extern { fn some_func_i32(x: i32); }
extern { fn some_func_i64(x: i64); }</pre></div>  <h3 id="E0045" class="section-header">E0045</h3> <p>Rust only supports variadic parameters for interoperability with C code in its FFI. As such, variadic parameters can only be used with functions which are using the C ABI. Examples of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(unboxed_closures)]

extern "rust-call" { fn foo(x: u8, ...); }

// or

fn foo(x: u8, ...) {}</pre></div> <p>To fix such code, put them in an extern "C" block:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
extern "C" {
    fn foo (x: u8, ...);
}</pre></div>  <h3 id="E0046" class="section-header">E0046</h3> <p>Items are missing in a trait implementation. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {}
// error: not all trait items implemented, missing: `foo`</pre></div> <p>When trying to make some type implement a trait <code>Foo</code>, you must, at minimum, provide implementations for all of <code>Foo</code>'s required methods (meaning the methods that do not have default implementations), as well as any required trait items like associated types or constants. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {
    fn foo() {} // ok!
}</pre></div>  <h3 id="E0049" class="section-header">E0049</h3> <p>This error indicates that an attempted implementation of a trait method has the wrong number of type or const parameters.</p> <p>For example, the trait below has a method <code>foo</code> with a type parameter <code>T</code>, but the implementation of <code>foo</code> for the type <code>Bar</code> is missing this parameter:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo&lt;T: Default&gt;(x: T) -&gt; Self;
}

struct Bar;

// error: method `foo` has 0 type parameters but its trait declaration has 1
// type parameter
impl Foo for Bar {
    fn foo(x: bool) -&gt; Self { Bar }
}</pre></div>  <h3 id="E0050" class="section-header">E0050</h3> <p>This error indicates that an attempted implementation of a trait method has the wrong number of function parameters.</p> <p>For example, the trait below has a method <code>foo</code> with two function parameters (<code>&amp;self</code> and <code>u8</code>), but the implementation of <code>foo</code> for the type <code>Bar</code> omits the <code>u8</code> parameter:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo(&amp;self, x: u8) -&gt; bool;
}

struct Bar;

// error: method `foo` has 1 parameter but the declaration in trait `Foo::foo`
// has 2
impl Foo for Bar {
    fn foo(&amp;self) -&gt; bool { true }
}</pre></div>  <h3 id="E0053" class="section-header">E0053</h3> <p>The parameters of any trait method must match between a trait implementation and the trait definition.</p> <p>Here are a couple examples of this error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo(x: u16);
    fn bar(&amp;self);
}

struct Bar;

impl Foo for Bar {
    // error, expected u16, found i16
    fn foo(x: i16) { }

    // error, types differ in mutability
    fn bar(&amp;mut self) { }
}</pre></div>  <h3 id="E0054" class="section-header">E0054</h3> <p>It is not allowed to cast to a bool. If you are trying to cast a numeric type to a bool, you can compare it with zero instead:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = 5;

// Not allowed, won't compile
let x_is_nonzero = x as bool;</pre></div> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = 5;

// Ok
let x_is_nonzero = x != 0;</pre></div>  <h3 id="E0055" class="section-header">E0055</h3> <p>During a method call, a value is automatically dereferenced as many times as needed to make the value's type match the method's receiver. The catch is that the compiler will only attempt to dereference a number of times up to the recursion limit (which can be set via the <code>recursion_limit</code> attribute).</p> <p>For a somewhat artificial example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![recursion_limit="5"]

struct Foo;

impl Foo {
    fn foo(&amp;self) {}
}

fn main() {
    let foo = Foo;
    let ref_foo = &amp;&amp;&amp;&amp;&amp;Foo;

    // error, reached the recursion limit while auto-dereferencing `&amp;&amp;&amp;&amp;&amp;Foo`
    ref_foo.foo();
}</pre></div> <p>One fix may be to increase the recursion limit. Note that it is possible to create an infinite recursion of dereferencing, in which case the only fix is to somehow break the recursion.</p>  <h3 id="E0057" class="section-header">E0057</h3> <p>When invoking closures or other implementations of the function traits <code>Fn</code>, <code>FnMut</code> or <code>FnOnce</code> using call notation, the number of parameters passed to the function must match its definition.</p> <p>An example using a closure:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let f = |x| x * 3;
let a = f();        // invalid, too few parameters
let b = f(4);       // this works!
let c = f(2, 3);    // invalid, too many parameters</pre></div> <p>A generic function must be treated similarly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;F: Fn()&gt;(f: F) {
    f(); // this is valid, but f(3) would not work
}</pre></div>  <h3 id="E0059" class="section-header">E0059</h3> <p>The built-in function traits are generic over a tuple of the function arguments. If one uses angle-bracket notation (<code>Fn&lt;(T,), Output=U&gt;</code>) instead of parentheses (<code>Fn(T) -&gt; U</code>) to denote the function trait, the type parameter should be a tuple. Otherwise function call notation cannot be used and the trait will not be implemented by closures.</p> <p>The most likely source of this error is using angle-bracket notation without wrapping the function argument type into a tuple, for example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(unboxed_closures)]

fn foo&lt;F: Fn&lt;i32&gt;&gt;(f: F) -&gt; F::Output { f(3) }</pre></div> <p>It can be fixed by adjusting the trait bound like this:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(unboxed_closures)]

fn foo&lt;F: Fn&lt;(i32,)&gt;&gt;(f: F) -&gt; F::Output { f(3) }</pre></div> <p>Note that <code>(T,)</code> always denotes the type of a 1-tuple containing an element of type <code>T</code>. The comma is necessary for syntactic disambiguation.</p>  <h3 id="E0060" class="section-header">E0060</h3> <p>External C functions are allowed to be variadic. However, a variadic function takes a minimum number of arguments. For example, consider C's variadic <code>printf</code> function:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::os::raw::{c_char, c_int};

extern "C" {
    fn printf(_: *const c_char, ...) -&gt; c_int;
}</pre></div> <p>Using this declaration, it must be called with at least one argument, so simply calling <code>printf()</code> is invalid. But the following uses are allowed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
unsafe {
    use std::ffi::CString;

    let fmt = CString::new("test\n").unwrap();
    printf(fmt.as_ptr());

    let fmt = CString::new("number = %d\n").unwrap();
    printf(fmt.as_ptr(), 3);

    let fmt = CString::new("%d, %d\n").unwrap();
    printf(fmt.as_ptr(), 10, 5);
}</pre></div>  <h3 id="E0061" class="section-header">E0061</h3> <p>The number of arguments passed to a function must match the number of arguments specified in the function signature.</p> <p>For example, a function like:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn f(a: u16, b: &amp;str) {}</pre></div> <p>Must always be called with exactly two arguments, e.g., <code>f(2, "test")</code>.</p> <p>Note that Rust does not have a notion of optional function arguments or variadic functions (except for its C-FFI).</p>  <h3 id="E0062" class="section-header">E0062</h3> <p>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was specified more than once. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    x: i32,
}

fn main() {
    let x = Foo {
                x: 0,
                x: 0, // error: field `x` specified more than once
            };
}</pre></div> <p>Each field should be specified exactly one time. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    x: i32,
}

fn main() {
    let x = Foo { x: 0 }; // ok!
}</pre></div>  <h3 id="E0063" class="section-header">E0063</h3> <p>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was not provided. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    x: i32,
    y: i32,
}

fn main() {
    let x = Foo { x: 0 }; // error: missing field: `y`
}</pre></div> <p>Each field should be specified exactly once. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    x: i32,
    y: i32,
}

fn main() {
    let x = Foo { x: 0, y: 0 }; // ok!
}</pre></div>  <h3 id="E0067" class="section-header">E0067</h3> <p>The left-hand side of a compound assignment expression must be a place expression. A place expression represents a memory location and includes item paths (ie, namespaced variables), dereferences, indexing expressions, and field references.</p> <p>Let's start with some erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::collections::LinkedList;

// Bad: assignment to non-place expression
LinkedList::new() += 1;

// ...

fn some_func(i: &amp;mut i32) {
    i += 12; // Error : '+=' operation cannot be applied on a reference !
}</pre></div> <p>And now some working examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut i : i32 = 0;

i += 12; // Good !

// ...

fn some_func(i: &amp;mut i32) {
    *i += 12; // Good !
}</pre></div>  <h3 id="E0069" class="section-header">E0069</h3> <p>The compiler found a function whose body contains a <code>return;</code> statement but whose return type is not <code>()</code>. An example of this is:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// error
fn foo() -&gt; u8 {
    return;
}</pre></div> <p>Since <code>return;</code> is just like <code>return ();</code>, there is a mismatch between the function's return type and the value being returned.</p>  <h3 id="E0070" class="section-header">E0070</h3> <p>The left-hand side of an assignment operator must be a place expression. A place expression represents a memory location and can be a variable (with optional namespacing), a dereference, an indexing expression or a field reference.</p> <p>More details can be found in the <a href="../reference/expressions/#places-rvalues-and-temporaries">Expressions</a> section of the Reference.</p> <p>Now, we can go further. Here are some erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct SomeStruct {
    x: i32,
    y: i32
}

const SOME_CONST : i32 = 12;

fn some_other_func() {}

fn some_function() {
    SOME_CONST = 14; // error : a constant value cannot be changed!
    1 = 3; // error : 1 isn't a valid place!
    some_other_func() = 4; // error : we can't assign value to a function!
    SomeStruct.x = 12; // error : SomeStruct a structure name but it is used
                       // like a variable!
}</pre></div> <p>And now let's give working examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct SomeStruct {
    x: i32,
    y: i32
}
let mut s = SomeStruct {x: 0, y: 0};

s.x = 3; // that's good !

// ...

fn some_func(x: &amp;mut i32) {
    *x = 12; // that's good !
}</pre></div>  <h3 id="E0071" class="section-header">E0071</h3> <p>You tried to use structure-literal syntax to create an item that is not a structure or enum variant.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
type U32 = u32;
let t = U32 { value: 4 }; // error: expected struct, variant or union type,
                          // found builtin type `u32`</pre></div> <p>To fix this, ensure that the name was correctly spelled, and that the correct form of initializer was used.</p> <p>For example, the code above can be fixed to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Foo {
    FirstValue(i32)
}

fn main() {
    let u = Foo::FirstValue(0i32);

    let t = 4;
}</pre></div>  <h3 id="E0072" class="section-header">E0072</h3> <p>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like <code>Box</code> or <code>&amp;</code>). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</p> <p>Consider the following erroneous definition of a type for a list of bytes:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// error, invalid recursive struct type
struct ListNode {
    head: u8,
    tail: Option&lt;ListNode&gt;,
}</pre></div> <p>This type cannot have a well-defined size, because it needs to be arbitrarily large (since we would be able to nest <code>ListNode</code>s to any depth). Specifically,</p> <pre>size of `ListNode` = 1 byte for `head`
                   + 1 byte for the discriminant of the `Option`
                   + size of `ListNode`
</pre> <p>One way to fix this is by wrapping <code>ListNode</code> in a <code>Box</code>, like so:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct ListNode {
    head: u8,
    tail: Option&lt;Box&lt;ListNode&gt;&gt;,
}</pre></div> <p>This works because <code>Box</code> is a pointer, so its size is well-known.</p>  <h3 id="E0073" class="section-header">E0073</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-2" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>You cannot define a struct (or enum) <code>Foo</code> that requires an instance of <code>Foo</code> in order to make a new <code>Foo</code> value. This is because there would be no way a first instance of <code>Foo</code> could be made to initialize another instance!</p> <p>Here's an example of a struct that has this problem:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo { x: Box&lt;Foo&gt; } // error</pre></div> <p>One fix is to use <code>Option</code>, like so:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo { x: Option&lt;Box&lt;Foo&gt;&gt; }</pre></div> <p>Now it's possible to create at least one instance of <code>Foo</code>: <code>Foo { x: None }</code>.</p>  <h3 id="E0074" class="section-header">E0074</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-3" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>When using the <code>#[simd]</code> attribute on a tuple struct, the components of the tuple struct must all be of a concrete, nongeneric type so the compiler can reason about how to use SIMD with them. This error will occur if the types are generic.</p> <p>This will cause an error:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Bad&lt;T&gt;(T, T, T);</pre></div> <p>This will not:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Good(u32, u32, u32);</pre></div>  <h3 id="E0075" class="section-header">E0075</h3> <p>The <code>#[simd]</code> attribute can only be applied to non empty tuple structs, because it doesn't make sense to try to use SIMD operations when there are no values to operate on.</p> <p>This will cause an error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Bad;</pre></div> <p>This will not:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Good(u32);</pre></div>  <h3 id="E0076" class="section-header">E0076</h3> <p>When using the <code>#[simd]</code> attribute to automatically use SIMD operations in tuple struct, the types in the struct must all be of the same type, or the compiler will trigger this error.</p> <p>This will cause an error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Bad(u16, u32, u32);</pre></div> <p>This will not:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Good(u32, u32, u32);</pre></div>  <h3 id="E0077" class="section-header">E0077</h3> <p>When using the <code>#[simd]</code> attribute on a tuple struct, the elements in the tuple must be machine types so SIMD operations can be applied to them.</p> <p>This will cause an error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Bad(String);</pre></div> <p>This will not:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Good(u32, u32, u32);</pre></div>  <h3 id="E0080" class="section-header">E0080</h3> <p>This error indicates that the compiler was unable to sensibly evaluate an constant expression that had to be evaluated. Attempting to divide by 0 or causing integer overflow are two ways to induce this error. For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Enum {
    X = (1 &lt;&lt; 500),
    Y = (1 / 0)
}</pre></div> <p>Ensure that the expressions given can be evaluated as the desired integer type. See the FFI section of the Reference for more information about using a custom integer type:</p> <p>https://doc.rust-lang.org/reference.html#ffi-attributes</p>  <h3 id="E0081" class="section-header">E0081</h3> <p>Enum discriminants are used to differentiate enum variants stored in memory. This error indicates that the same value was used for two or more variants, making them impossible to tell apart.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// Bad.
enum Enum {
    P = 3,
    X = 3,
    Y = 5,
}</pre></div> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// Good.
enum Enum {
    P,
    X = 3,
    Y = 5,
}</pre></div> <p>Note that variants without a manually specified discriminant are numbered from top to bottom starting from 0, so clashes can occur with seemingly unrelated variants.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Bad {
    X,
    Y = 0
}</pre></div> <p>Here <code>X</code> will have already been specified the discriminant 0 by the time <code>Y</code> is encountered, so a conflict occurs.</p>  <h3 id="E0084" class="section-header">E0084</h3> <p>An unsupported representation was attempted on a zero-variant enum.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(i32)]
enum NightsWatch {} // error: unsupported representation for zero-variant enum</pre></div> <p>It is impossible to define an integer type to be used to represent zero-variant enum values because there are no zero-variant enum values. There is no way to construct an instance of the following type using only safe code. So you have two solutions. Either you add variants in your enum:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(i32)]
enum NightsWatch {
    JonSnow,
    Commander,
}</pre></div> <p>or you remove the integer represention of your enum:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum NightsWatch {}</pre></div>  <h3 id="E0087" class="section-header">E0087</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-4" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>Too many type arguments were supplied for a function. For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;T&gt;() {}

fn main() {
    foo::&lt;f64, bool&gt;(); // error: wrong number of type arguments:
                        //        expected 1, found 2
}</pre></div> <p>The number of supplied arguments must exactly match the number of defined type parameters.</p>  <h3 id="E0088" class="section-header">E0088</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-5" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>You gave too many lifetime arguments. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn f() {}

fn main() {
    f::&lt;'static&gt;() // error: wrong number of lifetime arguments:
                   //        expected 0, found 1
}</pre></div> <p>Please check you give the right number of lifetime arguments. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn f() {}

fn main() {
    f() // ok!
}</pre></div> <p>It's also important to note that the Rust compiler can generally determine the lifetime by itself. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    value: String
}

impl Foo {
    // it can be written like this
    fn get_value&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a str { &amp;self.value }
    // but the compiler works fine with this too:
    fn without_lifetime(&amp;self) -&gt; &amp;str { &amp;self.value }
}

fn main() {
    let f = Foo { value: "hello".to_owned() };

    println!("{}", f.get_value());
    println!("{}", f.without_lifetime());
}</pre></div>  <h3 id="E0089" class="section-header">E0089</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-6" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>Too few type arguments were supplied for a function. For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;T, U&gt;() {}

fn main() {
    foo::&lt;f64&gt;(); // error: wrong number of type arguments: expected 2, found 1
}</pre></div> <p>Note that if a function takes multiple type arguments but you want the compiler to infer some of them, you can use type placeholders:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;T, U&gt;(x: T) {}

fn main() {
    let x: bool = true;
    foo::&lt;f64&gt;(x);    // error: wrong number of type arguments:
                      //        expected 2, found 1
    foo::&lt;_, f64&gt;(x); // same as `foo::&lt;bool, f64&gt;(x)`
}</pre></div>  <h3 id="E0090" class="section-header">E0090</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-7" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>You gave too few lifetime arguments. Example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;'a: 'b, 'b: 'a&gt;() {}

fn main() {
    foo::&lt;'static&gt;(); // error: wrong number of lifetime arguments:
                      //        expected 2, found 1
}</pre></div> <p>Please check you give the right number of lifetime arguments. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;'a: 'b, 'b: 'a&gt;() {}

fn main() {
    foo::&lt;'static, 'static&gt;();
}</pre></div>  <h3 id="E0091" class="section-header">E0091</h3> <p>You gave an unnecessary type or const parameter in a type alias. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
type Foo&lt;T&gt; = u32; // error: type parameter `T` is unused
// or:
type Foo&lt;A,B&gt; = Box&lt;A&gt;; // error: type parameter `B` is unused</pre></div> <p>Please check you didn't write too many parameters. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
type Foo = u32; // ok!
type Foo2&lt;A&gt; = Box&lt;A&gt;; // ok!</pre></div>  <h3 id="E0092" class="section-header">E0092</h3> <p>You tried to declare an undefined atomic operation function. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn atomic_foo(); // error: unrecognized atomic operation
                     //        function
}</pre></div> <p>Please check you didn't make a mistake in the function's name. All intrinsic functions are defined in librustc_codegen_llvm/intrinsic.rs and in libcore/intrinsics.rs in the Rust source code. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn atomic_fence(); // ok!
}</pre></div>  <h3 id="E0093" class="section-header">E0093</h3> <p>You declared an unknown intrinsic function. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn foo(); // error: unrecognized intrinsic function: `foo`
}

fn main() {
    unsafe {
        foo();
    }
}</pre></div> <p>Please check you didn't make a mistake in the function's name. All intrinsic functions are defined in librustc_codegen_llvm/intrinsic.rs and in libcore/intrinsics.rs in the Rust source code. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn atomic_fence(); // ok!
}

fn main() {
    unsafe {
        atomic_fence();
    }
}</pre></div>  <h3 id="E0094" class="section-header">E0094</h3> <p>You gave an invalid number of type parameters to an intrinsic function. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn size_of&lt;T, U&gt;() -&gt; usize; // error: intrinsic has wrong number
                                 //        of type parameters
}</pre></div> <p>Please check that you provided the right number of type parameters and verify with the function declaration in the Rust source code. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn size_of&lt;T&gt;() -&gt; usize; // ok!
}</pre></div>  <h3 id="E0106" class="section-header">E0106</h3> <p>This error indicates that a lifetime is missing from a type. If it is an error inside a function signature, the problem may be with failing to adhere to the lifetime elision rules (see below).</p> <p>Here are some simple examples of where you'll run into this error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo1 { x: &amp;bool }
              // ^ expected lifetime parameter
struct Foo2&lt;'a&gt; { x: &amp;'a bool } // correct

struct Bar1 { x: Foo2 }
              // ^^^^ expected lifetime parameter
struct Bar2&lt;'a&gt; { x: Foo2&lt;'a&gt; } // correct

enum Baz1 { A(u8), B(&amp;bool), }
                  // ^ expected lifetime parameter
enum Baz2&lt;'a&gt; { A(u8), B(&amp;'a bool), } // correct

type MyStr1 = &amp;str;
           // ^ expected lifetime parameter
type MyStr2&lt;'a&gt; = &amp;'a str; // correct</pre></div> <p>Lifetime elision is a special, limited kind of inference for lifetimes in function signatures which allows you to leave out lifetimes in certain cases. For more background on lifetime elision see <a href="../book/ch10-03-lifetime-syntax/#lifetime-elision">the book</a>.</p> <p>The lifetime elision rules require that any function signature with an elided output lifetime must either have</p> <ul> <li>exactly one input lifetime</li> <li>or, multiple input lifetimes, but the function must also be a method with a <code>&amp;self</code> or <code>&amp;mut self</code> receiver</li> </ul> <p>In the first case, the output lifetime is inferred to be the same as the unique input lifetime. In the second case, the lifetime is instead inferred to be the same as the lifetime on <code>&amp;self</code> or <code>&amp;mut self</code>.</p> <p>Here are some examples of elision errors:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// error, no input lifetimes
fn foo() -&gt; &amp;str { }

// error, `x` and `y` have distinct lifetimes inferred
fn bar(x: &amp;str, y: &amp;str) -&gt; &amp;str { }

// error, `y`'s lifetime is inferred to be distinct from `x`'s
fn baz&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;str { }</pre></div>  <h3 id="E0107" class="section-header">E0107</h3> <p>This error means that an incorrect number of generic arguments were provided:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;T&gt; { x: T }

struct Bar { x: Foo }             // error: wrong number of type arguments:
                                  //        expected 1, found 0
struct Baz&lt;S, T&gt; { x: Foo&lt;S, T&gt; } // error: wrong number of type arguments:
                                  //        expected 1, found 2

fn foo&lt;T, U&gt;(x: T, y: U) {}

fn main() {
    let x: bool = true;
    foo::&lt;bool&gt;(x);                 // error: wrong number of type arguments:
                                    //        expected 2, found 1
    foo::&lt;bool, i32, i32&gt;(x, 2, 4); // error: wrong number of type arguments:
                                    //        expected 2, found 3
}

fn f() {}

fn main() {
    f::&lt;'static&gt;(); // error: wrong number of lifetime arguments:
                    //        expected 0, found 1
}</pre></div>  <h3 id="E0109" class="section-header">E0109</h3> <p>You tried to provide a generic argument to a type which doesn't need it. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
type X = u32&lt;i32&gt;; // error: type arguments are not allowed for this type
type Y = bool&lt;'static&gt;; // error: lifetime parameters are not allowed on
                        //        this type</pre></div> <p>Check that you used the correct argument and that the definition is correct.</p> <p>Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
type X = u32; // ok!
type Y = bool; // ok!</pre></div> <p>Note that generic arguments for enum variant constructors go after the variant, not after the enum. For example, you would write <code>Option::None::&lt;u32&gt;</code>, rather than <code>Option::&lt;u32&gt;::None</code>.</p>  <h3 id="E0110" class="section-header">E0110</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-8" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>You tried to provide a lifetime to a type which doesn't need it. See <code>E0109</code> for more details.</p>  <h3 id="E0116" class="section-header">E0116</h3> <p>You can only define an inherent implementation for a type in the same crate where the type was defined. For example, an <code>impl</code> block as below is not allowed since <code>Vec</code> is defined in the standard library:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
impl Vec&lt;u8&gt; { } // error</pre></div> <p>To fix this problem, you can do either of these things:</p> <ul> <li>define a trait that has the desired associated functions/types/constants and implement the trait for the type in question</li> <li>define a new type wrapping the type and define an implementation on the new type</li> </ul> <p>Note that using the <code>type</code> keyword does not work here because <code>type</code> only introduces a type alias:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
type Bytes = Vec&lt;u8&gt;;

impl Bytes { } // error, same as above</pre></div>  <h3 id="E0117" class="section-header">E0117</h3> <p>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule prohibits any implementation of a foreign trait (a trait defined in another crate) where</p> <ul> <li>the type that is implementing the trait is foreign</li> <li>all of the parameters being passed to the trait (if there are any) are also foreign.</li> </ul> <p>Here's one example of this error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
impl Drop for u32 {}</pre></div> <p>To avoid this kind of error, ensure that at least one local type is referenced by the <code>impl</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
pub struct Foo; // you define your type in your crate

impl Drop for Foo { // and you can implement the trait on it!
    // code of trait implementation here
}

impl From&lt;Foo&gt; for i32 { // or you use a type from your crate as
                         // a type parameter
    fn from(i: Foo) -&gt; i32 {
        0
    }
}</pre></div> <p>Alternatively, define a trait locally and implement that instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Bar {
    fn get(&amp;self) -&gt; usize;
}

impl Bar for u32 {
    fn get(&amp;self) -&gt; usize { 0 }
}</pre></div> <p>For information on the design of the orphan rules, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md" target="_blank">RFC 1023</a>.</p>  <h3 id="E0118" class="section-header">E0118</h3> <p>You're trying to write an inherent implementation for something which isn't a struct nor an enum. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
impl (u8, u8) { // error: no base type found for inherent implementation
    fn get_state(&amp;self) -&gt; String {
        // ...
    }
}</pre></div> <p>To fix this error, please implement a trait on the type or wrap it in a struct. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// we create a trait here
trait LiveLongAndProsper {
    fn get_state(&amp;self) -&gt; String;
}

// and now you can implement it on (u8, u8)
impl LiveLongAndProsper for (u8, u8) {
    fn get_state(&amp;self) -&gt; String {
        "He's dead, Jim!".to_owned()
    }
}</pre></div> <p>Alternatively, you can create a newtype. A newtype is a wrapping tuple-struct. For example, <code>NewType</code> is a newtype over <code>Foo</code> in <code>struct NewType(Foo)</code>. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct TypeWrapper((u8, u8));

impl TypeWrapper {
    fn get_state(&amp;self) -&gt; String {
        "Fascinating!".to_owned()
    }
}</pre></div>  <h3 id="E0119" class="section-header">E0119</h3> <p>There are conflicting trait implementations for the same type. Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait MyTrait {
    fn get(&amp;self) -&gt; usize;
}

impl&lt;T&gt; MyTrait for T {
    fn get(&amp;self) -&gt; usize { 0 }
}

struct Foo {
    value: usize
}

impl MyTrait for Foo { // error: conflicting implementations of trait
                       //        `MyTrait` for type `Foo`
    fn get(&amp;self) -&gt; usize { self.value }
}</pre></div> <p>When looking for the implementation for the trait, the compiler finds both the <code>impl&lt;T&gt; MyTrait for T</code> where T is all types and the <code>impl MyTrait for Foo</code>. Since a trait cannot be implemented multiple times, this is an error. So, when you write:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait MyTrait {
    fn get(&amp;self) -&gt; usize;
}

impl&lt;T&gt; MyTrait for T {
    fn get(&amp;self) -&gt; usize { 0 }
}</pre></div> <p>This makes the trait implemented on all types in the scope. So if you try to implement it on another one after that, the implementations will conflict. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait MyTrait {
    fn get(&amp;self) -&gt; usize;
}

impl&lt;T&gt; MyTrait for T {
    fn get(&amp;self) -&gt; usize { 0 }
}

struct Foo;

fn main() {
    let f = Foo;

    f.get(); // the trait is implemented so we can use it
}</pre></div>  <h3 id="E0120" class="section-header">E0120</h3> <p>An attempt was made to implement Drop on a trait, which is not allowed: only structs and enums can implement Drop. An example causing this error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait MyTrait {}

impl Drop for MyTrait {
    fn drop(&amp;mut self) {}
}</pre></div> <p>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that. An example is shown below:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait MyTrait {}
struct MyWrapper&lt;T: MyTrait&gt; { foo: T }

impl &lt;T: MyTrait&gt; Drop for MyWrapper&lt;T&gt; {
    fn drop(&amp;mut self) {}
}
</pre></div> <p>Alternatively, wrapping trait objects requires something like the following:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait MyTrait {}

//or Box&lt;MyTrait&gt;, if you wanted an owned trait object
struct MyWrapper&lt;'a&gt; { foo: &amp;'a MyTrait }

impl &lt;'a&gt; Drop for MyWrapper&lt;'a&gt; {
    fn drop(&amp;mut self) {}
}</pre></div>  <h3 id="E0121" class="section-header">E0121</h3> <p>In order to be consistent with Rust's lack of global type inference, type and const placeholders are disallowed by design in item signatures.</p> <p>Examples of this error include:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo() -&gt; _ { 5 } // error, explicitly write out the return type instead

static BAR: _ = "test"; // error, explicitly write out the type instead</pre></div>  <h3 id="E0124" class="section-header">E0124</h3> <p>You declared two fields of a struct with the same name. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    field1: i32,
    field1: i32, // error: field is already declared
}</pre></div> <p>Please verify that the field names have been correctly spelled. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    field1: i32,
    field2: i32, // ok!
}</pre></div>  <h3 id="E0128" class="section-header">E0128</h3> <p>Type parameter defaults can only use parameters that occur before them. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;T=U, U=()&gt; {
    field1: T,
    filed2: U,
}
// error: type parameters with a default cannot use forward declared
// identifiers</pre></div> <p>Since type parameters are evaluated in-order, you may be able to fix this issue by doing:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;U=(), T=U&gt; {
    field1: T,
    filed2: U,
}</pre></div> <p>Please also verify that this wasn't because of a name-clash and rename the type parameter if so.</p>  <h3 id="E0130" class="section-header">E0130</h3> <p>You declared a pattern as an argument in a foreign function declaration. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
extern {
    fn foo((a, b): (u32, u32)); // error: patterns aren't allowed in foreign
                                //        function declarations
}</pre></div> <p>Please replace the pattern argument with a regular one. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct SomeStruct {
    a: u32,
    b: u32,
}

extern {
    fn foo(s: SomeStruct); // ok!
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
extern {
    fn foo(a: (u32, u32)); // ok!
}</pre></div>  <h3 id="E0131" class="section-header">E0131</h3> <p>It is not possible to define <code>main</code> with generic parameters. When <code>main</code> is present, it must take no arguments and return <code>()</code>. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main&lt;T&gt;() { // error: main function is not allowed to have generic parameters
}</pre></div>  <h3 id="E0132" class="section-header">E0132</h3> <p>A function with the <code>start</code> attribute was declared with type parameters.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(start)]

#[start]
fn f&lt;T&gt;() {}</pre></div> <p>It is not possible to declare type parameters on a function that has the <code>start</code> attribute. Such a function must have the following type signature (for more information, view <a href="https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib" target="_blank">the unstable book</a>):</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn(isize, *const *const u8) -&gt; isize;</pre></div> <p>Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(start)]

#[start]
fn my_start(argc: isize, argv: *const *const u8) -&gt; isize {
    0
}</pre></div>  <h3 id="E0133" class="section-header">E0133</h3> <p>Unsafe code was used outside of an unsafe function or block.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
unsafe fn f() { return; } // This is the unsafe code

fn main() {
    f(); // error: call to unsafe function requires unsafe function or block
}</pre></div> <p>Using unsafe functionality is potentially dangerous and disallowed by safety checks. Examples:</p> <ul> <li>Dereferencing raw pointers</li> <li>Calling functions via FFI</li> <li>Calling functions marked unsafe</li> </ul> <p>These safety checks can be relaxed for a section of the code by wrapping the unsafe instructions with an <code>unsafe</code> block. For instance:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
unsafe fn f() { return; }

fn main() {
    unsafe { f(); } // ok!
}</pre></div> <p>See also https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html</p>  <h3 id="E0136" class="section-header">E0136</h3> <p>A binary can only have one entry point, and by default that entry point is the function <code>main()</code>. If there are multiple such functions, please rename one.</p>  <h3 id="E0137" class="section-header">E0137</h3> <p>More than one function was declared with the <code>#[main]</code> attribute.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(main)]

#[main]
fn foo() {}

#[main]
fn f() {} // error: multiple functions with a #[main] attribute</pre></div> <p>This error indicates that the compiler found multiple functions with the <code>#[main]</code> attribute. This is an error because there must be a unique entry point into a Rust program. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(main)]

#[main]
fn f() {} // ok!</pre></div>  <h3 id="E0138" class="section-header">E0138</h3> <p>More than one function was declared with the <code>#[start]</code> attribute.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(start)]

#[start]
fn foo(argc: isize, argv: *const *const u8) -&gt; isize {}

#[start]
fn f(argc: isize, argv: *const *const u8) -&gt; isize {}
// error: multiple 'start' functions</pre></div> <p>This error indicates that the compiler found multiple functions with the <code>#[start]</code> attribute. This is an error because there must be a unique entry point into a Rust program. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(start)]

#[start]
fn foo(argc: isize, argv: *const *const u8) -&gt; isize { 0 } // ok!</pre></div>  <h3 id="E0139" class="section-header">E0139</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-9" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>There are various restrictions on transmuting between types in Rust; for example types being transmuted must have the same size. To apply all these restrictions, the compiler must know the exact types that may be transmuted. When type parameters are involved, this cannot always be done.</p> <p>So, for example, the following is not allowed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::mem::transmute;

struct Foo&lt;T&gt;(Vec&lt;T&gt;);

fn foo&lt;T&gt;(x: Vec&lt;T&gt;) {
    // we are transmuting between Vec&lt;T&gt; and Foo&lt;F&gt; here
    let y: Foo&lt;T&gt; = unsafe { transmute(x) };
    // do something with y
}</pre></div> <p>In this specific case there's a good chance that the transmute is harmless (but this is not guaranteed by Rust). However, when alignment and enum optimizations come into the picture, it's quite likely that the sizes may or may not match with different type parameter substitutions. It's not possible to check this for <em>all</em> possible types, so <code>transmute()</code> simply only accepts types without any unsubstituted type parameters.</p> <p>If you need this, there's a good chance you're doing something wrong. Keep in mind that Rust doesn't guarantee much about the layout of different structs (even two structs with identical declarations may have different layouts). If there is a solution that avoids the transmute entirely, try it instead.</p> <p>If it's possible, hand-monomorphize the code by writing the function for each possible type substitution. It's possible to use traits to do this cleanly, for example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::mem::transmute;

struct Foo&lt;T&gt;(Vec&lt;T&gt;);

trait MyTransmutableType: Sized {
    fn transmute(_: Vec&lt;Self&gt;) -&gt; Foo&lt;Self&gt;;
}

impl MyTransmutableType for u8 {
    fn transmute(x: Vec&lt;u8&gt;) -&gt; Foo&lt;u8&gt; {
        unsafe { transmute(x) }
    }
}

impl MyTransmutableType for String {
    fn transmute(x: Vec&lt;String&gt;) -&gt; Foo&lt;String&gt; {
        unsafe { transmute(x) }
    }
}

// ... more impls for the types you intend to transmute

fn foo&lt;T: MyTransmutableType&gt;(x: Vec&lt;T&gt;) {
    let y: Foo&lt;T&gt; = &lt;T as MyTransmutableType&gt;::transmute(x);
    // do something with y
}</pre></div> <p>Each impl will be checked for a size match in the transmute as usual, and since there are no unbound type parameters involved, this should compile unless there is a size mismatch in one of the impls.</p> <p>It is also possible to manually transmute:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
unsafe {
    ptr::read(&amp;v as *const _ as *const SomeType) // `v` transmuted to `SomeType`
}</pre></div> <p>Note that this does not move <code>v</code> (unlike <code>transmute</code>), and may need a call to <code>mem::forget(v)</code> in case you want to avoid destructors being called.</p>  <h3 id="E0152" class="section-header">E0152</h3> <p>A lang item was redefined.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(lang_items)]

#[lang = "arc"]
struct Foo; // error: duplicate lang item found: `arc`</pre></div> <p>Lang items are already implemented in the standard library. Unless you are writing a free-standing application (e.g., a kernel), you do not need to provide them yourself.</p> <p>You can build a free-standing crate by adding <code>#![no_std]</code> to the crate attributes:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#![no_std]</pre></div> <p>See also the <a href="https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib" target="_blank">unstable book</a>.</p>  <h3 id="E0154" class="section-header">E0154</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-10" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>Imports (<code>use</code> statements) are not allowed after non-item statements, such as variable declarations and expression statements.</p> <p>Here is an example that demonstrates the error:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn f() {
    // Variable declaration before import
    let x = 0;
    use std::io::Read;
    // ...
}</pre></div> <p>The solution is to declare the imports at the top of the block, function, or file.</p> <p>Here is the previous example again, with the correct order:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn f() {
    use std::io::Read;
    let x = 0;
    // ...
}</pre></div> <p>See the Declaration Statements section of the reference for more information about what constitutes an Item declaration and what does not:</p> <p>https://doc.rust-lang.org/reference.html#statements</p>  <h3 id="E0158" class="section-header">E0158</h3> <p><code>const</code> and <code>static</code> mean different things. A <code>const</code> is a compile-time constant, an alias for a literal value. This property means you can match it directly within a pattern.</p> <p>The <code>static</code> keyword, on the other hand, guarantees a fixed location in memory. This does not always mean that the value is constant. For example, a global mutex can be declared <code>static</code> as well.</p> <p>If you want to match against a <code>static</code>, consider using a guard instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
static FORTY_TWO: i32 = 42;

match Some(42) {
    Some(x) if x == FORTY_TWO =&gt; {}
    _ =&gt; {}
}</pre></div>  <h3 id="E0161" class="section-header">E0161</h3> <p>A value was moved. However, its size was not known at compile time, and only values of a known size can be moved.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(box_syntax)]

fn main() {
    let array: &amp;[isize] = &amp;[1, 2, 3];
    let _x: Box&lt;[isize]&gt; = box *array;
    // error: cannot move a value of type [isize]: the size of [isize] cannot
    //        be statically determined
}</pre></div> <p>In Rust, you can only move a value when its size is known at compile time.</p> <p>To work around this restriction, consider "hiding" the value behind a reference: either <code>&amp;x</code> or <code>&amp;mut x</code>. Since a reference has a fixed size, this lets you move it around as usual. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(box_syntax)]

fn main() {
    let array: &amp;[isize] = &amp;[1, 2, 3];
    let _x: Box&lt;&amp;[isize]&gt; = box array; // ok!
}</pre></div>  <h3 id="E0162" class="section-header">E0162</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-11" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>An if-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular <code>let</code>-binding instead. For instance:</p> <pre>struct Irrefutable(i32);
let irr = Irrefutable(0);

// This fails to compile because the match is irrefutable.
if let Irrefutable(x) = irr {
    // This body will always be executed.
    // ...
}
</pre> <p>Try this instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Irrefutable(i32);
let irr = Irrefutable(0);

let Irrefutable(x) = irr;
println!("{}", x);</pre></div>  <h3 id="E0164" class="section-header">E0164</h3> <p>This error means that an attempt was made to match a struct type enum variant as a non-struct type:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Foo { B { i: u32 } }

fn bar(foo: Foo) -&gt; u32 {
    match foo {
        Foo::B(i) =&gt; i, // error E0164
    }
}</pre></div> <p>Try using <code>{}</code> instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Foo { B { i: u32 } }

fn bar(foo: Foo) -&gt; u32 {
    match foo {
        Foo::B{i} =&gt; i,
    }
}</pre></div>  <h3 id="E0165" class="section-header">E0165</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-12" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>A while-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular <code>let</code>-binding inside a <code>loop</code> instead. For instance:</p> <pre>struct Irrefutable(i32);
let irr = Irrefutable(0);

// This fails to compile because the match is irrefutable.
while let Irrefutable(x) = irr {
    // ...
}
</pre> <p>Try this instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Irrefutable(i32);
let irr = Irrefutable(0);

loop {
    let Irrefutable(x) = irr;
    // ...
}</pre></div>  <h3 id="E0170" class="section-header">E0170</h3> <p>Enum variants are qualified by default. For example, given this type:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Method {
    GET,
    POST,
}</pre></div> <p>You would match it using:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Method {
    GET,
    POST,
}

let m = Method::GET;

match m {
    Method::GET =&gt; {},
    Method::POST =&gt; {},
}</pre></div> <p>If you don't qualify the names, the code will bind new variables named "GET" and "POST" instead. This behavior is likely not what you want, so <code>rustc</code> warns when that happens.</p> <p>Qualified names are good practice, and most code works well with them. But if you prefer them unqualified, you can import the variants into scope:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use Method::*;
enum Method { GET, POST }</pre></div> <p>If you want others to be able to import variants from your module directly, use <code>pub use</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
pub use Method::*;
pub enum Method { GET, POST }</pre></div>  <h3 id="E0178" class="section-header">E0178</h3> <p>In types, the <code>+</code> type operator has low precedence, so it is often necessary to use parentheses.</p> <p>For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {}

struct Bar&lt;'a&gt; {
    w: &amp;'a Foo + Copy,   // error, use &amp;'a (Foo + Copy)
    x: &amp;'a Foo + 'a,     // error, use &amp;'a (Foo + 'a)
    y: &amp;'a mut Foo + 'a, // error, use &amp;'a mut (Foo + 'a)
    z: fn() -&gt; Foo + 'a, // error, use fn() -&gt; (Foo + 'a)
}</pre></div> <p>More details can be found in <a href="https://github.com/rust-lang/rfcs/pull/438" target="_blank">RFC 438</a>.</p>   <h3 id="E0184" class="section-header">E0184</h3> <p>Explicitly implementing both Drop and Copy for a type is currently disallowed. This feature can make some sense in theory, but the current implementation is incorrect and can lead to memory unsafety (see <a href="https://github.com/rust-lang/rust/issues/20126" target="_blank">issue #20126</a>), so it has been disabled for now.</p>  <h3 id="E0185" class="section-header">E0185</h3> <p>An associated function for a trait was defined to be static, but an implementation of the trait declared the same function to be a method (i.e., to take a <code>self</code> parameter).</p> <p>Here's an example of this error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {
    // error, method `foo` has a `&amp;self` declaration in the impl, but not in
    // the trait
    fn foo(&amp;self) {}
}</pre></div>  <h3 id="E0186" class="section-header">E0186</h3> <p>An associated function for a trait was defined to be a method (i.e., to take a <code>self</code> parameter), but an implementation of the trait declared the same function to be static.</p> <p>Here's an example of this error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo(&amp;self);
}

struct Bar;

impl Foo for Bar {
    // error, method `foo` has a `&amp;self` declaration in the trait, but not in
    // the impl
    fn foo() {}
}</pre></div>  <h3 id="E0191" class="section-header">E0191</h3> <p>Trait objects need to have all associated types specified. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Trait {
    type Bar;
}

type Foo = Trait; // error: the value of the associated type `Bar` (from
                  //        the trait `Trait`) must be specified</pre></div> <p>Please verify you specified all associated types of the trait and that you used the right trait. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    type Bar;
}

type Foo = Trait&lt;Bar=i32&gt;; // ok!</pre></div>  <h3 id="E0192" class="section-header">E0192</h3> <p>Negative impls are only allowed for auto traits. For more information see the <a href="https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md" target="_blank">opt-in builtin traits RFC</a>.</p>  <h3 id="E0193" class="section-header">E0193</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-13" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p><code>where</code> clauses must use generic type parameters: it does not make sense to use them otherwise. An example causing this error:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn bar(&amp;self);
}

#[derive(Copy,Clone)]
struct Wrapper&lt;T&gt; {
    Wrapped: T
}

impl Foo for Wrapper&lt;u32&gt; where Wrapper&lt;u32&gt;: Clone {
    fn bar(&amp;self) { }
}</pre></div> <p>This use of a <code>where</code> clause is strange - a more common usage would look something like the following:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn bar(&amp;self);
}

#[derive(Copy,Clone)]
struct Wrapper&lt;T&gt; {
    Wrapped: T
}
impl &lt;T&gt; Foo for Wrapper&lt;T&gt; where Wrapper&lt;T&gt;: Clone {
    fn bar(&amp;self) { }
}</pre></div> <p>Here, we're saying that the implementation exists on Wrapper only when the wrapped type <code>T</code> implements <code>Clone</code>. The <code>where</code> clause is important because some types will not implement <code>Clone</code>, and thus will not get this method.</p> <p>In our erroneous example, however, we're referencing a single concrete type. Since we know for certain that <code>Wrapper&lt;u32&gt;</code> implements <code>Clone</code>, there's no reason to also specify it in a <code>where</code> clause.</p>  <h3 id="E0194" class="section-header">E0194</h3> <p>A type parameter was declared which shadows an existing one. An example of this error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo&lt;T&gt; {
    fn do_something(&amp;self) -&gt; T;
    fn do_something_else&lt;T: Clone&gt;(&amp;self, bar: T);
}</pre></div> <p>In this example, the trait <code>Foo</code> and the trait method <code>do_something_else</code> both define a type parameter <code>T</code>. This is not allowed: if the method wishes to define a type parameter, it must use a different name for it.</p>  <h3 id="E0195" class="section-header">E0195</h3> <p>Your method's lifetime parameters do not match the trait declaration. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Trait {
    fn bar&lt;'a,'b:'a&gt;(x: &amp;'a str, y: &amp;'b str);
}

struct Foo;

impl Trait for Foo {
    fn bar&lt;'a,'b&gt;(x: &amp;'a str, y: &amp;'b str) {
    // error: lifetime parameters or bounds on method `bar`
    // do not match the trait declaration
    }
}</pre></div> <p>The lifetime constraint <code>'b</code> for bar() implementation does not match the trait declaration. Ensure lifetime declarations match exactly in both trait declaration and implementation. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn t&lt;'a,'b:'a&gt;(x: &amp;'a str, y: &amp;'b str);
}

struct Foo;

impl Trait for Foo {
    fn t&lt;'a,'b:'a&gt;(x: &amp;'a str, y: &amp;'b str) { // ok!
    }
}</pre></div>  <h3 id="E0197" class="section-header">E0197</h3> <p>Inherent implementations (one that do not implement a trait but provide methods associated with a type) are always safe because they are not implementing an unsafe trait. Removing the <code>unsafe</code> keyword from the inherent implementation will resolve this error.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

// this will cause this error
unsafe impl Foo { }
// converting it to this will fix it
impl Foo { }</pre></div>  <h3 id="E0198" class="section-header">E0198</h3> <p>A negative implementation is one that excludes a type from implementing a particular trait. Not being able to use a trait is always a safe operation, so negative implementations are always safe and never need to be marked as unsafe.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(optin_builtin_traits)]

struct Foo;

// unsafe is unnecessary
unsafe impl !Clone for Foo { }</pre></div> <p>This will compile:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#![feature(optin_builtin_traits)]

struct Foo;

auto trait Enterprise {}

impl !Enterprise for Foo { }</pre></div> <p>Please note that negative impls are only allowed for auto traits.</p>  <h3 id="E0199" class="section-header">E0199</h3> <p>Safe traits should not have unsafe implementations, therefore marking an implementation for a safe trait unsafe will cause a compiler error. Removing the unsafe marker on the trait noted in the error will resolve this problem.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

trait Bar { }

// this won't compile because Bar is safe
unsafe impl Bar for Foo { }
// this will compile
impl Bar for Foo { }</pre></div>  <h3 id="E0200" class="section-header">E0200</h3> <p>Unsafe traits must have unsafe implementations. This error occurs when an implementation for an unsafe trait isn't marked as unsafe. This may be resolved by marking the unsafe implementation as unsafe.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

unsafe trait Bar { }

// this won't compile because Bar is unsafe and impl isn't unsafe
impl Bar for Foo { }
// this will compile
unsafe impl Bar for Foo { }</pre></div>  <h3 id="E0201" class="section-header">E0201</h3> <p>It is an error to define two associated items (like methods, associated types, associated functions, etc.) with the same identifier.</p> <p>For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo(u8);

impl Foo {
    fn bar(&amp;self) -&gt; bool { self.0 &gt; 5 }
    fn bar() {} // error: duplicate associated function
}

trait Baz {
    type Quux;
    fn baz(&amp;self) -&gt; bool;
}

impl Baz for Foo {
    type Quux = u32;

    fn baz(&amp;self) -&gt; bool { true }

    // error: duplicate method
    fn baz(&amp;self) -&gt; bool { self.0 &gt; 5 }

    // error: duplicate associated type
    type Quux = u32;
}</pre></div> <p>Note, however, that items with the same name are allowed for inherent <code>impl</code> blocks that don't overlap:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;T&gt;(T);

impl Foo&lt;u8&gt; {
    fn bar(&amp;self) -&gt; bool { self.0 &gt; 5 }
}

impl Foo&lt;bool&gt; {
    fn bar(&amp;self) -&gt; bool { self.0 }
}</pre></div>  <h3 id="E0202" class="section-header">E0202</h3> <p>Inherent associated types were part of <a href="https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md" target="_blank">RFC 195</a> but are not yet implemented. See <a href="https://github.com/rust-lang/rust/issues/8995" target="_blank">the tracking issue</a> for the status of this implementation.</p>   <h3 id="E0204" class="section-header">E0204</h3> <p>An attempt to implement the <code>Copy</code> trait for a struct failed because one of the fields does not implement <code>Copy</code>. To fix this, you must implement <code>Copy</code> for the mentioned field. Note that this may not be possible, as in the example of</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    foo : Vec&lt;u32&gt;,
}

impl Copy for Foo { }</pre></div> <p>This fails because <code>Vec&lt;T&gt;</code> does not implement <code>Copy</code> for any <code>T</code>.</p> <p>Here's another example that will fail:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[derive(Copy)]
struct Foo&lt;'a&gt; {
    ty: &amp;'a mut bool,
}</pre></div> <p>This fails because <code>&amp;mut T</code> is not <code>Copy</code>, even when <code>T</code> is <code>Copy</code> (this differs from the behavior for <code>&amp;T</code>, which is always <code>Copy</code>).</p>  <h3 id="E0206" class="section-header">E0206</h3> <p>You can only implement <code>Copy</code> for a struct or enum. Both of the following examples will fail, because neither <code>[u8; 256]</code> nor <code>&amp;'static mut Bar</code> (mutable reference to <code>Bar</code>) is a struct or enum:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
type Foo = [u8; 256];
impl Copy for Foo { } // error

#[derive(Copy, Clone)]
struct Bar;
impl Copy for &amp;'static mut Bar { } // error</pre></div>  <h3 id="E0207" class="section-header">E0207</h3> <p>Any type parameter or lifetime parameter of an <code>impl</code> must meet at least one of the following criteria:</p> <ul> <li>it appears in the <em>implementing type</em> of the impl, e.g. <code>impl&lt;T&gt; Foo&lt;T&gt;</code>
</li> <li>for a trait impl, it appears in the <em>implemented trait</em>, e.g. <code>impl&lt;T&gt; SomeTrait&lt;T&gt; for Foo</code>
</li> <li>it is bound as an associated type, e.g. <code>impl&lt;T, U&gt; SomeTrait for T where T: AnotherTrait&lt;AssocType=U&gt;</code>
</li> </ul> <h3 id="error-example-1" class="section-header">Error example 1</h3> <p>Suppose we have a struct <code>Foo</code> and we would like to define some methods for it. The following definition leads to a compiler error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

impl&lt;T: Default&gt; Foo {
// error: the type parameter `T` is not constrained by the impl trait, self
// type, or predicates [E0207]
    fn get(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}</pre></div> <p>The problem is that the parameter <code>T</code> does not appear in the implementing type (<code>Foo</code>) of the impl. In this case, we can fix the error by moving the type parameter from the <code>impl</code> to the method <code>get</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo;

// Move the type parameter from the impl to the method
impl Foo {
    fn get&lt;T: Default&gt;(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}</pre></div> <h3 id="error-example-2" class="section-header">Error example 2</h3> <p>As another example, suppose we have a <code>Maker</code> trait and want to establish a type <code>FooMaker</code> that makes <code>Foo</code>s:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

struct FooMaker;

impl&lt;T: Default&gt; Maker for FooMaker {
// error: the type parameter `T` is not constrained by the impl trait, self
// type, or predicates [E0207]
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo { foo: &lt;T as Default&gt;::default() }
    }
}</pre></div> <p>This fails to compile because <code>T</code> does not appear in the trait or in the implementing type.</p> <p>One way to work around this is to introduce a phantom type parameter into <code>FooMaker</code>, like so:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::marker::PhantomData;

trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

// Add a type parameter to `FooMaker`
struct FooMaker&lt;T&gt; {
    phantom: PhantomData&lt;T&gt;,
}

impl&lt;T: Default&gt; Maker for FooMaker&lt;T&gt; {
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo {
            foo: &lt;T as Default&gt;::default(),
        }
    }
}</pre></div> <p>Another way is to do away with the associated type in <code>Maker</code> and use an input type parameter instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// Use a type parameter instead of an associated type here
trait Maker&lt;Item&gt; {
    fn make(&amp;mut self) -&gt; Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

struct FooMaker;

impl&lt;T: Default&gt; Maker&lt;Foo&lt;T&gt;&gt; for FooMaker {
    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo { foo: &lt;T as Default&gt;::default() }
    }
}</pre></div> <h3 id="additional-information" class="section-header">Additional information</h3> <p>For more information, please see <a href="https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md" target="_blank">RFC 447</a>.</p>   <h3 id="E0210" class="section-header">E0210</h3> <p>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule concerns the use of type parameters in an implementation of a foreign trait (a trait defined in another crate), and states that type parameters must be "covered" by a local type. To understand what this means, it is perhaps easiest to consider a few examples.</p> <p>If <code>ForeignTrait</code> is a trait defined in some external crate <code>foo</code>, then the following trait <code>impl</code> is an error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
extern crate foo;
use foo::ForeignTrait;

impl&lt;T&gt; ForeignTrait for T { } // error</pre></div> <p>To work around this, it can be covered with a local type, <code>MyType</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct MyType&lt;T&gt;(T);
impl&lt;T&gt; ForeignTrait for MyType&lt;T&gt; { } // Ok</pre></div> <p>Please note that a type alias is not sufficient.</p> <p>For another example of an error, suppose there's another trait defined in <code>foo</code> named <code>ForeignTrait2</code> that takes two type parameters. Then this <code>impl</code> results in the same rule violation:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
struct MyType2;
impl&lt;T&gt; ForeignTrait2&lt;T, MyType&lt;T&gt;&gt; for MyType2 { } // error</pre></div> <p>The reason for this is that there are two appearances of type parameter <code>T</code> in the <code>impl</code> header, both as parameters for <code>ForeignTrait2</code>. The first appearance is uncovered, and so runs afoul of the orphan rule.</p> <p>Consider one more example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
impl&lt;T&gt; ForeignTrait2&lt;MyType&lt;T&gt;, T&gt; for MyType2 { } // Ok</pre></div> <p>This only differs from the previous <code>impl</code> in that the parameters <code>T</code> and <code>MyType&lt;T&gt;</code> for <code>ForeignTrait2</code> have been swapped. This example does <em>not</em> violate the orphan rule; it is permitted.</p> <p>To see why that last example was allowed, you need to understand the general rule. Unfortunately this rule is a bit tricky to state. Consider an <code>impl</code>:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
impl&lt;P1, ..., Pm&gt; ForeignTrait&lt;T1, ..., Tn&gt; for T0 { ... }</pre></div> <p>where <code>P1, ..., Pm</code> are the type parameters of the <code>impl</code> and <code>T0, ..., Tn</code> are types. One of the types <code>T0, ..., Tn</code> must be a local type (this is another orphan rule, see the explanation for E0117). Let <code>i</code> be the smallest integer such that <code>Ti</code> is a local type. Then no type parameter can appear in any of the <code>Tj</code> for <code>j &lt; i</code>.</p> <p>For information on the design of the orphan rules, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md" target="_blank">RFC 1023</a>.</p>   <h3 id="E0214" class="section-header">E0214</h3> <p>A generic type was described using parentheses rather than angle brackets. For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    let v: Vec(&amp;str) = vec!["foo"];
}</pre></div> <p>This is not currently supported: <code>v</code> should be defined as <code>Vec&lt;&amp;str&gt;</code>. Parentheses are currently only used with generic types when defining parameters for <code>Fn</code>-family traits.</p>  <h3 id="E0220" class="section-header">E0220</h3> <p>You used an associated type which isn't defined in the trait. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait T1 {
    type Bar;
}

type Foo = T1&lt;F=i32&gt;; // error: associated type `F` not found for `T1`

// or:

trait T2 {
    type Bar;

    // error: Baz is used but not declared
    fn return_bool(&amp;self, _: &amp;Self::Bar, _: &amp;Self::Baz) -&gt; bool;
}</pre></div> <p>Make sure that you have defined the associated type in the trait body. Also, verify that you used the right trait or you didn't misspell the associated type name. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait T1 {
    type Bar;
}

type Foo = T1&lt;Bar=i32&gt;; // ok!

// or:

trait T2 {
    type Bar;
    type Baz; // we declare `Baz` in our trait.

    // and now we can use it here:
    fn return_bool(&amp;self, _: &amp;Self::Bar, _: &amp;Self::Baz) -&gt; bool;
}</pre></div>  <h3 id="E0221" class="section-header">E0221</h3> <p>An attempt was made to retrieve an associated type, but the type was ambiguous. For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait T1 {}
trait T2 {}

trait Foo {
    type A: T1;
}

trait Bar : Foo {
    type A: T2;
    fn do_something() {
        let _: Self::A;
    }
}</pre></div> <p>In this example, <code>Foo</code> defines an associated type <code>A</code>. <code>Bar</code> inherits that type from <code>Foo</code>, and defines another associated type of the same name. As a result, when we attempt to use <code>Self::A</code>, it's ambiguous whether we mean the <code>A</code> defined by <code>Foo</code> or the one defined by <code>Bar</code>.</p> <p>There are two options to work around this issue. The first is simply to rename one of the types. Alternatively, one can specify the intended type using the following syntax:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait T1 {}
trait T2 {}

trait Foo {
    type A: T1;
}

trait Bar : Foo {
    type A: T2;
    fn do_something() {
        let _: &lt;Self as Bar&gt;::A;
    }
}</pre></div>  <h3 id="E0223" class="section-header">E0223</h3> <p>An attempt was made to retrieve an associated type, but the type was ambiguous. For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait MyTrait {type X; }

fn main() {
    let foo: MyTrait::X;
}</pre></div> <p>The problem here is that we're attempting to take the type of X from MyTrait. Unfortunately, the type of X is not defined, because it's only made concrete in implementations of the trait. A working version of this code might look like:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait MyTrait {type X; }
struct MyStruct;

impl MyTrait for MyStruct {
    type X = u32;
}

fn main() {
    let foo: &lt;MyStruct as MyTrait&gt;::X;
}</pre></div> <p>This syntax specifies that we want the X type from MyTrait, as made concrete in MyStruct. The reason that we cannot simply use <code>MyStruct::X</code> is that MyStruct might implement two different traits with identically-named associated types. This syntax allows disambiguation between the two.</p>   <h3 id="E0225" class="section-header">E0225</h3> <p>You attempted to use multiple types as bounds for a closure or trait object. Rust does not currently support this. A simple example that causes this error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    let _: Box&lt;dyn std::io::Read + std::io::Write&gt;;
}</pre></div> <p>Auto traits such as Send and Sync are an exception to this rule: It's possible to have bounds of one non-builtin trait, plus any number of auto traits. For example, the following compiles correctly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let _: Box&lt;dyn std::io::Read + Send + Sync&gt;;
}</pre></div>     <h3 id="E0229" class="section-header">E0229</h3> <p>An associated type binding was done outside of the type parameter declaration and <code>where</code> clause. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
pub trait Foo {
    type A;
    fn boo(&amp;self) -&gt; &lt;Self as Foo&gt;::A;
}

struct Bar;

impl Foo for isize {
    type A = usize;
    fn boo(&amp;self) -&gt; usize { 42 }
}

fn baz&lt;I&gt;(x: &amp;&lt;I as Foo&lt;A=Bar&gt;&gt;::A) {}
// error: associated type bindings are not allowed here</pre></div> <p>To solve this error, please move the type bindings in the type parameter declaration:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn baz&lt;I: Foo&lt;A=Bar&gt;&gt;(x: &amp;&lt;I as Foo&gt;::A) {} // ok!</pre></div> <p>Or in the <code>where</code> clause:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn baz&lt;I&gt;(x: &amp;&lt;I as Foo&gt;::A) where I: Foo&lt;A=Bar&gt; {}</pre></div>  <h3 id="E0230" class="section-header">E0230</h3> <p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error message for when a particular trait isn't implemented on a type placed in a position that needs that trait. For example, when the following code is compiled:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(on_unimplemented)]

fn foo&lt;T: Index&lt;u8&gt;&gt;(x: T){}

#[rustc_on_unimplemented = "the type `{Self}` cannot be indexed by `{Idx}`"]
trait Index&lt;Idx&gt; { /* ... */ }

foo(true); // `bool` does not implement `Index&lt;u8&gt;`</pre></div> <p>There will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a note saying "the type <code>bool</code> cannot be indexed by <code>u8</code>".</p> <p>As you can see, you can specify type parameters in curly braces for substitution with the actual types (using the regular format string syntax) in a given situation. Furthermore, <code>{Self}</code> will substitute to the type (in this case, <code>bool</code>) that we tried to use.</p> <p>This error appears when the curly braces contain an identifier which doesn't match with any of the type parameters or the string <code>Self</code>. This might happen if you misspelled a type parameter, or if you intended to use literal curly braces. If it is the latter, escape the curly braces with a second curly brace of the same type; e.g., a literal <code>{</code> is <code>{{</code>.</p>  <h3 id="E0231" class="section-header">E0231</h3> <p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error message for when a particular trait isn't implemented on a type placed in a position that needs that trait. For example, when the following code is compiled:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(on_unimplemented)]

fn foo&lt;T: Index&lt;u8&gt;&gt;(x: T){}

#[rustc_on_unimplemented = "the type `{Self}` cannot be indexed by `{Idx}`"]
trait Index&lt;Idx&gt; { /* ... */ }

foo(true); // `bool` does not implement `Index&lt;u8&gt;`</pre></div> <p>there will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a note saying "the type <code>bool</code> cannot be indexed by <code>u8</code>".</p> <p>As you can see, you can specify type parameters in curly braces for substitution with the actual types (using the regular format string syntax) in a given situation. Furthermore, <code>{Self}</code> will substitute to the type (in this case, <code>bool</code>) that we tried to use.</p> <p>This error appears when the curly braces do not contain an identifier. Please add one of the same name as a type parameter. If you intended to use literal braces, use <code>{{</code> and <code>}}</code> to escape them.</p>  <h3 id="E0232" class="section-header">E0232</h3> <p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error message for when a particular trait isn't implemented on a type placed in a position that needs that trait. For example, when the following code is compiled:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(on_unimplemented)]

fn foo&lt;T: Index&lt;u8&gt;&gt;(x: T){}

#[rustc_on_unimplemented = "the type `{Self}` cannot be indexed by `{Idx}`"]
trait Index&lt;Idx&gt; { /* ... */ }

foo(true); // `bool` does not implement `Index&lt;u8&gt;`</pre></div> <p>there will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a note saying "the type <code>bool</code> cannot be indexed by <code>u8</code>".</p> <p>For this to work, some note must be specified. An empty attribute will not do anything, please remove the attribute or add some helpful note for users of the trait.</p>  <h3 id="E0243" class="section-header">E0243</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-14" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>This error indicates that not enough type parameters were found in a type or trait.</p> <p>For example, the <code>Foo</code> struct below is defined to be generic in <code>T</code>, but the type parameter is missing in the definition of <code>Bar</code>:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;T&gt; { x: T }

struct Bar { x: Foo }</pre></div>  <h3 id="E0244" class="section-header">E0244</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-15" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>This error indicates that too many type parameters were found in a type or trait.</p> <p>For example, the <code>Foo</code> struct below has no type parameters, but is supplied with two in the definition of <code>Bar</code>:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo { x: bool }

struct Bar&lt;S, T&gt; { x: Foo&lt;S, T&gt; }</pre></div>  <h3 id="E0251" class="section-header">E0251</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-16" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>Two items of the same name cannot be imported without rebinding one of the items under a new local name.</p> <p>An example of this error:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use foo::baz;
use bar::*; // error, do `use foo::baz as quux` instead on the previous line

fn main() {}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</pre></div>  <h3 id="E0252" class="section-header">E0252</h3> <p>Two items of the same name cannot be imported without rebinding one of the items under a new local name.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use foo::baz;
use bar::baz; // error, do `use bar::baz as quux` instead

fn main() {}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</pre></div> <p>You can use aliases in order to fix this error. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use foo::baz as foo_baz;
use bar::baz; // ok!

fn main() {}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</pre></div> <p>Or you can reference the item with its parent:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use bar::baz;

fn main() {
    let x = foo::baz; // ok!
}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</pre></div>  <h3 id="E0253" class="section-header">E0253</h3> <p>Attempt was made to import an unimportable value. This can happen when trying to import a method from a trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod foo {
    pub trait MyTrait {
        fn do_something();
    }
}

use foo::MyTrait::do_something;
// error: `do_something` is not directly importable

fn main() {}</pre></div> <p>It's invalid to directly import methods belonging to a trait or concrete type.</p>  <h3 id="E0254" class="section-header">E0254</h3> <p>Attempt was made to import an item whereas an extern crate with this name has already been imported.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
extern crate core;

mod foo {
    pub trait core {
        fn do_something();
    }
}

use foo::core;  // error: an extern crate named `core` has already
                //        been imported in this module

fn main() {}</pre></div> <p>To fix this issue, you have to rename at least one of the two imports. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
extern crate core as libcore; // ok!

mod foo {
    pub trait core {
        fn do_something();
    }
}

use foo::core;

fn main() {}</pre></div>  <h3 id="E0255" class="section-header">E0255</h3> <p>You can't import a value whose name is the same as another value defined in the module.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use bar::foo; // error: an item named `foo` is already in scope

fn foo() {}

mod bar {
     pub fn foo() {}
}

fn main() {}</pre></div> <p>You can use aliases in order to fix this error. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use bar::foo as bar_foo; // ok!

fn foo() {}

mod bar {
     pub fn foo() {}
}

fn main() {}</pre></div> <p>Or you can reference the item with its parent:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo() {}

mod bar {
     pub fn foo() {}
}

fn main() {
    bar::foo(); // we get the item by referring to its parent
}</pre></div>  <h3 id="E0256" class="section-header">E0256</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-17" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>You can't import a type or module when the name of the item being imported is the same as another type or submodule defined in the module.</p> <p>An example of this error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use foo::Bar; // error

type Bar = u32;

mod foo {
    pub mod Bar { }
}

fn main() {}</pre></div>  <h3 id="E0259" class="section-header">E0259</h3> <p>The name chosen for an external crate conflicts with another external crate that has been imported into the current module.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
extern crate core;
extern crate std as core;

fn main() {}</pre></div> <p>The solution is to choose a different name that doesn't conflict with any external crate imported into the current module.</p> <p>Correct example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
extern crate core;
extern crate std as other_name;

fn main() {}</pre></div>  <h3 id="E0260" class="section-header">E0260</h3> <p>The name for an item declaration conflicts with an external crate's name.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
extern crate core;

struct core;

fn main() {}</pre></div> <p>There are two possible solutions:</p> <p>Solution #1: Rename the item.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
extern crate core;

struct xyz;</pre></div> <p>Solution #2: Import the crate with a different name.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
extern crate core as xyz;

struct abc;</pre></div> <p>See the Declaration Statements section of the reference for more information about what constitutes an Item declaration and what does not:</p> <p>https://doc.rust-lang.org/reference.html#statements</p>  <h3 id="E0261" class="section-header">E0261</h3> <p>When using a lifetime like <code>'a</code> in a type, it must be declared before being used.</p> <p>These two examples illustrate the problem:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// error, use of undeclared lifetime name `'a`
fn foo(x: &amp;'a str) { }

struct Foo {
    // error, use of undeclared lifetime name `'a`
    x: &amp;'a str,
}</pre></div> <p>These can be fixed by declaring lifetime parameters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;'a&gt; {
    x: &amp;'a str,
}

fn foo&lt;'a&gt;(x: &amp;'a str) {}</pre></div> <p>Impl blocks declare lifetime parameters separately. You need to add lifetime parameters to an impl block if you're implementing a type that has a lifetime parameter of its own. For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;'a&gt; {
    x: &amp;'a str,
}

// error,  use of undeclared lifetime name `'a`
impl Foo&lt;'a&gt; {
    fn foo&lt;'a&gt;(x: &amp;'a str) {}
}</pre></div> <p>This is fixed by declaring the impl block like this:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;'a&gt; {
    x: &amp;'a str,
}

// correct
impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn foo(x: &amp;'a str) {}
}</pre></div>  <h3 id="E0262" class="section-header">E0262</h3> <p>Declaring certain lifetime names in parameters is disallowed. For example, because the <code>'static</code> lifetime is a special built-in lifetime name denoting the lifetime of the entire program, this is an error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// error, invalid lifetime parameter name `'static`
fn foo&lt;'static&gt;(x: &amp;'static str) { }</pre></div>  <h3 id="E0263" class="section-header">E0263</h3> <p>A lifetime name cannot be declared more than once in the same scope. For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// error, lifetime name `'a` declared twice in the same scope
fn foo&lt;'a, 'b, 'a&gt;(x: &amp;'a str, y: &amp;'b str) { }</pre></div>  <h3 id="E0264" class="section-header">E0264</h3> <p>An unknown external lang item was used. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(lang_items)]

extern "C" {
    #[lang = "cake"] // error: unknown external lang item: `cake`
    fn cake();
}</pre></div> <p>A list of available external lang items is available in <code>src/librustc/middle/weak_lang_items.rs</code>. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(lang_items)]

extern "C" {
    #[lang = "panic_impl"] // ok!
    fn cake();
}</pre></div>  <h3 id="E0267" class="section-header">E0267</h3> <p>This error indicates the use of a loop keyword (<code>break</code> or <code>continue</code>) inside a closure but outside of any loop. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let w = || { break; }; // error: `break` inside of a closure</pre></div> <p><code>break</code> and <code>continue</code> keywords can be used as normal inside closures as long as they are also contained within a loop. To halt the execution of a closure you should instead use a return statement. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let w = || {
    for _ in 0..10 {
        break;
    }
};

w();</pre></div>  <h3 id="E0268" class="section-header">E0268</h3> <p>This error indicates the use of a loop keyword (<code>break</code> or <code>continue</code>) outside of a loop. Without a loop to break out of or continue in, no sensible action can be taken. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn some_func() {
    break; // error: `break` outside of loop
}</pre></div> <p>Please verify that you are using <code>break</code> and <code>continue</code> only in loops. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn some_func() {
    for _ in 0..10 {
        break; // ok!
    }
}</pre></div>  <h3 id="E0271" class="section-header">E0271</h3> <p>This is because of a type mismatch between the associated type of some trait (e.g., <code>T::Bar</code>, where <code>T</code> implements <code>trait Quux { type Bar; }</code>) and another type <code>U</code> that is required to be equal to <code>T::Bar</code>, but is not. Examples follow.</p> <p>Here is a basic example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Trait { type AssociatedType; }

fn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType=u32&gt; {
    println!("in foo");
}

impl Trait for i8 { type AssociatedType = &amp;'static str; }

foo(3_i8);</pre></div> <p>Here is that same example again, with some explanatory comments:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Trait { type AssociatedType; }

fn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType=u32&gt; {
//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~
//                        |            |
//         This says `foo` can         |
//           only be used with         |
//              some type that         |
//         implements `Trait`.         |
//                                     |
//                             This says not only must
//                             `T` be an impl of `Trait`
//                             but also that the impl
//                             must assign the type `u32`
//                             to the associated type.
    println!("in foo");
}

impl Trait for i8 { type AssociatedType = &amp;'static str; }
//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//      |                             |
// `i8` does have                     |
// implementation                     |
// of `Trait`...                      |
//                     ... but it is an implementation
//                     that assigns `&amp;'static str` to
//                     the associated type.

foo(3_i8);
// Here, we invoke `foo` with an `i8`, which does not satisfy
// the constraint `&lt;i8 as Trait&gt;::AssociatedType=u32`, and
// therefore the type-checker complains with this error code.</pre></div> <p>To avoid those issues, you have to make the types match correctly. So we can fix the previous examples like this:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// Basic Example:
trait Trait { type AssociatedType; }

fn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType = &amp;'static str&gt; {
    println!("in foo");
}

impl Trait for i8 { type AssociatedType = &amp;'static str; }

foo(3_i8);

// For-Loop Example:
let vs = vec![1, 2, 3, 4];
for v in &amp;vs {
    match v {
        &amp;1 =&gt; {}
        _ =&gt; {}
    }
}</pre></div>  <h3 id="E0275" class="section-header">E0275</h3> <p>This error occurs when there was a recursive trait requirement that overflowed before it could be evaluated. Often this means that there is unbounded recursion in resolving some type bounds.</p> <p>For example, in the following code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {}

struct Bar&lt;T&gt;(T);

impl&lt;T&gt; Foo for T where Bar&lt;T&gt;: Foo {}</pre></div> <p>To determine if a <code>T</code> is <code>Foo</code>, we need to check if <code>Bar&lt;T&gt;</code> is <code>Foo</code>. However, to do this check, we need to determine that <code>Bar&lt;Bar&lt;T&gt;&gt;</code> is <code>Foo</code>. To determine this, we check if <code>Bar&lt;Bar&lt;Bar&lt;T&gt;&gt;&gt;</code> is <code>Foo</code>, and so on. This is clearly a recursive requirement that can't be resolved directly.</p> <p>Consider changing your trait bounds so that they're less self-referential.</p>  <h3 id="E0276" class="section-header">E0276</h3> <p>This error occurs when a bound in an implementation of a trait does not match the bounds specified in the original trait. For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo&lt;T&gt;(x: T);
}

impl Foo for bool {
    fn foo&lt;T&gt;(x: T) where T: Copy {}
}</pre></div> <p>Here, all types implementing <code>Foo</code> must have a method <code>foo&lt;T&gt;(x: T)</code> which can take any type <code>T</code>. However, in the <code>impl</code> for <code>bool</code>, we have added an extra bound that <code>T</code> is <code>Copy</code>, which isn't compatible with the original trait.</p> <p>Consider removing the bound from the method or adding the bound to the original method definition in the trait.</p>  <h3 id="E0277" class="section-header">E0277</h3> <p>You tried to use a type which doesn't implement some trait in a place which expected that trait. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// here we declare the Foo trait with a bar method
trait Foo {
    fn bar(&amp;self);
}

// we now declare a function which takes an object implementing the Foo trait
fn some_func&lt;T: Foo&gt;(foo: T) {
    foo.bar();
}

fn main() {
    // we now call the method with the i32 type, which doesn't implement
    // the Foo trait
    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied
}</pre></div> <p>In order to fix this error, verify that the type you're using does implement the trait. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn bar(&amp;self);
}

fn some_func&lt;T: Foo&gt;(foo: T) {
    foo.bar(); // we can now use this method since i32 implements the
               // Foo trait
}

// we implement the trait on the i32 type
impl Foo for i32 {
    fn bar(&amp;self) {}
}

fn main() {
    some_func(5i32); // ok!
}</pre></div> <p>Or in a generic context, an erroneous code example would look like:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn some_func&lt;T&gt;(foo: T) {
    println!("{:?}", foo); // error: the trait `core::fmt::Debug` is not
                           //        implemented for the type `T`
}

fn main() {
    // We now call the method with the i32 type,
    // which *does* implement the Debug trait.
    some_func(5i32);
}</pre></div> <p>Note that the error here is in the definition of the generic function: Although we only call it with a parameter that does implement <code>Debug</code>, the compiler still rejects the function: It must work with all possible input types. In order to make this example compile, we need to restrict the generic type we're accepting:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::fmt;

// Restrict the input type to types that implement Debug.
fn some_func&lt;T: fmt::Debug&gt;(foo: T) {
    println!("{:?}", foo);
}

fn main() {
    // Calling the method is still fine, as i32 implements Debug.
    some_func(5i32);

    // This would fail to compile now:
    // struct WithoutDebug;
    // some_func(WithoutDebug);
}</pre></div> <p>Rust only looks at the signature of the called function, as such it must already specify all requirements that will be used for every type parameter.</p>     <h3 id="E0281" class="section-header">E0281</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-18" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>You tried to supply a type which doesn't implement some trait in a location which expected that trait. This error typically occurs when working with <code>Fn</code>-based types. Erroneous code example:</p> <pre>fn foo&lt;F: Fn(usize)&gt;(x: F) { }

fn main() {
    // type mismatch: ... implements the trait `core::ops::Fn&lt;(String,)&gt;`,
    // but the trait `core::ops::Fn&lt;(usize,)&gt;` is required
    // [E0281]
    foo(|y: String| { });
}
</pre> <p>The issue in this case is that <code>foo</code> is defined as accepting a <code>Fn</code> with one argument of type <code>String</code>, but the closure we attempted to pass to it requires one arguments of type <code>usize</code>.</p>  <h3 id="E0282" class="section-header">E0282</h3> <p>This error indicates that type inference did not result in one unique possible type, and extra information is required. In most cases this can be provided by adding a type annotation. Sometimes you need to specify a generic type parameter manually.</p> <p>A common example is the <code>collect</code> method on <code>Iterator</code>. It has a generic type parameter with a <code>FromIterator</code> bound, which for a <code>char</code> iterator is implemented by <code>Vec</code> and <code>String</code> among others. Consider the following snippet that reverses the characters of a string:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = "hello".chars().rev().collect();</pre></div> <p>In this case, the compiler cannot infer what the type of <code>x</code> should be: <code>Vec&lt;char&gt;</code> and <code>String</code> are both suitable candidates. To specify which type to use, you can use a type annotation on <code>x</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x: Vec&lt;char&gt; = "hello".chars().rev().collect();</pre></div> <p>It is not necessary to annotate the full type. Once the ambiguity is resolved, the compiler can infer the rest:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x: Vec&lt;_&gt; = "hello".chars().rev().collect();</pre></div> <p>Another way to provide the compiler with enough information, is to specify the generic type parameter:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = "hello".chars().rev().collect::&lt;Vec&lt;char&gt;&gt;();</pre></div> <p>Again, you need not specify the full type if the compiler can infer it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = "hello".chars().rev().collect::&lt;Vec&lt;_&gt;&gt;();</pre></div> <p>Apart from a method or function with a generic type parameter, this error can occur when a type parameter of a struct or trait cannot be inferred. In that case it is not always possible to use a type annotation, because all candidates have the same return type. For instance:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;T&gt; {
    num: T,
}

impl&lt;T&gt; Foo&lt;T&gt; {
    fn bar() -&gt; i32 {
        0
    }

    fn baz() {
        let number = Foo::bar();
    }
}</pre></div> <p>This will fail because the compiler does not know which instance of <code>Foo</code> to call <code>bar</code> on. Change <code>Foo::bar()</code> to <code>Foo::&lt;T&gt;::bar()</code> to resolve the error.</p>  <h3 id="E0283" class="section-header">E0283</h3> <p>This error occurs when the compiler doesn't have enough information to unambiguously choose an implementation.</p> <p>For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Generator {
    fn create() -&gt; u32;
}

struct Impl;

impl Generator for Impl {
    fn create() -&gt; u32 { 1 }
}

struct AnotherImpl;

impl Generator for AnotherImpl {
    fn create() -&gt; u32 { 2 }
}

fn main() {
    let cont: u32 = Generator::create();
    // error, impossible to choose one of Generator trait implementation
    // Should it be Impl or AnotherImpl, maybe something else?
}</pre></div> <p>To resolve this error use the concrete type:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Generator {
    fn create() -&gt; u32;
}

struct AnotherImpl;

impl Generator for AnotherImpl {
    fn create() -&gt; u32 { 2 }
}

fn main() {
    let gen1 = AnotherImpl::create();

    // if there are multiple methods with same name (different traits)
    let gen2 = &lt;AnotherImpl as Generator&gt;::create();
}</pre></div>  <h3 id="E0284" class="section-header">E0284</h3> <p>This error occurs when the compiler is unable to unambiguously infer the return type of a function or method which is generic on return type, such as the <code>collect</code> method for <code>Iterator</code>s.</p> <p>For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo() -&gt; Result&lt;bool, ()&gt; {
    let results = [Ok(true), Ok(false), Err(())].iter().cloned();
    let v: Vec&lt;bool&gt; = results.collect()?;
    // Do things with v...
    Ok(true)
}</pre></div> <p>Here we have an iterator <code>results</code> over <code>Result&lt;bool, ()&gt;</code>. Hence, <code>results.collect()</code> can return any type implementing <code>FromIterator&lt;Result&lt;bool, ()&gt;&gt;</code>. On the other hand, the <code>?</code> operator can accept any type implementing <code>Try</code>.</p> <p>The author of this code probably wants <code>collect()</code> to return a <code>Result&lt;Vec&lt;bool&gt;, ()&gt;</code>, but the compiler can't be sure that there isn't another type <code>T</code> implementing both <code>Try</code> and <code>FromIterator&lt;Result&lt;bool, ()&gt;&gt;</code> in scope such that <code>T::Ok == Vec&lt;bool&gt;</code>. Hence, this code is ambiguous and an error is returned.</p> <p>To resolve this error, use a concrete type for the intermediate expression:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo() -&gt; Result&lt;bool, ()&gt; {
    let results = [Ok(true), Ok(false), Err(())].iter().cloned();
    let v = {
        let temp: Result&lt;Vec&lt;bool&gt;, ()&gt; = results.collect();
        temp?
    };
    // Do things with v...
    Ok(true)
}</pre></div> <p>Note that the type of <code>v</code> can now be inferred from the type of <code>temp</code>.</p>  <h3 id="E0297" class="section-header">E0297</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-19" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>Patterns used to bind names must be irrefutable. That is, they must guarantee that a name will be extracted in all cases. Instead of pattern matching the loop variable, consider using a <code>match</code> or <code>if let</code> inside the loop body. For instance:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let xs : Vec&lt;Option&lt;i32&gt;&gt; = vec![Some(1), None];

// This fails because `None` is not covered.
for Some(x) in xs {
    // ...
}</pre></div> <p>Match inside the loop instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let xs : Vec&lt;Option&lt;i32&gt;&gt; = vec![Some(1), None];

for item in xs {
    match item {
        Some(x) =&gt; {},
        None =&gt; {},
    }
}</pre></div> <p>Or use <code>if let</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let xs : Vec&lt;Option&lt;i32&gt;&gt; = vec![Some(1), None];

for item in xs {
    if let Some(x) = item {
        // ...
    }
}</pre></div>  <h3 id="E0301" class="section-header">E0301</h3> <p>Mutable borrows are not allowed in pattern guards, because matching cannot have side effects. Side effects could alter the matched object or the environment on which the match depends in such a way, that the match would not be exhaustive. For instance, the following would not match any arm if mutable borrows were allowed:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
match Some(()) {
    None =&gt; { },
    option if option.take().is_none() =&gt; {
        /* impossible, option is `Some` */
    },
    Some(_) =&gt; { } // When the previous match failed, the option became `None`.
}</pre></div>  <h3 id="E0302" class="section-header">E0302</h3> <p>Assignments are not allowed in pattern guards, because matching cannot have side effects. Side effects could alter the matched object or the environment on which the match depends in such a way, that the match would not be exhaustive. For instance, the following would not match any arm if assignments were allowed:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
match Some(()) {
    None =&gt; { },
    option if { option = None; false } =&gt; { },
    Some(_) =&gt; { } // When the previous match failed, the option became `None`.
}</pre></div>  <h3 id="E0303" class="section-header">E0303</h3> <p>In certain cases it is possible for sub-bindings to violate memory safety. Updates to the borrow checker in a future version of Rust may remove this restriction, but for now patterns must be rewritten without sub-bindings.</p> <p>Before:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
match Some("hi".to_string()) {
    ref op_string_ref @ Some(s) =&gt; {},
    None =&gt; {},
}</pre></div> <p>After:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
match Some("hi".to_string()) {
    Some(ref s) =&gt; {
        let op_string_ref = &amp;Some(s);
        // ...
    },
    None =&gt; {},
}</pre></div> <p>The <code>op_string_ref</code> binding has type <code>&amp;Option&lt;&amp;String&gt;</code> in both cases.</p> <p>See also https://github.com/rust-lang/rust/issues/14587</p>   <h3 id="E0308" class="section-header">E0308</h3> <p>This error occurs when the compiler was unable to infer the concrete type of a variable. It can occur for several cases, the most common of which is a mismatch in the expected type that the compiler inferred for a variable's initializing expression, and the actual type explicitly assigned to the variable.</p> <p>For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x: i32 = "I am not a number!";
//     ~~~   ~~~~~~~~~~~~~~~~~~~~
//      |             |
//      |    initializing expression;
//      |    compiler infers type `&amp;str`
//      |
//    type `i32` assigned to variable `x`</pre></div>  <h3 id="E0309" class="section-header">E0309</h3> <p>The type definition contains some field whose type requires an outlives annotation. Outlives annotations (e.g., <code>T: 'a</code>) are used to guarantee that all the data in T is valid for at least the lifetime <code>'a</code>. This scenario most commonly arises when the type contains an associated type reference like <code>&lt;T as SomeTrait&lt;'a&gt;&gt;::Output</code>, as shown in this example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// This won't compile because the applicable impl of
// `SomeTrait` (below) requires that `T: 'a`, but the struct does
// not have a matching where-clause.
struct Foo&lt;'a, T&gt; {
    foo: &lt;T as SomeTrait&lt;'a&gt;&gt;::Output,
}

trait SomeTrait&lt;'a&gt; {
    type Output;
}

impl&lt;'a, T&gt; SomeTrait&lt;'a&gt; for T
where
    T: 'a,
{
    type Output = u32;
}</pre></div> <p>Here, the where clause <code>T: 'a</code> that appears on the impl is not known to be satisfied on the struct. To make this example compile, you have to add a where-clause like <code>T: 'a</code> to the struct definition:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;'a, T&gt;
where
    T: 'a,
{
    foo: &lt;T as SomeTrait&lt;'a&gt;&gt;::Output
}

trait SomeTrait&lt;'a&gt; {
    type Output;
}

impl&lt;'a, T&gt; SomeTrait&lt;'a&gt; for T
where
    T: 'a,
{
    type Output = u32;
}</pre></div>  <h3 id="E0310" class="section-header">E0310</h3> <p>Types in type definitions have lifetimes associated with them that represent how long the data stored within them is guaranteed to be live. This lifetime must be as long as the data needs to be alive, and missing the constraint that denotes this will cause this error.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// This won't compile because T is not constrained to the static lifetime
// the reference needs
struct Foo&lt;T&gt; {
    foo: &amp;'static T
}</pre></div> <p>This will compile, because it has the constraint on the type parameter:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;T: 'static&gt; {
    foo: &amp;'static T
}</pre></div>        <h3 id="E0317" class="section-header">E0317</h3> <p>This error occurs when an <code>if</code> expression without an <code>else</code> block is used in a context where a type other than <code>()</code> is expected, for example a <code>let</code> expression:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    let x = 5;
    let a = if x == 5 { 1 };
}</pre></div> <p>An <code>if</code> expression without an <code>else</code> block has the type <code>()</code>, so this is a type error. To resolve it, add an <code>else</code> block having the same type as the <code>if</code> block.</p>   <h3 id="E0321" class="section-header">E0321</h3> <p>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(optin_builtin_traits)]

struct Foo;

impl !Sync for Foo {}

unsafe impl Send for &amp;'static Foo {}
// error: cross-crate traits with a default impl, like `core::marker::Send`,
//        can only be implemented for a struct/enum type, not
//        `&amp;'static Foo`</pre></div> <p>Only structs and enums are permitted to impl Send, Sync, and other opt-out trait, and the struct or enum must be local to the current crate. So, for example, <code>unsafe impl Send for Rc&lt;Foo&gt;</code> is not allowed.</p>  <h3 id="E0322" class="section-header">E0322</h3> <p>The <code>Sized</code> trait is a special trait built-in to the compiler for types with a constant size known at compile-time. This trait is automatically implemented for types as needed by the compiler, and it is currently disallowed to explicitly implement it for a type.</p>  <h3 id="E0323" class="section-header">E0323</h3> <p>An associated const was implemented when another trait item was expected. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    type N;
}

struct Bar;

impl Foo for Bar {
    const N : u32 = 0;
    // error: item `N` is an associated const, which doesn't match its
    //        trait `&lt;Bar as Foo&gt;`
}</pre></div> <p>Please verify that the associated const wasn't misspelled and the correct trait was implemented. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Bar;

trait Foo {
    type N;
}

impl Foo for Bar {
    type N = u32; // ok!
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Bar;

trait Foo {
    const N : u32;
}

impl Foo for Bar {
    const N : u32 = 0; // ok!
}</pre></div>  <h3 id="E0324" class="section-header">E0324</h3> <p>A method was implemented when another trait item was expected. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Bar;

trait Foo {
    const N : u32;

    fn M();
}

impl Foo for Bar {
    fn N() {}
    // error: item `N` is an associated method, which doesn't match its
    //        trait `&lt;Bar as Foo&gt;`
}</pre></div> <p>To fix this error, please verify that the method name wasn't misspelled and verify that you are indeed implementing the correct trait items. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Bar;

trait Foo {
    const N : u32;

    fn M();
}

impl Foo for Bar {
    const N : u32 = 0;

    fn M() {} // ok!
}</pre></div>  <h3 id="E0325" class="section-header">E0325</h3> <p>An associated type was implemented when another trait item was expected. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Bar;

trait Foo {
    const N : u32;
}

impl Foo for Bar {
    type N = u32;
    // error: item `N` is an associated type, which doesn't match its
    //        trait `&lt;Bar as Foo&gt;`
}</pre></div> <p>Please verify that the associated type name wasn't misspelled and your implementation corresponds to the trait definition. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Bar;

trait Foo {
    type N;
}

impl Foo for Bar {
    type N = u32; // ok!
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Bar;

trait Foo {
    const N : u32;
}

impl Foo for Bar {
    const N : u32 = 0; // ok!
}</pre></div>  <h3 id="E0326" class="section-header">E0326</h3> <p>The types of any associated constants in a trait implementation must match the types in the trait definition. This error indicates that there was a mismatch.</p> <p>Here's an example of this error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    const BAR: bool;
}

struct Bar;

impl Foo for Bar {
    const BAR: u32 = 5; // error, expected bool, found u32
}</pre></div>  <h3 id="E0328" class="section-header">E0328</h3> <p>The Unsize trait should not be implemented directly. All implementations of Unsize are provided automatically by the compiler.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(unsize)]

use std::marker::Unsize;

pub struct MyType;

impl&lt;T&gt; Unsize&lt;T&gt; for MyType {}</pre></div> <p>If you are defining your own smart pointer type and would like to enable conversion from a sized to an unsized type with the <a href="https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md" target="_blank">DST coercion system</a>, use <a href="../std/ops/trait.coerceunsized/"><code>CoerceUnsized</code></a> instead.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(coerce_unsized)]

use std::ops::CoerceUnsized;

pub struct MyType&lt;T: ?Sized&gt; {
    field_with_unsized_type: T,
}

impl&lt;T, U&gt; CoerceUnsized&lt;MyType&lt;U&gt;&gt; for MyType&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}</pre></div>  <h3 id="E0364" class="section-header">E0364</h3> <p>Private items cannot be publicly re-exported. This error indicates that you attempted to <code>pub use</code> a type or value that was not itself public.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod foo {
    const X: u32 = 1;
}

pub use foo::X;

fn main() {}</pre></div> <p>The solution to this problem is to ensure that the items that you are re-exporting are themselves marked with <code>pub</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod foo {
    pub const X: u32 = 1;
}

pub use foo::X;

fn main() {}</pre></div> <p>See the 'Use Declarations' section of the reference for more information on this topic:</p> <p>https://doc.rust-lang.org/reference.html#use-declarations</p>  <h3 id="E0365" class="section-header">E0365</h3> <p>Private modules cannot be publicly re-exported. This error indicates that you attempted to <code>pub use</code> a module that was not itself public.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod foo {
    pub const X: u32 = 1;
}

pub use foo as foo2;

fn main() {}</pre></div> <p>The solution to this problem is to ensure that the module that you are re-exporting is itself marked with <code>pub</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
pub mod foo {
    pub const X: u32 = 1;
}

pub use foo as foo2;

fn main() {}</pre></div> <p>See the 'Use Declarations' section of the reference for more information on this topic:</p> <p>https://doc.rust-lang.org/reference.html#use-declarations</p>  <h3 id="E0366" class="section-header">E0366</h3> <p>An attempt was made to implement <code>Drop</code> on a concrete specialization of a generic type. An example is shown below:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;T&gt; {
    t: T
}

impl Drop for Foo&lt;u32&gt; {
    fn drop(&amp;mut self) {}
}</pre></div> <p>This code is not legal: it is not possible to specialize <code>Drop</code> to a subset of implementations of a generic type. One workaround for this is to wrap the generic type, as shown below:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;T&gt; {
    t: T
}

struct Bar {
    t: Foo&lt;u32&gt;
}

impl Drop for Bar {
    fn drop(&amp;mut self) {}
}</pre></div>  <h3 id="E0367" class="section-header">E0367</h3> <p>An attempt was made to implement <code>Drop</code> on a specialization of a generic type. An example is shown below:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo{}

struct MyStruct&lt;T&gt; {
    t: T
}

impl&lt;T: Foo&gt; Drop for MyStruct&lt;T&gt; {
    fn drop(&amp;mut self) {}
}</pre></div> <p>This code is not legal: it is not possible to specialize <code>Drop</code> to a subset of implementations of a generic type. In order for this code to work, <code>MyStruct</code> must also require that <code>T</code> implements <code>Foo</code>. Alternatively, another option is to wrap the generic type in another that specializes appropriately:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo{}

struct MyStruct&lt;T&gt; {
    t: T
}

struct MyStructWrapper&lt;T: Foo&gt; {
    t: MyStruct&lt;T&gt;
}

impl &lt;T: Foo&gt; Drop for MyStructWrapper&lt;T&gt; {
    fn drop(&amp;mut self) {}
}</pre></div>  <h3 id="E0368" class="section-header">E0368</h3> <p>This error indicates that a binary assignment operator like <code>+=</code> or <code>^=</code> was applied to a type that doesn't support it. For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let mut x = 12f32; // error: binary operation `&lt;&lt;` cannot be applied to
                   //        type `f32`

x &lt;&lt;= 2;</pre></div> <p>To fix this error, please check that this type implements this binary operation. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut x = 12u32; // the `u32` type does implement the `ShlAssign` trait

x &lt;&lt;= 2; // ok!</pre></div> <p>It is also possible to overload most operators for your own type by implementing the <code>[OP]Assign</code> traits from <code>std::ops</code>.</p> <p>Another problem you might be facing is this: suppose you've overloaded the <code>+</code> operator for some type <code>Foo</code> by implementing the <code>std::ops::Add</code> trait for <code>Foo</code>, but you find that using <code>+=</code> does not work, as in this example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::ops::Add;

struct Foo(u32);

impl Add for Foo {
    type Output = Foo;

    fn add(self, rhs: Foo) -&gt; Foo {
        Foo(self.0 + rhs.0)
    }
}

fn main() {
    let mut x: Foo = Foo(5);
    x += Foo(7); // error, `+= cannot be applied to the type `Foo`
}</pre></div> <p>This is because <code>AddAssign</code> is not automatically implemented, so you need to manually implement it for your type.</p>  <h3 id="E0369" class="section-header">E0369</h3> <p>A binary operation was attempted on a type which doesn't support it. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = 12f32; // error: binary operation `&lt;&lt;` cannot be applied to
               //        type `f32`

x &lt;&lt; 2;</pre></div> <p>To fix this error, please check that this type implements this binary operation. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = 12u32; // the `u32` type does implement it:
               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html

x &lt;&lt; 2; // ok!</pre></div> <p>It is also possible to overload most operators for your own type by implementing traits from <code>std::ops</code>.</p> <p>String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left. If something should be added to a string literal, move the literal to the heap by allocating it with <code>to_owned()</code> like in <code>"Your text".to_owned()</code>.</p>  <h3 id="E0370" class="section-header">E0370</h3> <p>The maximum value of an enum was reached, so it cannot be automatically set in the next enum value. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(i64)]
enum Foo {
    X = 0x7fffffffffffffff,
    Y, // error: enum discriminant overflowed on value after
       //        9223372036854775807: i64; set explicitly via
       //        Y = -9223372036854775808 if that is desired outcome
}</pre></div> <p>To fix this, please set manually the next enum value or put the enum variant with the maximum value at the end of the enum. Examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(i64)]
enum Foo {
    X = 0x7fffffffffffffff,
    Y = 0, // ok!
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(i64)]
enum Foo {
    Y = 0, // ok!
    X = 0x7fffffffffffffff,
}</pre></div>  <h3 id="E0371" class="section-header">E0371</h3> <p>When <code>Trait2</code> is a subtrait of <code>Trait1</code> (for example, when <code>Trait2</code> has a definition like <code>trait Trait2: Trait1 { ... }</code>), it is not allowed to implement <code>Trait1</code> for <code>Trait2</code>. This is because <code>Trait2</code> already implements <code>Trait1</code> by definition, so it is not useful to do this.</p> <p>Example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo { fn foo(&amp;self) { } }
trait Bar: Foo { }
trait Baz: Bar { }

impl Bar for Baz { } // error, `Baz` implements `Bar` by definition
impl Foo for Baz { } // error, `Baz` implements `Bar` which implements `Foo`
impl Baz for Baz { } // error, `Baz` (trivially) implements `Baz`
impl Baz for Bar { } // Note: This is OK</pre></div>  <h3 id="E0373" class="section-header">E0373</h3> <p>This error occurs when an attempt is made to use data captured by a closure, when that data may no longer exist. It's most commonly seen when attempting to return a closure:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo() -&gt; Box&lt;Fn(u32) -&gt; u32&gt; {
    let x = 0u32;
    Box::new(|y| x + y)
}</pre></div> <p>Notice that <code>x</code> is stack-allocated by <code>foo()</code>. By default, Rust captures closed-over data by reference. This means that once <code>foo()</code> returns, <code>x</code> no longer exists. An attempt to access <code>x</code> within the closure would thus be unsafe.</p> <p>Another situation where this might be encountered is when spawning threads:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo() {
    let x = 0u32;
    let y = 1u32;

    let thr = std::thread::spawn(|| {
        x + y
    });
}</pre></div> <p>Since our new thread runs in parallel, the stack frame containing <code>x</code> and <code>y</code> may well have disappeared by the time we try to use them. Even if we call <code>thr.join()</code> within foo (which blocks until <code>thr</code> has completed, ensuring the stack frame won't disappear), we will not succeed: the compiler cannot prove that this behaviour is safe, and so won't let us do it.</p> <p>The solution to this problem is usually to switch to using a <code>move</code> closure. This approach moves (or copies, where possible) data into the closure, rather than taking references to it. For example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo() -&gt; Box&lt;Fn(u32) -&gt; u32&gt; {
    let x = 0u32;
    Box::new(move |y| x + y)
}</pre></div> <p>Now that the closure has its own copy of the data, there's no need to worry about safety.</p>  <h3 id="E0374" class="section-header">E0374</h3> <p>A struct without a field containing an unsized type cannot implement <code>CoerceUnsized</code>. An <a href="../book/ch19-04-advanced-types/#dynamically-sized-types-and-the-sized-trait">unsized type</a> is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized&gt; {
    a: i32,
}

// error: Struct `Foo` has no unsized fields that need `CoerceUnsized`.
impl&lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U&gt;&gt; for Foo&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}</pre></div> <p><code>CoerceUnsized</code> is used to coerce one struct containing an unsized type into another struct containing a different unsized type. If the struct doesn't have any fields of unsized types then you don't need explicit coercion to get the types you want. To fix this you can either not try to implement <code>CoerceUnsized</code> or you can add a field that is unsized to the struct.</p> <p>Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

// We don't need to impl `CoerceUnsized` here.
struct Foo {
    a: i32,
}

// We add the unsized type field to the struct.
struct Bar&lt;T: ?Sized&gt; {
    a: i32,
    b: T,
}

// The struct has an unsized field so we can implement
// `CoerceUnsized` for it.
impl&lt;T, U&gt; CoerceUnsized&lt;Bar&lt;U&gt;&gt; for Bar&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}</pre></div> <p>Note that <code>CoerceUnsized</code> is mainly used by smart pointers like <code>Box</code>, <code>Rc</code> and <code>Arc</code> to be able to mark that they can coerce unsized types that they are pointing at.</p>  <h3 id="E0375" class="section-header">E0375</h3> <p>A struct with more than one field containing an unsized type cannot implement <code>CoerceUnsized</code>. This only occurs when you are trying to coerce one of the types in your struct to another type in the struct. In this case we try to impl <code>CoerceUnsized</code> from <code>T</code> to <code>U</code> which are both types that the struct takes. An <a href="../book/ch19-04-advanced-types/#dynamically-sized-types-and-the-sized-trait">unsized type</a> is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized, U: ?Sized&gt; {
    a: i32,
    b: T,
    c: U,
}

// error: Struct `Foo` has more than one unsized field.
impl&lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U, T&gt;&gt; for Foo&lt;T, U&gt; {}</pre></div> <p><code>CoerceUnsized</code> only allows for coercion from a structure with a single unsized type field to another struct with a single unsized type field. In fact Rust only allows for a struct to have one unsized type in a struct and that unsized type must be the last field in the struct. So having two unsized types in a single struct is not allowed by the compiler. To fix this use only one field containing an unsized type in the struct and then use multiple structs to manage each unsized type field you need.</p> <p>Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized&gt; {
    a: i32,
    b: T,
}

impl &lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U&gt;&gt; for Foo&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}

fn coerce_foo&lt;T: CoerceUnsized&lt;U&gt;, U&gt;(t: T) -&gt; Foo&lt;U&gt; {
    Foo { a: 12i32, b: t } // we use coercion to get the `Foo&lt;U&gt;` type we need
}</pre></div>  <h3 id="E0376" class="section-header">E0376</h3> <p>The type you are trying to impl <code>CoerceUnsized</code> for is not a struct. <code>CoerceUnsized</code> can only be implemented for a struct. Unsized types are already able to be coerced without an implementation of <code>CoerceUnsized</code> whereas a struct containing an unsized type needs to know the unsized type field it's containing is able to be coerced. An <a href="../book/ch19-04-advanced-types/#dynamically-sized-types-and-the-sized-trait">unsized type</a> is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized&gt; {
    a: T,
}

// error: The type `U` is not a struct
impl&lt;T, U&gt; CoerceUnsized&lt;U&gt; for Foo&lt;T&gt; {}</pre></div> <p>The <code>CoerceUnsized</code> trait takes a struct type. Make sure the type you are providing to <code>CoerceUnsized</code> is a struct with only the last field containing an unsized type.</p> <p>Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

struct Foo&lt;T&gt; {
    a: T,
}

// The `Foo&lt;U&gt;` is a struct so `CoerceUnsized` can be implemented
impl&lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U&gt;&gt; for Foo&lt;T&gt; where T: CoerceUnsized&lt;U&gt; {}</pre></div> <p>Note that in Rust, structs can only contain an unsized type if the field containing the unsized type is the last and only unsized type field in the struct.</p>   <h3 id="E0378" class="section-header">E0378</h3> <p>The <code>DispatchFromDyn</code> trait currently can only be implemented for builtin pointer types and structs that are newtype wrappers around them — that is, the struct must have only one field (except for<code>PhantomData</code>), and that field must itself implement <code>DispatchFromDyn</code>.</p> <p>Examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(dispatch_from_dyn, unsize)]
use std::{
    marker::Unsize,
    ops::DispatchFromDyn,
};

struct Ptr&lt;T: ?Sized&gt;(*const T);

impl&lt;T: ?Sized, U: ?Sized&gt; DispatchFromDyn&lt;Ptr&lt;U&gt;&gt; for Ptr&lt;T&gt;
where
    T: Unsize&lt;U&gt;,
{}</pre></div> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(dispatch_from_dyn)]
use std::{
    ops::DispatchFromDyn,
    marker::PhantomData,
};

struct Wrapper&lt;T&gt; {
    ptr: T,
    _phantom: PhantomData&lt;()&gt;,
}

impl&lt;T, U&gt; DispatchFromDyn&lt;Wrapper&lt;U&gt;&gt; for Wrapper&lt;T&gt;
where
    T: DispatchFromDyn&lt;U&gt;,
{}</pre></div> <p>Example of illegal <code>DispatchFromDyn</code> implementation (illegal because of extra field)</p> <pre>#![feature(dispatch_from_dyn)]
use std::ops::DispatchFromDyn;

struct WrapperExtraField&lt;T&gt; {
    ptr: T,
    extra_stuff: i32,
}

impl&lt;T, U&gt; DispatchFromDyn&lt;WrapperExtraField&lt;U&gt;&gt; for WrapperExtraField&lt;T&gt;
where
    T: DispatchFromDyn&lt;U&gt;,
{}
</pre>  <h3 id="E0379" class="section-header">E0379</h3> <p>Trait methods cannot be declared <code>const</code> by design. For more information, see <a href="https://github.com/rust-lang/rfcs/pull/911" target="_blank">RFC 911</a>.</p>  <h3 id="E0380" class="section-header">E0380</h3> <p>Auto traits cannot have methods or associated items. For more information see the <a href="https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md" target="_blank">opt-in builtin traits RFC</a>.</p>  <h3 id="E0381" class="section-header">E0381</h3> <p>It is not allowed to use or capture an uninitialized variable. For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    let x: i32;
    let y = x; // error, use of possibly uninitialized variable
}</pre></div> <p>To fix this, ensure that any declared variables are initialized before being used. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let x: i32 = 0;
    let y = x; // ok!
}</pre></div>  <h3 id="E0382" class="section-header">E0382</h3> <p>This error occurs when an attempt is made to use a variable after its contents have been moved elsewhere. For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct MyStruct { s: u32 }

fn main() {
    let mut x = MyStruct{ s: 5u32 };
    let y = x;
    x.s = 6;
    println!("{}", x.s);
}</pre></div> <p>Since <code>MyStruct</code> is a type that is not marked <code>Copy</code>, the data gets moved out of <code>x</code> when we set <code>y</code>. This is fundamental to Rust's ownership system: outside of workarounds like <code>Rc</code>, a value cannot be owned by more than one variable.</p> <p>Sometimes we don't need to move the value. Using a reference, we can let another function borrow the value without changing its ownership. In the example below, we don't actually have to move our string to <code>calculate_length</code>, we can give it a reference to it with <code>&amp;</code> instead.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</pre></div> <p>A mutable reference can be created with <code>&amp;mut</code>.</p> <p>Sometimes we don't want a reference, but a duplicate. All types marked <code>Clone</code> can be duplicated by calling <code>.clone()</code>. Subsequent changes to a clone do not affect the original variable.</p> <p>Most types in the standard library are marked <code>Clone</code>. The example below demonstrates using <code>clone()</code> on a string. <code>s1</code> is first set to "many", and then copied to <code>s2</code>. Then the first character of <code>s1</code> is removed, without affecting <code>s2</code>. "any many" is printed to the console.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let mut s1 = String::from("many");
    let s2 = s1.clone();
    s1.remove(0);
    println!("{} {}", s1, s2);
}</pre></div> <p>If we control the definition of a type, we can implement <code>Clone</code> on it ourselves with <code>#[derive(Clone)]</code>.</p> <p>Some types have no ownership semantics at all and are trivial to duplicate. An example is <code>i32</code> and the other number types. We don't have to call <code>.clone()</code> to clone them, because they are marked <code>Copy</code> in addition to <code>Clone</code>. Implicit cloning is more convenient in this case. We can mark our own types <code>Copy</code> if all their members also are marked <code>Copy</code>.</p> <p>In the example below, we implement a <code>Point</code> type. Because it only stores two integers, we opt-out of ownership semantics with <code>Copy</code>. Then we can <code>let p2 = p1</code> without <code>p1</code> being moved.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[derive(Copy, Clone)]
struct Point { x: i32, y: i32 }

fn main() {
    let mut p1 = Point{ x: -1, y: 2 };
    let p2 = p1;
    p1.x = 1;
    println!("p1: {}, {}", p1.x, p1.y);
    println!("p2: {}, {}", p2.x, p2.y);
}</pre></div> <p>Alternatively, if we don't control the struct's definition, or mutable shared ownership is truly required, we can use <code>Rc</code> and <code>RefCell</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::RefCell;
use std::rc::Rc;

struct MyStruct { s: u32 }

fn main() {
    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));
    let y = x.clone();
    x.borrow_mut().s = 6;
    println!("{}", x.borrow().s);
}</pre></div> <p>With this approach, x and y share ownership of the data via the <code>Rc</code> (reference count type). <code>RefCell</code> essentially performs runtime borrow checking: ensuring that at most one writer or multiple readers can access the data at any one time.</p> <p>If you wish to learn more about ownership in Rust, start with the chapter in the Book:</p> <p>https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html</p>  <h3 id="E0383" class="section-header">E0383</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-20" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>This error occurs when an attempt is made to partially reinitialize a structure that is currently uninitialized.</p> <p>For example, this can happen when a drop has taken place:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    a: u32,
}
impl Drop for Foo {
    fn drop(&amp;mut self) { /* ... */ }
}

let mut x = Foo { a: 1 };
drop(x); // `x` is now uninitialized
x.a = 2; // error, partial reinitialization of uninitialized structure `t`</pre></div> <p>This error can be fixed by fully reinitializing the structure in question:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    a: u32,
}
impl Drop for Foo {
    fn drop(&amp;mut self) { /* ... */ }
}

let mut x = Foo { a: 1 };
drop(x);
x = Foo { a: 2 };</pre></div>  <h3 id="E0384" class="section-header">E0384</h3> <p>This error occurs when an attempt is made to reassign an immutable variable. For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    let x = 3;
    x = 5; // error, reassignment of immutable variable
}</pre></div> <p>By default, variables in Rust are immutable. To fix this error, add the keyword <code>mut</code> after the keyword <code>let</code> when declaring the variable. For example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let mut x = 3;
    x = 5;
}</pre></div>  <h3 id="E0387" class="section-header">E0387</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-21" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>This error occurs when an attempt is made to mutate or mutably reference data that a closure has captured immutably. Examples of this error are shown below:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// Accepts a function or a closure that captures its environment immutably.
// Closures passed to foo will not be able to mutate their closed-over state.
fn foo&lt;F: Fn()&gt;(f: F) { }

// Attempts to mutate closed-over data. Error message reads:
// `cannot assign to data in a captured outer variable...`
fn mutable() {
    let mut x = 0u32;
    foo(|| x = 2);
}

// Attempts to take a mutable reference to closed-over data.  Error message
// reads: `cannot borrow data mutably in a captured outer variable...`
fn mut_addr() {
    let mut x = 0u32;
    foo(|| { let y = &amp;mut x; });
}</pre></div> <p>The problem here is that foo is defined as accepting a parameter of type <code>Fn</code>. Closures passed into foo will thus be inferred to be of type <code>Fn</code>, meaning that they capture their context immutably.</p> <p>If the definition of <code>foo</code> is under your control, the simplest solution is to capture the data mutably. This can be done by defining <code>foo</code> to take FnMut rather than Fn:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;F: FnMut()&gt;(f: F) { }</pre></div> <p>Alternatively, we can consider using the <code>Cell</code> and <code>RefCell</code> types to achieve interior mutability through a shared reference. Our example's <code>mutable</code> function could be redefined as below:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::Cell;

fn foo&lt;F: Fn()&gt;(f: F) { }

fn mutable() {
    let x = Cell::new(0u32);
    foo(|| x.set(2));
}</pre></div> <p>You can read more about cell types in the API documentation:</p> <p>https://doc.rust-lang.org/std/cell/</p>  <h3 id="E0388" class="section-header">E0388</h3> <p>E0388 was removed and is no longer issued.</p>  <h3 id="E0389" class="section-header">E0389</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-22" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>An attempt was made to mutate data using a non-mutable reference. This commonly occurs when attempting to assign to a non-mutable reference of a mutable reference (<code>&amp;(&amp;mut T)</code>).</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy = FancyNum{ num: 5 };
    let fancy_ref = &amp;(&amp;mut fancy);
    fancy_ref.num = 6; // error: cannot assign to data in a `&amp;` reference
    println!("{}", fancy_ref.num);
}</pre></div> <p>Here, <code>&amp;mut fancy</code> is mutable, but <code>&amp;(&amp;mut fancy)</code> is not. Creating an immutable reference to a value borrows it immutably. There can be multiple references of type <code>&amp;(&amp;mut T)</code> that point to the same value, so they must be immutable to prevent multiple mutable references to the same value.</p> <p>To fix this, either remove the outer reference:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy = FancyNum{ num: 5 };

    let fancy_ref = &amp;mut fancy;
    // `fancy_ref` is now &amp;mut FancyNum, rather than &amp;(&amp;mut FancyNum)

    fancy_ref.num = 6; // No error!

    println!("{}", fancy_ref.num);
}</pre></div> <p>Or make the outer reference mutable:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8
}

fn main() {
    let mut fancy = FancyNum{ num: 5 };

    let fancy_ref = &amp;mut (&amp;mut fancy);
    // `fancy_ref` is now &amp;mut(&amp;mut FancyNum), rather than &amp;(&amp;mut FancyNum)

    fancy_ref.num = 6; // No error!

    println!("{}", fancy_ref.num);
}</pre></div>  <h3 id="E0390" class="section-header">E0390</h3> <p>You tried to implement methods for a primitive type. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    x: i32
}

impl *mut Foo {}
// error: only a single inherent implementation marked with
//        `#[lang = "mut_ptr"]` is allowed for the `*mut T` primitive</pre></div> <p>This isn't allowed, but using a trait to implement a method is a good solution. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    x: i32
}

trait Bar {
    fn bar();
}

impl Bar for *mut Foo {
    fn bar() {} // ok!
}</pre></div>  <h3 id="E0391" class="section-header">E0391</h3> <p>This error indicates that some types or traits depend on each other and therefore cannot be constructed.</p> <p>The following example contains a circular dependency between two traits:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait FirstTrait : SecondTrait {

}

trait SecondTrait : FirstTrait {

}</pre></div>  <h3 id="E0392" class="section-header">E0392</h3> <p>This error indicates that a type or lifetime parameter has been declared but not actually used. Here is an example that demonstrates the error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Foo&lt;T&gt; {
    Bar,
}</pre></div> <p>If the type parameter was included by mistake, this error can be fixed by simply removing the type parameter, as shown below:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Foo {
    Bar,
}</pre></div> <p>Alternatively, if the type parameter was intentionally inserted, it must be used. A simple fix is shown below:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Foo&lt;T&gt; {
    Bar(T),
}</pre></div> <p>This error may also commonly be found when working with unsafe code. For example, when using raw pointers one may wish to specify the lifetime for which the pointed-at data is valid. An initial attempt (below) causes this error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;'a, T&gt; {
    x: *const T,
}</pre></div> <p>We want to express the constraint that Foo should not outlive <code>'a</code>, because the data pointed to by <code>T</code> is only valid for that lifetime. The problem is that there are no actual uses of <code>'a</code>. It's possible to work around this by adding a PhantomData type to the struct, using it to tell the compiler to act as if the struct contained a borrowed reference <code>&amp;'a T</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::marker::PhantomData;

struct Foo&lt;'a, T: 'a&gt; {
    x: *const T,
    phantom: PhantomData&lt;&amp;'a T&gt;
}</pre></div> <p><a href="../std/marker/struct.phantomdata/">PhantomData</a> can also be used to express information about unused type parameters.</p>  <h3 id="E0393" class="section-header">E0393</h3> <p>A type parameter which references <code>Self</code> in its default value was not specified. Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait A&lt;T=Self&gt; {}

fn together_we_will_rule_the_galaxy(son: &amp;A) {}
// error: the type parameter `T` must be explicitly specified in an
//        object type because its default value `Self` references the
//        type `Self`</pre></div> <p>A trait object is defined over a single, fully-defined trait. With a regular default parameter, this parameter can just be substituted in. However, if the default parameter is <code>Self</code>, the trait changes for each concrete type; i.e. <code>i32</code> will be expected to implement <code>A&lt;i32&gt;</code>, <code>bool</code> will be expected to implement <code>A&lt;bool&gt;</code>, etc... These types will not share an implementation of a fully-defined trait; instead they share implementations of a trait with different parameters substituted in for each implementation. This is irreconcilable with what we need to make a trait object work, and is thus disallowed. Making the trait concrete by explicitly specifying the value of the defaulted parameter will fix this issue. Fixed example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait A&lt;T=Self&gt; {}

fn together_we_will_rule_the_galaxy(son: &amp;A&lt;i32&gt;) {} // Ok!</pre></div>  <h3 id="E0398" class="section-header">E0398</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-23" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>In Rust 1.3, the default object lifetime bounds are expected to change, as described in <a href="https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md" target="_blank">RFC 1156</a>. You are getting a warning because the compiler thinks it is possible that this change will cause a compilation error in your code. It is possible, though unlikely, that this is a false alarm.</p> <p>The heart of the change is that where <code>&amp;'a Box&lt;SomeTrait&gt;</code> used to default to <code>&amp;'a Box&lt;SomeTrait+'a&gt;</code>, it now defaults to <code>&amp;'a Box&lt;SomeTrait+'static&gt;</code> (here, <code>SomeTrait</code> is the name of some trait type). Note that the only types which are affected are references to boxes, like <code>&amp;Box&lt;SomeTrait&gt;</code> or <code>&amp;[Box&lt;SomeTrait&gt;]</code>. More common types like <code>&amp;SomeTrait</code> or <code>Box&lt;SomeTrait&gt;</code> are unaffected.</p> <p>To silence this warning, edit your code to use an explicit bound. Most of the time, this means that you will want to change the signature of a function that you are calling. For example, if the error is reported on a call like <code>foo(x)</code>, and <code>foo</code> is defined as follows:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo(arg: &amp;Box&lt;SomeTrait&gt;) { /* ... */ }</pre></div> <p>You might change it to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;'a&gt;(arg: &amp;'a Box&lt;SomeTrait+'a&gt;) { /* ... */ }</pre></div> <p>This explicitly states that you expect the trait object <code>SomeTrait</code> to contain references (with a maximum lifetime of <code>'a</code>).</p>  <h3 id="E0399" class="section-header">E0399</h3> <p>You implemented a trait, overriding one or more of its associated types but did not reimplement its default methods.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(associated_type_defaults)]

pub trait Foo {
    type Assoc = u8;
    fn bar(&amp;self) {}
}

impl Foo for i32 {
    // error - the following trait items need to be reimplemented as
    //         `Assoc` was overridden: `bar`
    type Assoc = i32;
}</pre></div> <p>To fix this, add an implementation for each default method from the trait:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(associated_type_defaults)]

pub trait Foo {
    type Assoc = u8;
    fn bar(&amp;self) {}
}

impl Foo for i32 {
    type Assoc = i32;
    fn bar(&amp;self) {} // ok!
}</pre></div>  <h3 id="E0401" class="section-header">E0401</h3> <p>Inner items do not inherit type or const parameters from the functions they are embedded in.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    fn bar(y: T) { // T is defined in the "outer" function
        // ..
    }
    bar(x);
}</pre></div> <p>Nor will this:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    type MaybeT = Option&lt;T&gt;;
    // ...
}</pre></div> <p>Or this:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    struct Foo {
        x: T,
    }
    // ...
}</pre></div> <p>Items inside functions are basically just like top-level items, except that they can only be used from the function they are in.</p> <p>There are a couple of solutions for this.</p> <p>If the item is a function, you may use a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    let bar = |y: T| { // explicit type annotation may not be necessary
        // ..
    };
    bar(x);
}</pre></div> <p>For a generic item, you can copy over the parameters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    fn bar&lt;T&gt;(y: T) {
        // ..
    }
    bar(x);
}</pre></div> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    type MaybeT&lt;T&gt; = Option&lt;T&gt;;
}</pre></div> <p>Be sure to copy over any bounds as well:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T: Copy&gt;(x: T) {
    fn bar&lt;T: Copy&gt;(y: T) {
        // ..
    }
    bar(x);
}</pre></div> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T: Copy&gt;(x: T) {
    struct Foo&lt;T: Copy&gt; {
        x: T,
    }
}</pre></div> <p>This may require additional type hints in the function body.</p> <p>In case the item is a function inside an <code>impl</code>, defining a private helper function might be easier:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
impl&lt;T&gt; Foo&lt;T&gt; {
    pub fn foo(&amp;self, x: T) {
        self.bar(x);
    }

    fn bar(&amp;self, y: T) {
        // ..
    }
}</pre></div> <p>For default impls in traits, the private helper solution won't work, however closures or copying the parameters should still work.</p>  <h3 id="E0403" class="section-header">E0403</h3> <p>Some type parameters have the same name.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;T, T&gt;(s: T, u: T) {} // error: the name `T` is already used for a type
                            //        parameter in this type parameter list</pre></div> <p>Please verify that none of the type parameters are misspelled, and rename any clashing parameters. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T, Y&gt;(s: T, u: Y) {} // ok!</pre></div>  <h3 id="E0404" class="section-header">E0404</h3> <p>You tried to use something which is not a trait in a trait position, such as a bound or <code>impl</code>.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;
struct Bar;

impl Foo for Bar {} // error: `Foo` is not a trait</pre></div> <p>Another erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

fn bar&lt;T: Foo&gt;(t: T) {} // error: `Foo` is not a trait</pre></div> <p>Please verify that you didn't misspell the trait's name or otherwise use the wrong identifier. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    // some functions
}
struct Bar;

impl Foo for Bar { // ok!
    // functions implementation
}</pre></div> <p>or</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    // some functions
}

fn bar&lt;T: Foo&gt;(t: T) {} // ok!</pre></div>  <h3 id="E0405" class="section-header">E0405</h3> <p>The code refers to a trait that is not in scope.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

impl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope</pre></div> <p>Please verify that the name of the trait wasn't misspelled and ensure that it was imported. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// solution 1:
use some_file::SomeTrait;

// solution 2:
trait SomeTrait {
    // some functions
}

struct Foo;

impl SomeTrait for Foo { // ok!
    // implements functions
}</pre></div>  <h3 id="E0407" class="section-header">E0407</h3> <p>A definition of a method not in the implemented trait was given in a trait implementation.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn a();
}

struct Bar;

impl Foo for Bar {
    fn a() {}
    fn b() {} // error: method `b` is not a member of trait `Foo`
}</pre></div> <p>Please verify you didn't misspell the method name and you used the correct trait. First example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn a();
    fn b();
}

struct Bar;

impl Foo for Bar {
    fn a() {}
    fn b() {} // ok!
}</pre></div> <p>Second example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn a();
}

struct Bar;

impl Foo for Bar {
    fn a() {}
}

impl Bar {
    fn b() {}
}</pre></div>  <h3 id="E0408" class="section-header">E0408</h3> <p>An "or" pattern was used where the variable bindings are not consistently bound across patterns.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
match x {
    Some(y) | None =&gt; { /* use y */ } // error: variable `y` from pattern #1 is
                                      //        not bound in pattern #2
    _ =&gt; ()
}</pre></div> <p>Here, <code>y</code> is bound to the contents of the <code>Some</code> and can be used within the block corresponding to the match arm. However, in case <code>x</code> is <code>None</code>, we have not specified what <code>y</code> is, and the block will use a nonexistent variable.</p> <p>To fix this error, either split into multiple match arms:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = Some(1);
match x {
    Some(y) =&gt; { /* use y */ }
    None =&gt; { /* ... */ }
}</pre></div> <p>or, bind the variable to a field of the same type in all sub-patterns of the or pattern:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = (0, 2);
match x {
    (0, y) | (y, 0) =&gt; { /* use y */}
    _ =&gt; {}
}</pre></div> <p>In this example, if <code>x</code> matches the pattern <code>(0, _)</code>, the second field is set to <code>y</code>. If it matches <code>(_, 0)</code>, the first field is set to <code>y</code>; so in all cases <code>y</code> is set to some value.</p>  <h3 id="E0409" class="section-header">E0409</h3> <p>An "or" pattern was used where the variable bindings are not consistently bound across patterns.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = (0, 2);
match x {
    (0, ref y) | (y, 0) =&gt; { /* use y */} // error: variable `y` is bound with
                                          //        different mode in pattern #2
                                          //        than in pattern #1
    _ =&gt; ()
}</pre></div> <p>Here, <code>y</code> is bound by-value in one case and by-reference in the other.</p> <p>To fix this error, just use the same mode in both cases. Generally using <code>ref</code> or <code>ref mut</code> where not already used will fix this:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = (0, 2);
match x {
    (0, ref y) | (ref y, 0) =&gt; { /* use y */}
    _ =&gt; ()
}</pre></div> <p>Alternatively, split the pattern:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = (0, 2);
match x {
    (y, 0) =&gt; { /* use y */ }
    (0, ref y) =&gt; { /* use y */}
    _ =&gt; ()
}</pre></div>  <h3 id="E0411" class="section-header">E0411</h3> <p>The <code>Self</code> keyword was used outside an impl, trait, or type definition.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
&lt;Self&gt;::foo; // error: use of `Self` outside of an impl, trait, or type
             // definition</pre></div> <p>The <code>Self</code> keyword represents the current type, which explains why it can only be used inside an impl, trait, or type definition. It gives access to the associated items of a type:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    type Bar;
}

trait Baz : Foo {
    fn bar() -&gt; Self::Bar; // like this
}</pre></div> <p>However, be careful when two types have a common associated type:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    type Bar;
}

trait Foo2 {
    type Bar;
}

trait Baz : Foo + Foo2 {
    fn bar() -&gt; Self::Bar;
    // error: ambiguous associated type `Bar` in bounds of `Self`
}</pre></div> <p>This problem can be solved by specifying from which trait we want to use the <code>Bar</code> type:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    type Bar;
}

trait Foo2 {
    type Bar;
}

trait Baz : Foo + Foo2 {
    fn bar() -&gt; &lt;Self as Foo&gt;::Bar; // ok!
}</pre></div>  <h3 id="E0412" class="section-header">E0412</h3> <p>The type name used is not in scope.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
impl Something {} // error: type name `Something` is not in scope

// or:

trait Foo {
    fn bar(N); // error: type name `N` is not in scope
}

// or:

fn foo(x: T) {} // type name `T` is not in scope</pre></div> <p>To fix this error, please verify you didn't misspell the type name, you did declare it or imported it into the scope. Examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Something;

impl Something {} // ok!

// or:

trait Foo {
    type N;

    fn bar(_: Self::N); // ok!
}

// or:

fn foo&lt;T&gt;(x: T) {} // ok!</pre></div> <p>Another case that causes this error is when a type is imported into a parent module. To fix this, you can follow the suggestion and use File directly or <code>use super::File;</code> which will import the types from the parent namespace. An example that causes this error is below:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::fs::File;

mod foo {
    fn some_function(f: File) {}
}</pre></div> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::fs::File;

mod foo {
    // either
    use super::File;
    // or
    // use std::fs::File;
    fn foo(f: File) {}
}</pre></div>  <h3 id="E0415" class="section-header">E0415</h3> <p>More than one function parameter have the same name.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than
                          //        once in this parameter list</pre></div> <p>Please verify you didn't misspell parameters' name. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo(f: i32, g: i32) {} // ok!</pre></div>  <h3 id="E0416" class="section-header">E0416</h3> <p>An identifier is bound more than once in a pattern.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
match (1, 2) {
    (x, x) =&gt; {} // error: identifier `x` is bound more than once in the
                 //        same pattern
}</pre></div> <p>Please verify you didn't misspell identifiers' name. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
match (1, 2) {
    (x, y) =&gt; {} // ok!
}</pre></div> <p>Or maybe did you mean to unify? Consider using a guard:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
match (A, B, C) {
    (x, x2, see) if x == x2 =&gt; { /* A and B are equal, do one thing */ }
    (y, z, see) =&gt; { /* A and B unequal; do another thing */ }
}</pre></div>  <h3 id="E0422" class="section-header">E0422</h3> <p>You are trying to use an identifier that is either undefined or not a struct. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main () {
    let x = Foo { x: 1, y: 2 };
}</pre></div> <p>In this case, <code>Foo</code> is undefined, so it inherently isn't anything, and definitely not a struct.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main () {
    let foo = 1;
    let x = foo { x: 1, y: 2 };
}</pre></div> <p>In this case, <code>foo</code> is defined, but is not a struct, so Rust can't use it as one.</p>  <h3 id="E0423" class="section-header">E0423</h3> <p>An identifier was used like a function name or a value was expected and the identifier exists but it belongs to a different namespace.</p> <p>For (an erroneous) example, here a <code>struct</code> variant name were used as a function:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo { a: bool };

let f = Foo();
// error: expected function, found `Foo`
// `Foo` is a struct name, but this expression uses it like a function name</pre></div> <p>Please verify you didn't misspell the name of what you actually wanted to use here. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn Foo() -&gt; u32 { 0 }

let f = Foo(); // ok!</pre></div> <p>It is common to forget the trailing <code>!</code> on macro invocations, which would also yield this error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
println("");
// error: expected function, found macro `println`
// did you mean `println!(...)`? (notice the trailing `!`)</pre></div> <p>Another case where this error is emitted is when a value is expected, but something else is found:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
pub mod a {
    pub const I: i32 = 1;
}

fn h1() -&gt; i32 {
    a.I
    //~^ ERROR expected value, found module `a`
    // did you mean `a::I`?
}</pre></div>  <h3 id="E0424" class="section-header">E0424</h3> <p>The <code>self</code> keyword was used in a static method.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

impl Foo {
    fn bar(self) {}

    fn foo() {
        self.bar(); // error: `self` is not available in a static method.
    }
}</pre></div> <p>Please check if the method's argument list should have contained <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> (in case you didn't want to create a static method), and add it if so. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo;

impl Foo {
    fn bar(self) {}

    fn foo(self) {
        self.bar(); // ok!
    }
}</pre></div>  <h3 id="E0425" class="section-header">E0425</h3> <p>An unresolved name was used.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
something_that_doesnt_exist::foo;
// error: unresolved name `something_that_doesnt_exist::foo`

// or:

trait Foo {
    fn bar() {
        Self; // error: unresolved name `Self`
    }
}

// or:

let x = unknown_variable;  // error: unresolved name `unknown_variable`</pre></div> <p>Please verify that the name wasn't misspelled and ensure that the identifier being referred to is valid for the given situation. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum something_that_does_exist {
    Foo,
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod something_that_does_exist {
    pub static foo : i32 = 0i32;
}

something_that_does_exist::foo; // ok!</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let unknown_variable = 12u32;
let x = unknown_variable; // ok!</pre></div> <p>If the item is not defined in the current module, it must be imported using a <code>use</code> statement, like so:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use foo::bar;
bar();</pre></div> <p>If the item you are importing is not defined in some super-module of the current module, then it must also be declared as public (e.g., <code>pub fn</code>).</p>  <h3 id="E0426" class="section-header">E0426</h3> <p>An undeclared label was used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
loop {
    break 'a; // error: use of undeclared label `'a`
}</pre></div> <p>Please verify you spelt or declare the label correctly. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
'a: loop {
    break 'a; // ok!
}</pre></div>  <h3 id="E0428" class="section-header">E0428</h3> <p>A type or module has been defined more than once.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Bar;
struct Bar; // error: duplicate definition of value `Bar`</pre></div> <p>Please verify you didn't misspell the type/module's name or remove/rename the duplicated one. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Bar;
struct Bar2; // ok!</pre></div>  <h3 id="E0429" class="section-header">E0429</h3> <p>The <code>self</code> keyword cannot appear alone as the last segment in a <code>use</code> declaration.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::fmt::self; // error: `self` imports are only allowed within a { } list</pre></div> <p>To use a namespace itself in addition to some of its members, <code>self</code> may appear as part of a brace-enclosed list of imports:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::fmt::{self, Debug};</pre></div> <p>If you only want to import the namespace, do so directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::fmt;</pre></div>  <h3 id="E0430" class="section-header">E0430</h3> <p>The <code>self</code> import appears more than once in the list.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use something::{self, self}; // error: `self` import can only appear once in
                             //        the list</pre></div> <p>Please verify you didn't misspell the import name or remove the duplicated <code>self</code> import. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use something::{self}; // ok!</pre></div>  <h3 id="E0431" class="section-header">E0431</h3> <p>An invalid <code>self</code> import was made.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use {self}; // error: `self` import can only appear in an import list with a
            //        non-empty prefix</pre></div> <p>You cannot import the current module into itself, please remove this import or verify you didn't misspell it.</p>  <h3 id="E0432" class="section-header">E0432</h3> <p>An import was unresolved.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use something::Foo; // error: unresolved import `something::Foo`.</pre></div> <p>Paths in <code>use</code> statements are relative to the crate root. To import items relative to the current and parent modules, use the <code>self::</code> and <code>super::</code> prefixes, respectively. Also verify that you didn't misspell the import name and that the import exists in the module from where you tried to import it. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use self::something::Foo; // ok!

mod something {
    pub struct Foo;
}</pre></div> <p>Or, if you tried to use a module from an external crate, you may have missed the <code>extern crate</code> declaration (which is usually placed in the crate root):</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
extern crate core; // Required to use the `core` crate

use core::any;</pre></div>  <h3 id="E0433" class="section-header">E0433</h3> <p>An undeclared type or module was used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let map = HashMap::new();
// error: failed to resolve: use of undeclared type or module `HashMap`</pre></div> <p>Please verify you didn't misspell the type/module's name or that you didn't forget to import it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::HashMap; // HashMap has been imported.
let map: HashMap&lt;u32, u32&gt; = HashMap::new(); // So it can be used!</pre></div>  <h3 id="E0434" class="section-header">E0434</h3> <p>This error indicates that a variable usage inside an inner function is invalid because the variable comes from a dynamic environment. Inner functions do not have access to their containing environment.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo() {
    let y = 5;
    fn bar() -&gt; u32 {
        y // error: can't capture dynamic environment in a fn item; use the
          //        || { ... } closure form instead.
    }
}</pre></div> <p>Functions do not capture local variables. To fix this error, you can replace the function with a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo() {
    let y = 5;
    let bar = || {
        y
    };
}</pre></div> <p>or replace the captured variable with a constant or a static item:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo() {
    static mut X: u32 = 4;
    const Y: u32 = 5;
    fn bar() -&gt; u32 {
        unsafe {
            X = 3;
        }
        Y
    }
}</pre></div>  <h3 id="E0435" class="section-header">E0435</h3> <p>A non-constant value was used in a constant expression.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let foo = 42;
let a: [u8; foo]; // error: attempt to use a non-constant value in a constant</pre></div> <p>To fix this error, please replace the value with a constant. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let a: [u8; 42]; // ok!</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
const FOO: usize = 42;
let a: [u8; FOO]; // ok!</pre></div>  <h3 id="E0436" class="section-header">E0436</h3> <p>The functional record update syntax is only allowed for structs. (Struct-like enum variants don't qualify, for example.)</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum PublicationFrequency {
    Weekly,
    SemiMonthly { days: (u8, u8), annual_special: bool },
}

fn one_up_competitor(competitor_frequency: PublicationFrequency)
                     -&gt; PublicationFrequency {
    match competitor_frequency {
        PublicationFrequency::Weekly =&gt; PublicationFrequency::SemiMonthly {
            days: (1, 15), annual_special: false
        },
        c @ PublicationFrequency::SemiMonthly{ .. } =&gt;
            PublicationFrequency::SemiMonthly {
                annual_special: true, ..c // error: functional record update
                                          //        syntax requires a struct
        }
    }
}</pre></div> <p>Rewrite the expression without functional record update syntax:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum PublicationFrequency {
    Weekly,
    SemiMonthly { days: (u8, u8), annual_special: bool },
}

fn one_up_competitor(competitor_frequency: PublicationFrequency)
                     -&gt; PublicationFrequency {
    match competitor_frequency {
        PublicationFrequency::Weekly =&gt; PublicationFrequency::SemiMonthly {
            days: (1, 15), annual_special: false
        },
        PublicationFrequency::SemiMonthly{ days, .. } =&gt;
            PublicationFrequency::SemiMonthly {
                days, annual_special: true // ok!
        }
    }
}</pre></div>  <h3 id="E0437" class="section-header">E0437</h3> <p>Trait implementations can only implement associated types that are members of the trait in question. This error indicates that you attempted to implement an associated type whose name does not match the name of any associated type in the trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {}

impl Foo for i32 {
    type Bar = bool;
}</pre></div> <p>The solution to this problem is to remove the extraneous associated type:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {}

impl Foo for i32 {}</pre></div>  <h3 id="E0438" class="section-header">E0438</h3> <p>Trait implementations can only implement associated constants that are members of the trait in question. This error indicates that you attempted to implement an associated constant whose name does not match the name of any associated constant in the trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {}

impl Foo for i32 {
    const BAR: bool = true;
}</pre></div> <p>The solution to this problem is to remove the extraneous associated constant:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {}

impl Foo for i32 {}</pre></div>  <h3 id="E0439" class="section-header">E0439</h3> <p>The length of the platform-intrinsic function <code>simd_shuffle</code> wasn't specified. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(platform_intrinsics)]

extern "platform-intrinsic" {
    fn simd_shuffle&lt;A,B&gt;(a: A, b: A, c: [u32; 8]) -&gt; B;
    // error: invalid `simd_shuffle`, needs length: `simd_shuffle`
}</pre></div> <p>The <code>simd_shuffle</code> function needs the length of the array passed as last parameter in its name. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(platform_intrinsics)]

extern "platform-intrinsic" {
    fn simd_shuffle8&lt;A,B&gt;(a: A, b: A, c: [u32; 8]) -&gt; B;
}</pre></div>  <h3 id="E0445" class="section-header">E0445</h3> <p>A private trait was used on a public type parameter bound. Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![deny(private_in_public)]

trait Foo {
    fn dummy(&amp;self) { }
}

pub trait Bar : Foo {} // error: private trait in public interface
pub struct Bar2&lt;T: Foo&gt;(pub T); // same error
pub fn foo&lt;T: Foo&gt; (t: T) {} // same error</pre></div> <p>To solve this error, please ensure that the trait is also public. The trait can be made inaccessible if necessary by placing it into a private inner module, but it still has to be marked with <code>pub</code>. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
pub trait Foo { // we set the Foo trait public
    fn dummy(&amp;self) { }
}

pub trait Bar : Foo {} // ok!
pub struct Bar2&lt;T: Foo&gt;(pub T); // ok!
pub fn foo&lt;T: Foo&gt; (t: T) {} // ok!</pre></div>  <h3 id="E0446" class="section-header">E0446</h3> <p>A private type was used in a public type signature. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![deny(private_in_public)]

mod Foo {
    struct Bar(u32);

    pub fn bar() -&gt; Bar { // error: private type in public interface
        Bar(0)
    }
}</pre></div> <p>To solve this error, please ensure that the type is also public. The type can be made inaccessible if necessary by placing it into a private inner module, but it still has to be marked with <code>pub</code>. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod Foo {
    pub struct Bar(u32); // we set the Bar type public

    pub fn bar() -&gt; Bar { // ok!
        Bar(0)
    }
}</pre></div>  <h3 id="E0447" class="section-header">E0447</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-24" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>The <code>pub</code> keyword was used inside a function. Erroneous code example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo() {
    pub struct Bar; // error: visibility has no effect inside functions
}</pre></div> <p>Since we cannot access items defined inside a function, the visibility of its items does not impact outer code. So using the <code>pub</code> keyword in this context is invalid.</p>  <h3 id="E0448" class="section-header">E0448</h3> <p>The <code>pub</code> keyword was used inside a public enum. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
pub enum Foo {
    pub Bar, // error: unnecessary `pub` visibility
}</pre></div> <p>Since the enum is already public, adding <code>pub</code> on one its elements is unnecessary. Example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Foo {
    pub Bar, // not ok!
}</pre></div> <p>This is the correct syntax:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
pub enum Foo {
    Bar, // ok!
}</pre></div>  <h3 id="E0449" class="section-header">E0449</h3> <p>A visibility qualifier was used when it was unnecessary. Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Bar;

trait Foo {
    fn foo();
}

pub impl Bar {} // error: unnecessary visibility qualifier

pub impl Foo for Bar { // error: unnecessary visibility qualifier
    pub fn foo() {} // error: unnecessary visibility qualifier
}</pre></div> <p>To fix this error, please remove the visibility qualifier when it is not required. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Bar;

trait Foo {
    fn foo();
}

// Directly implemented methods share the visibility of the type itself,
// so `pub` is unnecessary here
impl Bar {}

// Trait methods share the visibility of the trait, so `pub` is
// unnecessary in either case
impl Foo for Bar {
    fn foo() {}
}</pre></div>  <h3 id="E0451" class="section-header">E0451</h3> <p>A struct constructor with private fields was invoked. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod Bar {
    pub struct Foo {
        pub a: isize,
        b: isize,
    }
}

let f = Bar::Foo{ a: 0, b: 0 }; // error: field `b` of struct `Bar::Foo`
                                //        is private</pre></div> <p>To fix this error, please ensure that all the fields of the struct are public, or implement a function for easy instantiation. Examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod Bar {
    pub struct Foo {
        pub a: isize,
        pub b: isize, // we set `b` field public
    }
}

let f = Bar::Foo{ a: 0, b: 0 }; // ok!</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod Bar {
    pub struct Foo {
        pub a: isize,
        b: isize, // still private
    }

    impl Foo {
        pub fn new() -&gt; Foo { // we create a method to instantiate `Foo`
            Foo { a: 0, b: 0 }
        }
    }
}

let f = Bar::Foo::new(); // ok!</pre></div>  <h3 id="E0452" class="section-header">E0452</h3> <p>An invalid lint attribute has been given. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![allow(foo = "")] // error: malformed lint attribute</pre></div> <p>Lint attributes only accept a list of identifiers (where each identifier is a lint name). Ensure the attribute is of this form:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![allow(foo)] // ok!
// or:
#![allow(foo, foo2)] // ok!</pre></div>  <h3 id="E0453" class="section-header">E0453</h3> <p>A lint check attribute was overruled by a <code>forbid</code> directive set as an attribute on an enclosing scope, or on the command line with the <code>-F</code> option.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![forbid(non_snake_case)]

#[allow(non_snake_case)]
fn main() {
    let MyNumber = 2; // error: allow(non_snake_case) overruled by outer
                      //        forbid(non_snake_case)
}</pre></div> <p>The <code>forbid</code> lint setting, like <code>deny</code>, turns the corresponding compiler warning into a hard error. Unlike <code>deny</code>, <code>forbid</code> prevents itself from being overridden by inner attributes.</p> <p>If you're sure you want to override the lint check, you can change <code>forbid</code> to <code>deny</code> (or use <code>-D</code> instead of <code>-F</code> if the <code>forbid</code> setting was given as a command-line option) to allow the inner lint check attribute:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![deny(non_snake_case)]

#[allow(non_snake_case)]
fn main() {
    let MyNumber = 2; // ok!
}</pre></div> <p>Otherwise, edit the code to pass the lint check, and remove the overruled attribute:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![forbid(non_snake_case)]

fn main() {
    let my_number = 2;
}</pre></div>  <h3 id="E0454" class="section-header">E0454</h3> <p>A link name was given with an empty name. Erroneous code example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#[link(name = "")] extern {} // error: #[link(name = "")] given with empty name</pre></div> <p>The rust compiler cannot link to an external library if you don't give it its name. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[link(name = "some_lib")] extern {} // ok!</pre></div>  <h3 id="E0455" class="section-header">E0455</h3> <p>Linking with <code>kind=framework</code> is only supported when targeting macOS, as frameworks are specific to that operating system.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#[link(name = "FooCoreServices", kind = "framework")] extern {}
// OS used to compile is Linux for example</pre></div> <p>To solve this error you can use conditional compilation:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[cfg_attr(target="macos", link(name = "FooCoreServices", kind = "framework"))]
extern {}</pre></div> <p>See more: https://doc.rust-lang.org/reference/attributes.html#conditional-compilation</p>    <h3 id="E0458" class="section-header">E0458</h3> <p>An unknown "kind" was specified for a link attribute. Erroneous code example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#[link(kind = "wonderful_unicorn")] extern {}
// error: unknown kind: `wonderful_unicorn`</pre></div> <p>Please specify a valid "kind" value, from one of the following:</p> <ul> <li>static</li> <li>dylib</li> <li>framework</li> </ul>  <h3 id="E0459" class="section-header">E0459</h3> <p>A link was used without a name parameter. Erroneous code example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#[link(kind = "dylib")] extern {}
// error: #[link(...)] specified without `name = "foo"`</pre></div> <p>Please add the name parameter to allow the rust compiler to find the library you want. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[link(kind = "dylib", name = "some_lib")] extern {} // ok!</pre></div>     <h3 id="E0463" class="section-header">E0463</h3> <p>A plugin/crate was declared but cannot be found. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(plugin)]
#![plugin(cookie_monster)] // error: can't find crate for `cookie_monster`
extern crate cake_is_a_lie; // error: can't find crate for `cake_is_a_lie`</pre></div> <p>You need to link your code to the relevant crate in order to be able to use it (through Cargo or the <code>-L</code> option of rustc example). Plugins are crates as well, and you link to them the same way.</p>    <h3 id="E0466" class="section-header">E0466</h3> <p>Macro import declarations were malformed.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[macro_use(a_macro(another_macro))] // error: invalid import declaration
extern crate core as some_crate;

#[macro_use(i_want = "some_macros")] // error: invalid import declaration
extern crate core as another_crate;</pre></div> <p>This is a syntax error at the level of attribute declarations. The proper syntax for macro imports is the following:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
// In some_crate:
#[macro_export]
macro_rules! get_tacos {
    ...
}

#[macro_export]
macro_rules! get_pimientos {
    ...
}

// In your crate:
#[macro_use(get_tacos, get_pimientos)] // It imports `get_tacos` and
extern crate some_crate;               // `get_pimientos` macros from some_crate</pre></div> <p>If you would like to import all exported macros, write <code>macro_use</code> with no arguments.</p>  <h3 id="E0468" class="section-header">E0468</h3> <p>A non-root module attempts to import macros from another crate.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod foo {
    #[macro_use(debug_assert)]  // error: must be at crate root to import
    extern crate core;          //        macros from another crate
    fn run_macro() { debug_assert!(true); }
}</pre></div> <p>Only <code>extern crate</code> imports at the crate root level are allowed to import macros.</p> <p>Either move the macro import to crate root or do without the foreign macros. This will work:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[macro_use(debug_assert)]
extern crate core;

mod foo {
    fn run_macro() { debug_assert!(true); }
}</pre></div>  <h3 id="E0469" class="section-header">E0469</h3> <p>A macro listed for import was not found.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[macro_use(drink, be_merry)] // error: imported macro not found
extern crate alloc;

fn main() {
    // ...
}</pre></div> <p>Either the listed macro is not contained in the imported crate, or it is not exported from the given crate.</p> <p>This could be caused by a typo. Did you misspell the macro's name?</p> <p>Double-check the names of the macros listed for import, and that the crate in question exports them.</p> <p>A working version would be:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
// In some_crate crate:
#[macro_export]
macro_rules! eat {
    ...
}

#[macro_export]
macro_rules! drink {
    ...
}

// In your crate:
#[macro_use(eat, drink)]
extern crate some_crate; //ok!</pre></div>        <h3 id="E0478" class="section-header">E0478</h3> <p>A lifetime bound was not satisfied.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
// Check that the explicit lifetime bound (`'SnowWhite`, in this example) must
// outlive all the superbounds from the trait (`'kiss`, in this example).

trait Wedding&lt;'t&gt;: 't { }

struct Prince&lt;'kiss, 'SnowWhite&gt; {
    child: Box&lt;Wedding&lt;'kiss&gt; + 'SnowWhite&gt;,
    // error: lifetime bound not satisfied
}</pre></div> <p>In this example, the <code>'SnowWhite</code> lifetime is supposed to outlive the <code>'kiss</code> lifetime but the declaration of the <code>Prince</code> struct doesn't enforce it. To fix this issue, you need to specify it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Wedding&lt;'t&gt;: 't { }

struct Prince&lt;'kiss, 'SnowWhite: 'kiss&gt; { // You say here that 'kiss must live
                                          // longer than 'SnowWhite.
    child: Box&lt;Wedding&lt;'kiss&gt; + 'SnowWhite&gt;, // And now it's all good!
}</pre></div>              <h3 id="E0491" class="section-header">E0491</h3> <p>A reference has a longer lifetime than the data it references.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait SomeTrait&lt;'a&gt; {
    type Output;
}

impl&lt;'a, T&gt; SomeTrait&lt;'a&gt; for T {
    type Output = &amp;'a T; // compile error E0491
}</pre></div> <p>Here, the problem is that a reference type like <code>&amp;'a T</code> is only valid if all the data in T outlives the lifetime <code>'a</code>. But this impl as written is applicable to any lifetime <code>'a</code> and any type <code>T</code> -- we have no guarantee that <code>T</code> outlives <code>'a</code>. To fix this, you can add a where clause like <code>where T: 'a</code>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait SomeTrait&lt;'a&gt; {
    type Output;
}

impl&lt;'a, T&gt; SomeTrait&lt;'a&gt; for T
where
    T: 'a,
{
    type Output = &amp;'a T; // compile error E0491
}</pre></div>  <h3 id="E0492" class="section-header">E0492</h3> <p>A borrow of a constant containing interior mutability was attempted. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::sync::atomic::AtomicUsize;

const A: AtomicUsize = AtomicUsize::new(0);
static B: &amp;'static AtomicUsize = &amp;A;
// error: cannot borrow a constant which may contain interior mutability,
//        create a static instead</pre></div> <p>A <code>const</code> represents a constant value that should never change. If one takes a <code>&amp;</code> reference to the constant, then one is taking a pointer to some memory location containing the value. Normally this is perfectly fine: most values can't be changed via a shared <code>&amp;</code> pointer, but interior mutability would allow it. That is, a constant value could be mutated. On the other hand, a <code>static</code> is explicitly a single memory location, which can be mutated at will.</p> <p>So, in order to solve this error, either use statics which are <code>Sync</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::AtomicUsize;

static A: AtomicUsize = AtomicUsize::new(0);
static B: &amp;'static AtomicUsize = &amp;A; // ok!</pre></div> <p>You can also have this error while using a cell type:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::cell::Cell;

const A: Cell&lt;usize&gt; = Cell::new(1);
const B: &amp;Cell&lt;usize&gt; = &amp;A;
// error: cannot borrow a constant which may contain interior mutability,
//        create a static instead

// or:
struct C { a: Cell&lt;usize&gt; }

const D: C = C { a: Cell::new(1) };
const E: &amp;Cell&lt;usize&gt; = &amp;D.a; // error

// or:
const F: &amp;C = &amp;D; // error</pre></div> <p>This is because cell types do operations that are not thread-safe. Due to this, they don't implement Sync and thus can't be placed in statics.</p> <p>However, if you still wish to use these types, you can achieve this by an unsafe wrapper:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::Cell;
use std::marker::Sync;

struct NotThreadSafe&lt;T&gt; {
    value: Cell&lt;T&gt;,
}

unsafe impl&lt;T&gt; Sync for NotThreadSafe&lt;T&gt; {}

static A: NotThreadSafe&lt;usize&gt; = NotThreadSafe { value : Cell::new(1) };
static B: &amp;'static NotThreadSafe&lt;usize&gt; = &amp;A; // ok!</pre></div> <p>Remember this solution is unsafe! You will have to ensure that accesses to the cell are synchronized.</p>    <h3 id="E0496" class="section-header">E0496</h3> <p>A lifetime name is shadowing another lifetime name. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;'a&gt; {
    a: &amp;'a i32,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn f&lt;'a&gt;(x: &amp;'a i32) { // error: lifetime name `'a` shadows a lifetime
                           //        name that is already in scope
    }
}</pre></div> <p>Please change the name of one of the lifetimes to remove this error. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;'a&gt; {
    a: &amp;'a i32,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn f&lt;'b&gt;(x: &amp;'b i32) { // ok!
    }
}

fn main() {
}</pre></div>  <h3 id="E0497" class="section-header">E0497</h3> <p>A stability attribute was used outside of the standard library. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[stable] // error: stability attributes may not be used outside of the
          //        standard library
fn foo() {}</pre></div> <p>It is not possible to use stability attributes outside of the standard library. Also, for now, it is not possible to write deprecation messages either.</p>   <h3 id="E0499" class="section-header">E0499</h3> <p>A variable was borrowed as mutable more than once. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let mut i = 0;
let mut x = &amp;mut i;
let mut a = &amp;mut i;
x;
// error: cannot borrow `i` as mutable more than once at a time</pre></div> <p>Please note that in rust, you can either have many immutable references, or one mutable reference. Take a look at https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html for more information. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut i = 0;
let mut x = &amp;mut i; // ok!

// or:
let mut i = 0;
let a = &amp;i; // ok!
let b = &amp;i; // still ok!
let c = &amp;i; // still ok!
b;
a;</pre></div>  <h3 id="E0500" class="section-header">E0500</h3> <p>A borrowed variable was used by a closure. Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn you_know_nothing(jon_snow: &amp;mut i32) {
    let nights_watch = &amp;jon_snow;
    let starks = || {
        *jon_snow = 3; // error: closure requires unique access to `jon_snow`
                       //        but it is already borrowed
    };
    println!("{}", nights_watch);
}</pre></div> <p>In here, <code>jon_snow</code> is already borrowed by the <code>nights_watch</code> reference, so it cannot be borrowed by the <code>starks</code> closure at the same time. To fix this issue, you can create the closure after the borrow has ended:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn you_know_nothing(jon_snow: &amp;mut i32) {
    let nights_watch = &amp;jon_snow;
    println!("{}", nights_watch);
    let starks = || {
        *jon_snow = 3;
    };
}</pre></div> <p>Or, if the type implements the <code>Clone</code> trait, you can clone it between closures:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn you_know_nothing(jon_snow: &amp;mut i32) {
    let mut jon_copy = jon_snow.clone();
    let starks = || {
        *jon_snow = 3;
    };
    println!("{}", jon_copy);
}</pre></div>  <h3 id="E0501" class="section-header">E0501</h3> <p>This error indicates that a mutable variable is being used while it is still captured by a closure. Because the closure has borrowed the variable, it is not available for use until the closure goes out of scope.</p> <p>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at http://rustbyexample.com/fn/closures/capture.html for more information about capturing.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn inside_closure(x: &amp;mut i32) {
    // Actions which require unique access
}

fn outside_closure(x: &amp;mut i32) {
    // Actions which require unique access
}

fn foo(a: &amp;mut i32) {
    let mut bar = || {
        inside_closure(a)
    };
    outside_closure(a); // error: cannot borrow `*a` as mutable because previous
                        //        closure requires unique access.
    bar();
}</pre></div> <p>To fix this error, you can finish using the closure before using the captured variable:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn inside_closure(x: &amp;mut i32) {}
fn outside_closure(x: &amp;mut i32) {}

fn foo(a: &amp;mut i32) {
    let mut bar = || {
        inside_closure(a)
    };
    bar();
    // borrow on `a` ends.
    outside_closure(a); // ok!
}</pre></div> <p>Or you can pass the variable as a parameter to the closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn inside_closure(x: &amp;mut i32) {}
fn outside_closure(x: &amp;mut i32) {}

fn foo(a: &amp;mut i32) {
    let mut bar = |s: &amp;mut i32| {
        inside_closure(s)
    };
    outside_closure(a);
    bar(a);
}</pre></div> <p>It may be possible to define the closure later:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn inside_closure(x: &amp;mut i32) {}
fn outside_closure(x: &amp;mut i32) {}

fn foo(a: &amp;mut i32) {
    outside_closure(a);
    let mut bar = || {
        inside_closure(a)
    };
    bar();
}</pre></div>  <h3 id="E0502" class="section-header">E0502</h3> <p>This error indicates that you are trying to borrow a variable as mutable when it has already been borrowed as immutable.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn bar(x: &amp;mut i32) {}
fn foo(a: &amp;mut i32) {
    let ref y = a; // a is borrowed as immutable.
    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed
            //        as immutable
    println!("{}", y);
}</pre></div> <p>To fix this error, ensure that you don't have any other references to the variable before trying to access it mutably:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn bar(x: &amp;mut i32) {}
fn foo(a: &amp;mut i32) {
    bar(a);
    let ref y = a; // ok!
    println!("{}", y);
}</pre></div> <p>For more information on the rust ownership system, take a look at https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html.</p>  <h3 id="E0503" class="section-header">E0503</h3> <p>A value was used after it was mutably borrowed.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    let mut value = 3;
    // Create a mutable borrow of `value`.
    let borrow = &amp;mut value;
    let _sum = value + 1; // error: cannot use `value` because
                          //        it was mutably borrowed
    println!("{}", borrow);
}</pre></div> <p>In this example, <code>value</code> is mutably borrowed by <code>borrow</code> and cannot be used to calculate <code>sum</code>. This is not possible because this would violate Rust's mutability rules.</p> <p>You can fix this error by finishing using the borrow before the next use of the value:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let mut value = 3;
    let borrow = &amp;mut value;
    println!("{}", borrow);
    // The block has ended and with it the borrow.
    // You can now use `value` again.
    let _sum = value + 1;
}</pre></div> <p>Or by cloning <code>value</code> before borrowing it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let mut value = 3;
    // We clone `value`, creating a copy.
    let value_cloned = value.clone();
    // The mutable borrow is a reference to `value` and
    // not to `value_cloned`...
    let borrow = &amp;mut value;
    // ... which means we can still use `value_cloned`,
    let _sum = value_cloned + 1;
    // even though the borrow only ends here.
    println!("{}", borrow);
}</pre></div> <p>You can find more information about borrowing in the rust-book: http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html</p>  <h3 id="E0504" class="section-header">E0504</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-25" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>This error occurs when an attempt is made to move a borrowed variable into a closure.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_num = FancyNum { num: 5 };
    let fancy_ref = &amp;fancy_num;

    let x = move || {
        println!("child function: {}", fancy_num.num);
        // error: cannot move `fancy_num` into closure because it is borrowed
    };

    x();
    println!("main function: {}", fancy_ref.num);
}</pre></div> <p>Here, <code>fancy_num</code> is borrowed by <code>fancy_ref</code> and so cannot be moved into the closure <code>x</code>. There is no way to move a value into a closure while it is borrowed, as that would invalidate the borrow.</p> <p>If the closure can't outlive the value being moved, try using a reference rather than moving:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_num = FancyNum { num: 5 };
    let fancy_ref = &amp;fancy_num;

    let x = move || {
        // fancy_ref is usable here because it doesn't move `fancy_num`
        println!("child function: {}", fancy_ref.num);
    };

    x();

    println!("main function: {}", fancy_num.num);
}</pre></div> <p>If the value has to be borrowed and then moved, try limiting the lifetime of the borrow using a scoped block:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_num = FancyNum { num: 5 };

    {
        let fancy_ref = &amp;fancy_num;
        println!("main function: {}", fancy_ref.num);
        // `fancy_ref` goes out of scope here
    }

    let x = move || {
        // `fancy_num` can be moved now (no more references exist)
        println!("child function: {}", fancy_num.num);
    };

    x();
}</pre></div> <p>If the lifetime of a reference isn't enough, such as in the case of threading, consider using an <code>Arc</code> to create a reference-counted value:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::sync::Arc;
use std::thread;

struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_ref1 = Arc::new(FancyNum { num: 5 });
    let fancy_ref2 = fancy_ref1.clone();

    let x = thread::spawn(move || {
        // `fancy_ref1` can be moved and has a `'static` lifetime
        println!("child thread: {}", fancy_ref1.num);
    });

    x.join().expect("child thread should finish");
    println!("main thread: {}", fancy_ref2.num);
}</pre></div>  <h3 id="E0505" class="section-header">E0505</h3> <p>A value was moved out while it was still borrowed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Value {}

fn borrow(val: &amp;Value) {}

fn eat(val: Value) {}

fn main() {
    let x = Value{};
    let _ref_to_val: &amp;Value = &amp;x;
    eat(x);
    borrow(_ref_to_val);
}</pre></div> <p>Here, the function <code>eat</code> takes ownership of <code>x</code>. However, <code>x</code> cannot be moved because the borrow to <code>_ref_to_val</code> needs to last till the function <code>borrow</code>. To fix that you can do a few different things:</p> <ul> <li>Try to avoid moving the variable.</li> <li>Release borrow before move.</li> <li>Implement the <code>Copy</code> trait on the type.</li> </ul> <p>Examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Value {}

fn borrow(val: &amp;Value) {}

fn eat(val: &amp;Value) {}

fn main() {
    let x = Value{};

    let ref_to_val: &amp;Value = &amp;x;
    eat(&amp;x); // pass by reference, if it's possible
    borrow(ref_to_val);
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Value {}

fn borrow(val: &amp;Value) {}

fn eat(val: Value) {}

fn main() {
    let x = Value{};

    let ref_to_val: &amp;Value = &amp;x;
    borrow(ref_to_val);
    // ref_to_val is no longer used.
    eat(x);
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[derive(Clone, Copy)] // implement Copy trait
struct Value {}

fn borrow(val: &amp;Value) {}

fn eat(val: Value) {}

fn main() {
    let x = Value{};
    let ref_to_val: &amp;Value = &amp;x;
    eat(x); // it will be copied here.
    borrow(ref_to_val);
}</pre></div> <p>You can find more information about borrowing in the rust-book: http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html</p>  <h3 id="E0506" class="section-header">E0506</h3> <p>This error occurs when an attempt is made to assign to a borrowed value.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy_num = FancyNum { num: 5 };
    let fancy_ref = &amp;fancy_num;
    fancy_num = FancyNum { num: 6 };
    // error: cannot assign to `fancy_num` because it is borrowed

    println!("Num: {}, Ref: {}", fancy_num.num, fancy_ref.num);
}</pre></div> <p>Because <code>fancy_ref</code> still holds a reference to <code>fancy_num</code>, <code>fancy_num</code> can't be assigned to a new value as it would invalidate the reference.</p> <p>Alternatively, we can move out of <code>fancy_num</code> into a second <code>fancy_num</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy_num = FancyNum { num: 5 };
    let moved_num = fancy_num;
    fancy_num = FancyNum { num: 6 };

    println!("Num: {}, Moved num: {}", fancy_num.num, moved_num.num);
}</pre></div> <p>If the value has to be borrowed, try limiting the lifetime of the borrow using a scoped block:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy_num = FancyNum { num: 5 };

    {
        let fancy_ref = &amp;fancy_num;
        println!("Ref: {}", fancy_ref.num);
    }

    // Works because `fancy_ref` is no longer in scope
    fancy_num = FancyNum { num: 6 };
    println!("Num: {}", fancy_num.num);
}</pre></div> <p>Or by moving the reference into a function:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy_num = FancyNum { num: 5 };

    print_fancy_ref(&amp;fancy_num);

    // Works because function borrow has ended
    fancy_num = FancyNum { num: 6 };
    println!("Num: {}", fancy_num.num);
}

fn print_fancy_ref(fancy_ref: &amp;FancyNum){
    println!("Ref: {}", fancy_ref.num);
}</pre></div>  <h3 id="E0507" class="section-header">E0507</h3> <p>You tried to move out of a value which was borrowed. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content
}</pre></div> <p>Here, the <code>nothing_is_true</code> method takes the ownership of <code>self</code>. However, <code>self</code> cannot be moved because <code>.borrow()</code> only provides an <code>&amp;TheDarkKnight</code>, which is a borrow of the content owned by the <code>RefCell</code>. To fix this error, you have three choices:</p> <ul> <li>Try to avoid moving the variable.</li> <li>Somehow reclaim the ownership.</li> <li>Implement the <code>Copy</code> trait on the type.</li> </ul> <p>Examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(&amp;self) {} // First case, we don't take ownership
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // ok!
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);
    let x = x.into_inner(); // we get back ownership

    x.nothing_is_true(); // ok!
}</pre></div> <p>Or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::RefCell;

#[derive(Clone, Copy)] // we implement the Copy trait
struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // ok!
}</pre></div> <p>Moving a member out of a mutably borrowed struct will also cause E0507 error:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

struct Batcave {
    knight: TheDarkKnight
}

fn main() {
    let mut cave = Batcave {
        knight: TheDarkKnight
    };
    let borrowed = &amp;mut cave;

    borrowed.knight.nothing_is_true(); // E0507
}</pre></div> <p>It is fine only if you put something back. <code>mem::replace</code> can be used for that:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::mem;

let mut cave = Batcave {
    knight: TheDarkKnight
};
let borrowed = &amp;mut cave;

mem::replace(&amp;mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!</pre></div> <p>You can find more information about borrowing in the rust-book: http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html</p>  <h3 id="E0508" class="section-header">E0508</h3> <p>A value was moved out of a non-copy fixed-size array.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct NonCopy;

fn main() {
    let array = [NonCopy; 1];
    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,
                           //        a non-copy fixed-size array
}</pre></div> <p>The first element was moved out of the array, but this is not possible because <code>NonCopy</code> does not implement the <code>Copy</code> trait.</p> <p>Consider borrowing the element instead of moving it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct NonCopy;

fn main() {
    let array = [NonCopy; 1];
    let _value = &amp;array[0]; // Borrowing is allowed, unlike moving.
}</pre></div> <p>Alternatively, if your type implements <code>Clone</code> and you need to own the value, consider borrowing and then cloning:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[derive(Clone)]
struct NonCopy;

fn main() {
    let array = [NonCopy; 1];
    // Now you can clone the array element.
    let _value = array[0].clone();
}</pre></div>  <h3 id="E0509" class="section-header">E0509</h3> <p>This error occurs when an attempt is made to move out of a value whose type implements the <code>Drop</code> trait.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct FancyNum {
    num: usize
}

struct DropStruct {
    fancy: FancyNum
}

impl Drop for DropStruct {
    fn drop(&amp;mut self) {
        // Destruct DropStruct, possibly using FancyNum
    }
}

fn main() {
    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};
    let fancy_field = drop_struct.fancy; // Error E0509
    println!("Fancy: {}", fancy_field.num);
    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope
}</pre></div> <p>Here, we tried to move a field out of a struct of type <code>DropStruct</code> which implements the <code>Drop</code> trait. However, a struct cannot be dropped if one or more of its fields have been moved.</p> <p>Structs implementing the <code>Drop</code> trait have an implicit destructor that gets called when they go out of scope. This destructor may use the fields of the struct, so moving out of the struct could make it impossible to run the destructor. Therefore, we must think of all values whose type implements the <code>Drop</code> trait as single units whose fields cannot be moved.</p> <p>This error can be fixed by creating a reference to the fields of a struct, enum, or tuple using the <code>ref</code> keyword:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: usize
}

struct DropStruct {
    fancy: FancyNum
}

impl Drop for DropStruct {
    fn drop(&amp;mut self) {
        // Destruct DropStruct, possibly using FancyNum
    }
}

fn main() {
    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};
    let ref fancy_field = drop_struct.fancy; // No more errors!
    println!("Fancy: {}", fancy_field.num);
    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope
}</pre></div> <p>Note that this technique can also be used in the arms of a match expression:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: usize
}

enum DropEnum {
    Fancy(FancyNum)
}

impl Drop for DropEnum {
    fn drop(&amp;mut self) {
        // Destruct DropEnum, possibly using FancyNum
    }
}

fn main() {
    // Creates and enum of type `DropEnum`, which implements `Drop`
    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});
    match drop_enum {
        // Creates a reference to the inside of `DropEnum::Fancy`
        DropEnum::Fancy(ref fancy_field) =&gt; // No error!
            println!("It was fancy-- {}!", fancy_field.num),
    }
    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope
}</pre></div>  <h3 id="E0510" class="section-header">E0510</h3> <p>Cannot mutate place in this match guard.</p> <p>When matching on a variable it cannot be mutated in the match guards, as this could cause the match to be non-exhaustive:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(nll, bind_by_move_pattern_guards)]
let mut x = Some(0);
match x {
    None =&gt; (),
    Some(_) if { x = None; false } =&gt; (),
    Some(v) =&gt; (), // No longer matches
}</pre></div> <p>Here executing <code>x = None</code> would modify the value being matched and require us to go "back in time" to the <code>None</code> arm.</p>  <h3 id="E0511" class="section-header">E0511</h3> <p>Invalid monomorphization of an intrinsic function was used. Erroneous code example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#![feature(platform_intrinsics)]

extern "platform-intrinsic" {
    fn simd_add&lt;T&gt;(a: T, b: T) -&gt; T;
}

fn main() {
    unsafe { simd_add(0, 1); }
    // error: invalid monomorphization of `simd_add` intrinsic
}</pre></div> <p>The generic type has to be a SIMD type. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]
#![feature(platform_intrinsics)]

#[repr(simd)]
#[derive(Copy, Clone)]
struct i32x2(i32, i32);

extern "platform-intrinsic" {
    fn simd_add&lt;T&gt;(a: T, b: T) -&gt; T;
}

unsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); } // ok!</pre></div>  <h3 id="E0512" class="section-header">E0512</h3> <p>Transmute with two differently sized types was attempted. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn takes_u8(_: u8) {}

fn main() {
    unsafe { takes_u8(::std::mem::transmute(0u16)); }
    // error: cannot transmute between types of different sizes,
    //        or dependently-sized types
}</pre></div> <p>Please use types with same size or use the expected type directly. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn takes_u8(_: u8) {}

fn main() {
    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!
    // or:
    unsafe { takes_u8(0u8); } // ok!
}</pre></div>   <h3 id="E0515" class="section-header">E0515</h3> <p>Cannot return value that references local variable</p> <p>Local variables, function parameters and temporaries are all dropped before the end of the function body. So a reference to them cannot be returned.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(nll)]
fn get_dangling_reference() -&gt; &amp;'static i32 {
    let x = 0;
    &amp;x
}</pre></div> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(nll)]
use std::slice::Iter;
fn get_dangling_iterator&lt;'a&gt;() -&gt; Iter&lt;'a, i32&gt; {
    let v = vec![1, 2, 3];
    v.iter()
}</pre></div> <p>Consider returning an owned value instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::vec::IntoIter;

fn get_integer() -&gt; i32 {
    let x = 0;
    x
}

fn get_owned_iterator() -&gt; IntoIter&lt;i32&gt; {
    let v = vec![1, 2, 3];
    v.into_iter()
}</pre></div>  <h3 id="E0516" class="section-header">E0516</h3> <p>The <code>typeof</code> keyword is currently reserved but unimplemented. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    let x: typeof(92) = 92;
}</pre></div> <p>Try using type inference instead. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let x = 92;
}</pre></div>  <h3 id="E0517" class="section-header">E0517</h3> <p>This error indicates that a <code>#[repr(..)]</code> attribute was placed on an unsupported item.</p> <p>Examples of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(C)]
type Foo = u8;

#[repr(packed)]
enum Foo {Bar, Baz}

#[repr(u8)]
struct Foo {bar: bool, baz: bool}

#[repr(C)]
impl Foo {
    // ...
}</pre></div> <ul> <li>The <code>#[repr(C)]</code> attribute can only be placed on structs and enums.</li> <li>The <code>#[repr(packed)]</code> and <code>#[repr(simd)]</code> attributes only work on structs.</li> <li>The <code>#[repr(u8)]</code>, <code>#[repr(i16)]</code>, etc attributes only work on enums.</li> </ul> <p>These attributes do not work on typedefs, since typedefs are just aliases.</p> <p>Representations like <code>#[repr(u8)]</code>, <code>#[repr(i64)]</code> are for selecting the discriminant size for enums with no data fields on any of the variants, e.g. <code>enum Color {Red, Blue, Green}</code>, effectively setting the size of the enum to the size of the provided type. Such an enum can be cast to a value of the same type as well. In short, <code>#[repr(u8)]</code> makes the enum behave like an integer with a constrained set of allowed values.</p> <p>Only field-less enums can be cast to numerical primitives, so this attribute will not apply to structs.</p> <p><code>#[repr(packed)]</code> reduces padding to make the struct size smaller. The representation of enums isn't strictly defined in Rust, and this attribute won't work on enums.</p> <p><code>#[repr(simd)]</code> will give a struct consisting of a homogeneous series of machine types (i.e., <code>u8</code>, <code>i32</code>, etc) a representation that permits vectorization via SIMD. This doesn't make much sense for enums since they don't consist of a single list of data.</p>  <h3 id="E0518" class="section-header">E0518</h3> <p>This error indicates that an <code>#[inline(..)]</code> attribute was incorrectly placed on something other than a function or method.</p> <p>Examples of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[inline(always)]
struct Foo;

#[inline(never)]
impl Foo {
    // ...
}</pre></div> <p><code>#[inline]</code> hints the compiler whether or not to attempt to inline a method or function. By default, the compiler does a pretty good job of figuring this out itself, but if you feel the need for annotations, <code>#[inline(always)]</code> and <code>#[inline(never)]</code> can override or force the compiler's decision.</p> <p>If you wish to apply this attribute to all methods in an impl, manually annotate each method; it is not possible to annotate the entire impl with an <code>#[inline]</code> attribute.</p>   <h3 id="E0520" class="section-header">E0520</h3> <p>A non-default implementation was already made on this type so it cannot be specialized further. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(specialization)]

trait SpaceLlama {
    fn fly(&amp;self);
}

// applies to all T
impl&lt;T&gt; SpaceLlama for T {
    default fn fly(&amp;self) {}
}

// non-default impl
// applies to all `Clone` T and overrides the previous impl
impl&lt;T: Clone&gt; SpaceLlama for T {
    fn fly(&amp;self) {}
}

// since `i32` is clone, this conflicts with the previous implementation
impl SpaceLlama for i32 {
    default fn fly(&amp;self) {}
    // error: item `fly` is provided by an `impl` that specializes
    //        another, but the item in the parent `impl` is not marked
    //        `default` and so it cannot be specialized.
}</pre></div> <p>Specialization only allows you to override <code>default</code> functions in implementations.</p> <p>To fix this error, you need to mark all the parent implementations as default. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(specialization)]

trait SpaceLlama {
    fn fly(&amp;self);
}

// applies to all T
impl&lt;T&gt; SpaceLlama for T {
    default fn fly(&amp;self) {} // This is a parent implementation.
}

// applies to all `Clone` T; overrides the previous impl
impl&lt;T: Clone&gt; SpaceLlama for T {
    default fn fly(&amp;self) {} // This is a parent implementation but was
                             // previously not a default one, causing the error
}

// applies to i32, overrides the previous two impls
impl SpaceLlama for i32 {
    fn fly(&amp;self) {} // And now that's ok!
}</pre></div>   <h3 id="E0522" class="section-header">E0522</h3> <p>The lang attribute is intended for marking special items that are built-in to Rust itself. This includes special traits (like <code>Copy</code> and <code>Sized</code>) that affect how the compiler behaves, as well as special functions that may be automatically invoked (such as the handler for out-of-bounds accesses when indexing a slice). Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(lang_items)]

#[lang = "cookie"]
fn cookie() -&gt; ! { // error: definition of an unknown language item: `cookie`
    loop {}
}</pre></div>    <h3 id="E0525" class="section-header">E0525</h3> <p>A closure was used but didn't implement the expected trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct X;

fn foo&lt;T&gt;(_: T) {}
fn bar&lt;T: Fn(u32)&gt;(_: T) {}

fn main() {
    let x = X;
    let closure = |_| foo(x); // error: expected a closure that implements
                              //        the `Fn` trait, but this closure only
                              //        implements `FnOnce`
    bar(closure);
}</pre></div> <p>In the example above, <code>closure</code> is an <code>FnOnce</code> closure whereas the <code>bar</code> function expected an <code>Fn</code> closure. In this case, it's simple to fix the issue, you just have to implement <code>Copy</code> and <code>Clone</code> traits on <code>struct X</code> and it'll be ok:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[derive(Clone, Copy)] // We implement `Clone` and `Copy` traits.
struct X;

fn foo&lt;T&gt;(_: T) {}
fn bar&lt;T: Fn(u32)&gt;(_: T) {}

fn main() {
    let x = X;
    let closure = |_| foo(x);
    bar(closure); // ok!
}</pre></div> <p>To understand better how closures work in Rust, read: https://doc.rust-lang.org/book/ch13-01-closures.html</p>   <h3 id="E0527" class="section-header">E0527</h3> <p>The number of elements in an array or slice pattern differed from the number of elements in the array being matched.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let r = &amp;[1, 2, 3, 4];
match r {
    &amp;[a, b] =&gt; { // error: pattern requires 2 elements but array
                 //        has 4
        println!("a={}, b={}", a, b);
    }
}</pre></div> <p>Ensure that the pattern is consistent with the size of the matched array. Additional elements can be matched with <code>..</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(slice_patterns)]

let r = &amp;[1, 2, 3, 4];
match r {
    &amp;[a, b, ..] =&gt; { // ok!
        println!("a={}, b={}", a, b);
    }
}</pre></div>  <h3 id="E0528" class="section-header">E0528</h3> <p>An array or slice pattern required more elements than were present in the matched array.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(slice_patterns)]

let r = &amp;[1, 2];
match r {
    &amp;[a, b, c, rest..] =&gt; { // error: pattern requires at least 3
                            //        elements but array has 2
        println!("a={}, b={}, c={} rest={:?}", a, b, c, rest);
    }
}</pre></div> <p>Ensure that the matched array has at least as many elements as the pattern requires. You can match an arbitrary number of remaining elements with <code>..</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(slice_patterns)]

let r = &amp;[1, 2, 3, 4, 5];
match r {
    &amp;[a, b, c, rest..] =&gt; { // ok!
        // prints `a=1, b=2, c=3 rest=[4, 5]`
        println!("a={}, b={}, c={} rest={:?}", a, b, c, rest);
    }
}</pre></div>  <h3 id="E0529" class="section-header">E0529</h3> <p>An array or slice pattern was matched against some other type.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let r: f32 = 1.0;
match r {
    [a, b] =&gt; { // error: expected an array or slice, found `f32`
        println!("a={}, b={}", a, b);
    }
}</pre></div> <p>Ensure that the pattern and the expression being matched on are of consistent types:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let r = [1.0, 2.0];
match r {
    [a, b] =&gt; { // ok!
        println!("a={}, b={}", a, b);
    }
}</pre></div>  <h3 id="E0530" class="section-header">E0530</h3> <p>A binding shadowed something it shouldn't.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
static TEST: i32 = 0;

let r: (i32, i32) = (0, 0);
match r {
    TEST =&gt; {} // error: match bindings cannot shadow statics
}</pre></div> <p>To fix this error, just change the binding's name in order to avoid shadowing one of the following:</p> <ul> <li>struct name</li> <li>struct/enum variant</li> <li>static</li> <li>const</li> <li>associated const</li> </ul> <p>Fixed example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
static TEST: i32 = 0;

let r: (i32, i32) = (0, 0);
match r {
    something =&gt; {} // ok!
}</pre></div>   <h3 id="E0532" class="section-header">E0532</h3> <p>Pattern arm did not match expected kind.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum State {
    Succeeded,
    Failed(String),
}

fn print_on_failure(state: &amp;State) {
    match *state {
        // error: expected unit struct/variant or constant, found tuple
        //        variant `State::Failed`
        State::Failed =&gt; println!("Failed"),
        _ =&gt; ()
    }
}</pre></div> <p>To fix this error, ensure the match arm kind is the same as the expression matched.</p> <p>Fixed example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum State {
    Succeeded,
    Failed(String),
}

fn print_on_failure(state: &amp;State) {
    match *state {
        State::Failed(ref msg) =&gt; println!("Failed with {}", msg),
        _ =&gt; ()
    }
}</pre></div>   <h3 id="E0534" class="section-header">E0534</h3> <p>The <code>inline</code> attribute was malformed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#[inline()] // error: expected one argument
pub fn something() {}

fn main() {}</pre></div> <p>The parenthesized <code>inline</code> attribute requires the parameter to be specified:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[inline(always)]
fn something() {}</pre></div> <p>or:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[inline(never)]
fn something() {}</pre></div> <p>Alternatively, a paren-less version of the attribute may be used to hint the compiler about inlining opportunity:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[inline]
fn something() {}</pre></div> <p>For more information about the inline attribute, read: https://doc.rust-lang.org/reference.html#inline-attributes</p>  <h3 id="E0535" class="section-header">E0535</h3> <p>An unknown argument was given to the <code>inline</code> attribute.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#[inline(unknown)] // error: invalid argument
pub fn something() {}

fn main() {}</pre></div> <p>The <code>inline</code> attribute only supports two arguments:</p> <ul> <li>always</li> <li>never</li> </ul> <p>All other arguments given to the <code>inline</code> attribute will return this error. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[inline(never)] // ok!
pub fn something() {}

fn main() {}</pre></div> <p>For more information about the inline attribute, https: read://doc.rust-lang.org/reference.html#inline-attributes</p>  <h3 id="E0536" class="section-header">E0536</h3> <p>The <code>not</code> cfg-predicate was malformed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[cfg(not())] // error: expected 1 cfg-pattern
pub fn something() {}

pub fn main() {}</pre></div> <p>The <code>not</code> predicate expects one cfg-pattern. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[cfg(not(target_os = "linux"))] // ok!
pub fn something() {}

pub fn main() {}</pre></div> <p>For more information about the cfg attribute, read: https://doc.rust-lang.org/reference.html#conditional-compilation</p>  <h3 id="E0537" class="section-header">E0537</h3> <p>An unknown predicate was used inside the <code>cfg</code> attribute.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[cfg(unknown())] // error: invalid predicate `unknown`
pub fn something() {}

pub fn main() {}</pre></div> <p>The <code>cfg</code> attribute supports only three kinds of predicates:</p> <ul> <li>any</li> <li>all</li> <li>not</li> </ul> <p>Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[cfg(not(target_os = "linux"))] // ok!
pub fn something() {}

pub fn main() {}</pre></div> <p>For more information about the cfg attribute, read: https://doc.rust-lang.org/reference.html#conditional-compilation</p>  <h3 id="E0538" class="section-header">E0538</h3> <p>Attribute contains same meta item more than once.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[deprecated(
    since="1.0.0",
    note="First deprecation note.",
    note="Second deprecation note." // error: multiple same meta item
)]
fn deprecated_function() {}</pre></div> <p>Meta items are the key-value pairs inside of an attribute. Each key may only be used once in each attribute.</p> <p>To fix the problem, remove all but one of the meta items with the same key.</p> <p>Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[deprecated(
    since="1.0.0",
    note="First deprecation note."
)]
fn deprecated_function() {}</pre></div>    <h3 id="E0541" class="section-header">E0541</h3> <p>An unknown meta item was used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[deprecated(
    since="1.0.0",
    // error: unknown meta item
    reason="Example invalid meta item. Should be 'note'")
]
fn deprecated_function() {}</pre></div> <p>Meta items are the key-value pairs inside of an attribute. The keys provided must be one of the valid keys for the specified attribute.</p> <p>To fix the problem, either remove the unknown meta item, or rename it if you provided the wrong name.</p> <p>In the erroneous code example above, the wrong name was provided, so changing to a correct one it will fix the error. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[deprecated(
    since="1.0.0",
    note="This is a valid meta item for the deprecated attribute."
)]
fn deprecated_function() {}</pre></div>           <h3 id="E0552" class="section-header">E0552</h3> <p>A unrecognized representation attribute was used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(D)] // error: unrecognized representation hint
struct MyStruct {
    my_field: usize
}</pre></div> <p>You can use a <code>repr</code> attribute to tell the compiler how you want a struct or enum to be laid out in memory.</p> <p>Make sure you're using one of the supported options:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(C)] // ok!
struct MyStruct {
    my_field: usize
}</pre></div> <p>For more information about specifying representations, see the <a href="https://doc.rust-lang.org/nomicon/other-reprs.html" target="_blank">"Alternative Representations" section</a> of the Rustonomicon.</p>   <h3 id="E0554" class="section-header">E0554</h3> <p>Feature attributes are only allowed on the nightly release channel. Stable or beta compilers will not comply.</p> <p>Example of erroneous code (on a stable compiler):</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#![feature(non_ascii_idents)] // error: #![feature] may not be used on the
                              //        stable release channel</pre></div> <p>If you need the feature, make sure to use a nightly release of the compiler (but be warned that the feature may be removed or altered in the future).</p>   <h3 id="E0557" class="section-header">E0557</h3> <p>A feature attribute named a feature that has been removed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(managed_boxes)] // error: feature has been removed</pre></div> <p>Delete the offending feature attribute.</p>  <h3 id="E0559" class="section-header">E0559</h3> <p>An unknown field was specified into an enum's structure variant.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Field {
    Fool { x: u32 },
}

let s = Field::Fool { joke: 0 };
// error: struct variant `Field::Fool` has no field named `joke`</pre></div> <p>Verify you didn't misspell the field's name or that the field exists. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
enum Field {
    Fool { joke: u32 },
}

let s = Field::Fool { joke: 0 }; // ok!</pre></div>  <h3 id="E0560" class="section-header">E0560</h3> <p>An unknown field was specified into a structure.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Simba {
    mother: u32,
}

let s = Simba { mother: 1, father: 0 };
// error: structure `Simba` has no field named `father`</pre></div> <p>Verify you didn't misspell the field's name or that the field exists. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Simba {
    mother: u32,
    father: u32,
}

let s = Simba { mother: 1, father: 0 }; // ok!</pre></div>   <h3 id="E0562" class="section-header">E0562</h3> <p>Abstract return types (written <code>impl Trait</code> for some trait <code>Trait</code>) are only allowed as function and inherent impl return types.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    let count_to_ten: impl Iterator&lt;Item=usize&gt; = 0..10;
    // error: `impl Trait` not allowed outside of function and inherent method
    //        return types
    for i in count_to_ten {
        println!("{}", i);
    }
}</pre></div> <p>Make sure <code>impl Trait</code> only appears in return-type position.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn count_to_n(n: usize) -&gt; impl Iterator&lt;Item=usize&gt; {
    0..n
}

fn main() {
    for i in count_to_n(10) {  // ok!
        println!("{}", i);
    }
}</pre></div> <p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md" target="_blank">RFC 1522</a> for more details.</p>   <h3 id="E0565" class="section-header">E0565</h3> <p>A literal was used in a built-in attribute that doesn't support literals.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#[inline("always")] // error: unsupported literal
pub fn something() {}</pre></div> <p>Literals in attributes are new and largely unsupported in built-in attributes. Work to support literals where appropriate is ongoing. Try using an unquoted name instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[inline(always)]
pub fn something() {}</pre></div>     <h3 id="E0569" class="section-header">E0569</h3> <p>If an impl has a generic parameter with the <code>#[may_dangle]</code> attribute, then that impl must be declared as an `unsafe impl.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(dropck_eyepatch)]

struct Foo&lt;X&gt;(X);
impl&lt;#[may_dangle] X&gt; Drop for Foo&lt;X&gt; {
    fn drop(&amp;mut self) { }
}</pre></div> <p>In this example, we are asserting that the destructor for <code>Foo</code> will not access any data of type <code>X</code>, and require this assertion to be true for overall safety in our program. The compiler does not currently attempt to verify this assertion; therefore we must tag this <code>impl</code> as unsafe.</p>  <h3 id="E0570" class="section-header">E0570</h3> <p>The requested ABI is unsupported by the current target.</p> <p>The rust compiler maintains for each target a blacklist of ABIs unsupported on that target. If an ABI is present in such a list this usually means that the target / ABI combination is currently unsupported by llvm.</p> <p>If necessary, you can circumvent this check using custom target specifications.</p>  <h3 id="E0571" class="section-header">E0571</h3> <p>A <code>break</code> statement with an argument appeared in a non-<code>loop</code> loop.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let result = while true {
    if satisfied(i) {
        break 2*i; // error: `break` with value from a `while` loop
    }
    i += 1;
};</pre></div> <p>The <code>break</code> statement can take an argument (which will be the value of the loop expression if the <code>break</code> statement is executed) in <code>loop</code> loops, but not <code>for</code>, <code>while</code>, or <code>while let</code> loops.</p> <p>Make sure <code>break value;</code> statements only occur in <code>loop</code> loops:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let result = loop { // ok!
    if satisfied(i) {
        break 2*i;
    }
    i += 1;
};</pre></div>  <h3 id="E0572" class="section-header">E0572</h3> <p>A return statement was found outside of a function body.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
const FOO: u32 = return 0; // error: return statement outside of function body

fn main() {}</pre></div> <p>To fix this issue, just remove the return keyword or move the expression into a function. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
const FOO: u32 = 0;

fn some_fn() -&gt; u32 {
    return FOO;
}

fn main() {
    some_fn();
}</pre></div>        <h3 id="E0579" class="section-header">E0579</h3> <p>When matching against an exclusive range, the compiler verifies that the range is non-empty. Exclusive range patterns include the start point but not the end point, so this is equivalent to requiring the start of the range to be less than the end of the range.</p> <p>For example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
match 5u32 {
    // This range is ok, albeit pointless.
    1 .. 2 =&gt; {}
    // This range is empty, and the compiler can tell.
    5 .. 5 =&gt; {}
}</pre></div>  <h3 id="E0580" class="section-header">E0580</h3> <p>The <code>main</code> function was incorrectly declared.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main(x: i32) { // error: main function has wrong type
    println!("{}", x);
}</pre></div> <p>The <code>main</code> function prototype should never take arguments. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    // your code
}</pre></div> <p>If you want to get command-line arguments, use <code>std::env::args</code>. To exit with a specified exit code, use <code>std::process::exit</code>.</p>  <h3 id="E0581" class="section-header">E0581</h3> <p>In a <code>fn</code> type, a lifetime appears only in the return type, and not in the arguments types.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    // Here, `'a` appears only in the return type:
    let x: for&lt;'a&gt; fn() -&gt; &amp;'a i32;
}</pre></div> <p>To fix this issue, either use the lifetime in the arguments, or use <code>'static</code>. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    // Here, `'a` appears only in the return type:
    let x: for&lt;'a&gt; fn(&amp;'a i32) -&gt; &amp;'a i32;
    let y: fn() -&gt; &amp;'static i32;
}</pre></div> <p>Note: The examples above used to be (erroneously) accepted by the compiler, but this was since corrected. See <a href="https://github.com/rust-lang/rust/issues/33685" target="_blank">issue #33685</a> for more details.</p>  <h3 id="E0582" class="section-header">E0582</h3> <p>A lifetime appears only in an associated-type binding, and not in the input types to the trait.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn bar&lt;F&gt;(t: F)
    // No type can satisfy this requirement, since `'a` does not
    // appear in any of the input types (here, `i32`):
    where F: for&lt;'a&gt; Fn(i32) -&gt; Option&lt;&amp;'a i32&gt;
{
}

fn main() { }</pre></div> <p>To fix this issue, either use the lifetime in the inputs, or use <code>'static</code>. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn bar&lt;F, G&gt;(t: F, u: G)
    where F: for&lt;'a&gt; Fn(&amp;'a i32) -&gt; Option&lt;&amp;'a i32&gt;,
          G: Fn(i32) -&gt; Option&lt;&amp;'static i32&gt;,
{
}

fn main() { }</pre></div> <p>Note: The examples above used to be (erroneously) accepted by the compiler, but this was since corrected. See <a href="https://github.com/rust-lang/rust/issues/33685" target="_blank">issue #33685</a> for more details.</p>  <h3 id="E0583" class="section-header">E0583</h3> <p>A file wasn't found for an out-of-line module.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
mod file_that_doesnt_exist; // error: file not found for module

fn main() {}</pre></div> <p>Please be sure that a file corresponding to the module exists. If you want to use a module named <code>file_that_doesnt_exist</code>, you need to have a file named <code>file_that_doesnt_exist.rs</code> or <code>file_that_doesnt_exist/mod.rs</code> in the same directory.</p>   <h3 id="E0585" class="section-header">E0585</h3> <p>A documentation comment that doesn't document anything was found.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    // The following doc comment will fail:
    /// This is a useless doc comment!
}</pre></div> <p>Documentation comments need to be followed by items, including functions, types, modules, etc. Examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
/// I'm documenting the following struct:
struct Foo;

/// I'm documenting the following function:
fn foo() {}</pre></div>  <h3 id="E0586" class="section-header">E0586</h3> <p>An inclusive range was used with no end.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() {
    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];
    let x = &amp;tmp[1..=]; // error: inclusive range was used with no end
}</pre></div> <p>An inclusive range needs an end in order to <em>include</em> it. If you just need a start and no end, use a non-inclusive range (with <code>..</code>):</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];
    let x = &amp;tmp[1..]; // ok!
}</pre></div> <p>Or put an end to your inclusive range:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];
    let x = &amp;tmp[1..=3]; // ok!
}</pre></div>    <h3 id="E0589" class="section-header">E0589</h3> <p>The value of <code>N</code> that was specified for <code>repr(align(N))</code> was not a power of two, or was greater than 2^29.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(align(15))] // error: invalid `repr(align)` attribute: not a power of two
enum Foo {
    Bar(u64),
}</pre></div>  <h3 id="E0590" class="section-header">E0590</h3> <p><code>break</code> or <code>continue</code> must include a label when used in the condition of a <code>while</code> loop.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
while break {}</pre></div> <p>To fix this, add a label specifying which loop is being broken out of:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
'foo: while break 'foo {}</pre></div>  <h3 id="E0591" class="section-header">E0591</h3> <p>Per <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md" target="_blank">RFC 401</a>, if you have a function declaration <code>foo</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// For the purposes of this explanation, all of these
// different kinds of `fn` declarations are equivalent:
struct S;
fn foo(x: S) { /* ... */ }
extern "C" { fn foo(x: S); }
impl S { fn foo(self) { /* ... */ } }</pre></div> <p>the type of <code>foo</code> is <strong>not</strong> <code>fn(S)</code>, as one might expect. Rather, it is a unique, zero-sized marker type written here as <code>typeof(foo)</code>. However, <code>typeof(foo)</code> can be <em>coerced</em> to a function pointer <code>fn(S)</code>, so you rarely notice this:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x: fn(S) = foo; // OK, coerces</pre></div> <p>The reason that this matter is that the type <code>fn(S)</code> is not specific to any particular function: it's a function <em>pointer</em>. So calling <code>x()</code> results in a virtual call, whereas <code>foo()</code> is statically dispatched, because the type of <code>foo</code> tells us precisely what function is being called.</p> <p>As noted above, coercions mean that most code doesn't have to be concerned with this distinction. However, you can tell the difference when using <strong>transmute</strong> to convert a fn item into a fn pointer.</p> <p>This is sometimes done as part of an FFI:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
extern "C" fn foo(userdata: Box&lt;i32&gt;) {
    /* ... */
}

let f: extern "C" fn(*mut i32) = transmute(foo);
callback(f);</pre></div> <p>Here, transmute is being used to convert the types of the fn arguments. This pattern is incorrect because, because the type of <code>foo</code> is a function <strong>item</strong> (<code>typeof(foo)</code>), which is zero-sized, and the target type (<code>fn()</code>) is a function pointer, which is not zero-sized. This pattern should be rewritten. There are a few possible ways to do this:</p> <ul> <li> <p>change the original fn declaration to match the expected signature, and do the cast in the fn body (the preferred option)</p> </li> <li> <p>cast the fn item fo a fn pointer before calling transmute, as shown here:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let f: extern "C" fn(*mut i32) = transmute(foo as extern "C" fn(_));
let f: extern "C" fn(*mut i32) = transmute(foo as usize); // works too</pre></div> </li> </ul> <p>The same applies to transmutes to <code>*mut fn()</code>, which were observed in practice. Note though that use of this type is generally incorrect. The intention is typically to describe a function pointer, but just <code>fn()</code> alone suffices for that. <code>*mut fn()</code> is a pointer to a fn pointer. (Since these values are typically just passed to C code, however, this rarely makes a difference in practice.)</p>  <h3 id="E0592" class="section-header">E0592</h3> <p>This error occurs when you defined methods or associated functions with same name.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo;

impl Foo {
    fn bar() {} // previous definition here
}

impl Foo {
    fn bar() {} // duplicate definition here
}</pre></div> <p>A similar error is E0201. The difference is whether there is one declaration block or not. To avoid this error, you must give each <code>fn</code> a unique name.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo;

impl Foo {
    fn bar() {}
}

impl Foo {
    fn baz() {} // define with different name
}</pre></div>  <h3 id="E0593" class="section-header">E0593</h3> <p>You tried to supply an <code>Fn</code>-based type with an incorrect number of arguments than what was expected.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;F: Fn()&gt;(x: F) { }

fn main() {
    // [E0593] closure takes 1 argument but 0 arguments are required
    foo(|y| { });
}</pre></div>   <h3 id="E0595" class="section-header">E0595</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-26" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>Closures cannot mutate immutable captured variables.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = 3; // error: closure cannot assign to immutable local variable `x`
let mut c = || { x += 1 };</pre></div> <p>Make the variable binding mutable:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut x = 3; // ok!
let mut c = || { x += 1 };</pre></div>  <h3 id="E0596" class="section-header">E0596</h3> <p>This error occurs because you tried to mutably borrow a non-mutable variable.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = 1;
let y = &amp;mut x; // error: cannot borrow mutably</pre></div> <p>In here, <code>x</code> isn't mutable, so when we try to mutably borrow it in <code>y</code>, it fails. To fix this error, you need to make <code>x</code> mutable:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut x = 1;
let y = &amp;mut x; // ok!</pre></div>  <h3 id="E0597" class="section-header">E0597</h3> <p>This error occurs because a value was dropped while it was still borrowed</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo&lt;'a&gt; {
    x: Option&lt;&amp;'a u32&gt;,
}

let mut x = Foo { x: None };
{
    let y = 0;
    x.x = Some(&amp;y); // error: `y` does not live long enough
}
println!("{:?}", x.x);</pre></div> <p>In here, <code>y</code> is dropped at the end of the inner scope, but it is borrowed by <code>x</code> until the <code>println</code>. To fix the previous example, just remove the scope so that <code>y</code> isn't dropped until after the println</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;'a&gt; {
    x: Option&lt;&amp;'a u32&gt;,
}

let mut x = Foo { x: None };

let y = 0;
x.x = Some(&amp;y);

println!("{:?}", x.x);</pre></div>   <h3 id="E0599" class="section-header">E0599</h3> <p>This error occurs when a method is used on a type which doesn't implement it:</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Mouth;

let x = Mouth;
x.chocolate(); // error: no method named `chocolate` found for type `Mouth`
               //        in the current scope</pre></div>  <h3 id="E0600" class="section-header">E0600</h3> <p>An unary operator was used on a type which doesn't implement it.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum Question {
    Yes,
    No,
}

!Question::Yes; // error: cannot apply unary operator `!` to type `Question`</pre></div> <p>In this case, <code>Question</code> would need to implement the <code>std::ops::Not</code> trait in order to be able to use <code>!</code> on it. Let's implement it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::ops::Not;

enum Question {
    Yes,
    No,
}

// We implement the `Not` trait on the enum.
impl Not for Question {
    type Output = bool;

    fn not(self) -&gt; bool {
        match self {
            Question::Yes =&gt; false, // If the `Answer` is `Yes`, then it
                                    // returns false.
            Question::No =&gt; true, // And here we do the opposite.
        }
    }
}

assert_eq!(!Question::Yes, false);
assert_eq!(!Question::No, true);</pre></div>  <h3 id="E0601" class="section-header">E0601</h3> <p>No <code>main</code> function was found in a binary crate. To fix this error, add a <code>main</code> function. For example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    // Your program will start here.
    println!("Hello world!");
}</pre></div> <p>If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/</p>  <h3 id="E0602" class="section-header">E0602</h3> <p>An unknown lint was used on the command line.</p> <p>Erroneous example:</p> <pre>rustc -D bogus omse_file.rs
</pre> <p>Maybe you just misspelled the lint name or the lint doesn't exist anymore. Either way, try to update/remove it in order to fix the error.</p>  <h3 id="E0603" class="section-header">E0603</h3> <p>A private item was used outside its scope.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod SomeModule {
    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we
                                            // can't use it outside of the
                                            // `SomeModule` module.
}

println!("const value: {}", SomeModule::PRIVATE); // error: constant `PRIVATE`
                                                  //        is private</pre></div> <p>In order to fix this error, you need to make the item public by using the <code>pub</code> keyword. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod SomeModule {
    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the
                                                // `pub` keyword.
}

println!("const value: {}", SomeModule::PRIVATE); // ok!</pre></div>  <h3 id="E0604" class="section-header">E0604</h3> <p>A cast to <code>char</code> was attempted on a type other than <code>u8</code>.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
0u32 as char; // error: only `u8` can be cast as `char`, not `u32`</pre></div> <p>As the error message indicates, only <code>u8</code> can be cast into <code>char</code>. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let c = 86u8 as char; // ok!
assert_eq!(c, 'V');</pre></div> <p>For more information about casts, take a look at the Type cast section in <a href="../reference/expressions/operator-expr/#type-cast-expressions">The Reference Book</a>.</p>  <h3 id="E0605" class="section-header">E0605</h3> <p>An invalid cast was attempted.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = 0u8;
x as Vec&lt;u8&gt;; // error: non-primitive cast: `u8` as `std::vec::Vec&lt;u8&gt;`

// Another example

let v = core::ptr::null::&lt;u8&gt;(); // So here, `v` is a `*const u8`.
v as &amp;u8; // error: non-primitive cast: `*const u8` as `&amp;u8`</pre></div> <p>Only primitive types can be cast into each other. Examples:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = 0u8;
x as u32; // ok!

let v = core::ptr::null::&lt;u8&gt;();
v as *const i8; // ok!</pre></div> <p>For more information about casts, take a look at the Type cast section in <a href="../reference/expressions/operator-expr/#type-cast-expressions">The Reference Book</a>.</p>  <h3 id="E0606" class="section-header">E0606</h3> <p>An incompatible cast was attempted.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = &amp;0u8; // Here, `x` is a `&amp;u8`.
let y: u32 = x as u32; // error: casting `&amp;u8` as `u32` is invalid</pre></div> <p>When casting, keep in mind that only primitive types can be cast into each other. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = &amp;0u8;
let y: u32 = *x as u32; // We dereference it first and then cast it.</pre></div> <p>For more information about casts, take a look at the Type cast section in <a href="../reference/expressions/operator-expr/#type-cast-expressions">The Reference Book</a>.</p>  <h3 id="E0607" class="section-header">E0607</h3> <p>A cast between a thin and a fat pointer was attempted.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let v = core::ptr::null::&lt;u8&gt;();
v as *const [u8];</pre></div> <p>First: what are thin and fat pointers?</p> <p>Thin pointers are "simple" pointers: they are purely a reference to a memory address.</p> <p>Fat pointers are pointers referencing Dynamically Sized Types (also called DST). DST don't have a statically known size, therefore they can only exist behind some kind of pointers that contain additional information. Slices and trait objects are DSTs. In the case of slices, the additional information the fat pointer holds is their size.</p> <p>To fix this error, don't try to cast directly between thin and fat pointers.</p> <p>For more information about casts, take a look at the Type cast section in <a href="../reference/expressions/operator-expr/#type-cast-expressions">The Reference Book</a>.</p>  <h3 id="E0608" class="section-header">E0608</h3> <p>An attempt to index into a type which doesn't implement the <code>std::ops::Index</code> trait was performed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
0u8[2]; // error: cannot index into a value of type `u8`</pre></div> <p>To be able to index into a type it needs to implement the <code>std::ops::Index</code> trait. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;u8&gt; = vec![0, 1, 2, 3];

// The `Vec` type implements the `Index` trait so you can do:
println!("{}", v[2]);</pre></div>  <h3 id="E0609" class="section-header">E0609</h3> <p>Attempted to access a non-existent field in a struct.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct StructWithFields {
    x: u32,
}

let s = StructWithFields { x: 0 };
println!("{}", s.foo); // error: no field `foo` on type `StructWithFields`</pre></div> <p>To fix this error, check that you didn't misspell the field's name or that the field actually exists. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
struct StructWithFields {
    x: u32,
}

let s = StructWithFields { x: 0 };
println!("{}", s.x); // ok!</pre></div>  <h3 id="E0610" class="section-header">E0610</h3> <p>Attempted to access a field on a primitive type.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x: u32 = 0;
println!("{}", x.foo); // error: `{integer}` is a primitive type, therefore
                       //        doesn't have fields</pre></div> <p>Primitive types are the most basic types available in Rust and don't have fields. To access data via named fields, struct types are used. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// We declare struct called `Foo` containing two fields:
struct Foo {
    x: u32,
    y: i64,
}

// We create an instance of this struct:
let variable = Foo { x: 0, y: -12 };
// And we can now access its fields:
println!("x: {}, y: {}", variable.x, variable.y);</pre></div> <p>For more information about primitives and structs, take a look at The Book: https://doc.rust-lang.org/book/ch03-02-data-types.html https://doc.rust-lang.org/book/ch05-00-structs.html</p>  <h3 id="E0614" class="section-header">E0614</h3> <p>Attempted to dereference a variable which cannot be dereferenced.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let y = 0u32;
*y; // error: type `u32` cannot be dereferenced</pre></div> <p>Only types implementing <code>std::ops::Deref</code> can be dereferenced (such as <code>&amp;T</code>). Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let y = 0u32;
let x = &amp;y;
// So here, `x` is a `&amp;u32`, so we can dereference it:
*x; // ok!</pre></div>  <h3 id="E0615" class="section-header">E0615</h3> <p>Attempted to access a method like a field.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
struct Foo {
    x: u32,
}

impl Foo {
    fn method(&amp;self) {}
}

let f = Foo { x: 0 };
f.method; // error: attempted to take value of method `method` on type `Foo`</pre></div> <p>If you want to use a method, add <code>()</code> after it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
f.method();</pre></div> <p>However, if you wanted to access a field of a struct check that the field name is spelled correctly. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
println!("{}", f.x);</pre></div>  <h3 id="E0616" class="section-header">E0616</h3> <p>Attempted to access a private field on a struct.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod some_module {
    pub struct Foo {
        x: u32, // So `x` is private in here.
    }

    impl Foo {
        pub fn new() -&gt; Foo { Foo { x: 0 } }
    }
}

let f = some_module::Foo::new();
println!("{}", f.x); // error: field `x` of struct `some_module::Foo` is private</pre></div> <p>If you want to access this field, you have two options:</p> <ol> <li>Set the field public:</li> </ol> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod some_module {
    pub struct Foo {
        pub x: u32, // `x` is now public.
    }

    impl Foo {
        pub fn new() -&gt; Foo { Foo { x: 0 } }
    }
}

let f = some_module::Foo::new();
println!("{}", f.x); // ok!</pre></div> <ol start="2"> <li>Add a getter function:</li> </ol> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod some_module {
    pub struct Foo {
        x: u32, // So `x` is still private in here.
    }

    impl Foo {
        pub fn new() -&gt; Foo { Foo { x: 0 } }

        // We create the getter function here:
        pub fn get_x(&amp;self) -&gt; &amp;u32 { &amp;self.x }
    }
}

let f = some_module::Foo::new();
println!("{}", f.get_x()); // ok!</pre></div>  <h3 id="E0617" class="section-header">E0617</h3> <p>Attempted to pass an invalid type of variable into a variadic function.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
extern {
    fn printf(c: *const i8, ...);
}

unsafe {
    printf(::std::ptr::null(), 0f32);
    // error: can't pass an `f32` to variadic function, cast to `c_double`
}</pre></div> <p>Certain Rust types must be cast before passing them to a variadic function, because of arcane ABI rules dictated by the C standard. To fix the error, cast the value to the type specified by the error message (which you may need to import from <code>std::os::raw</code>).</p>  <h3 id="E0618" class="section-header">E0618</h3> <p>Attempted to call something which isn't a function nor a method.</p> <p>Erroneous code examples:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
enum X {
    Entry,
}

X::Entry(); // error: expected function, found `X::Entry`

// Or even simpler:
let x = 0i32;
x(); // error: expected function, found `i32`</pre></div> <p>Only functions and methods can be called using <code>()</code>. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// We declare a function:
fn i_am_a_function() {}

// And we call it:
i_am_a_function();</pre></div>  <h3 id="E0619" class="section-header">E0619</h3> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-27" class="section-header">Note: this error code is no longer emitted by the compiler.</h4> <p>The type-checker needed to know the type of an expression, but that type had not yet been inferred.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let mut x = vec![];
match x.pop() {
    Some(v) =&gt; {
        // Here, the type of `v` is not (yet) known, so we
        // cannot resolve this method call:
        v.to_uppercase(); // error: the type of this value must be known in
                          //        this context
    }
    None =&gt; {}
}</pre></div> <p>Type inference typically proceeds from the top of the function to the bottom, figuring out types as it goes. In some cases -- notably method calls and overloadable operators like <code>*</code> -- the type checker may not have enough information <em>yet</em> to make progress. This can be true even if the rest of the function provides enough context (because the type-checker hasn't looked that far ahead yet). In this case, type annotations can be used to help it along.</p> <p>To fix this error, just specify the type of the variable. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut x: Vec&lt;String&gt; = vec![]; // We precise the type of the vec elements.
match x.pop() {
    Some(v) =&gt; {
        v.to_uppercase(); // Since rustc now knows the type of the vec elements,
                          // we can use `v`'s methods.
    }
    None =&gt; {}
}</pre></div>  <h3 id="E0620" class="section-header">E0620</h3> <p>A cast to an unsized type was attempted.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = &amp;[1_usize, 2] as [usize]; // error: cast to unsized type: `&amp;[usize; 2]`
                                  //        as `[usize]`</pre></div> <p>In Rust, some types don't have a known size at compile-time. For example, in a slice type like <code>[u32]</code>, the number of elements is not known at compile-time and hence the overall size cannot be computed. As a result, such types can only be manipulated through a reference (e.g., <code>&amp;T</code> or <code>&amp;mut T</code>) or other pointer-type (e.g., <code>Box</code> or <code>Rc</code>). Try casting to a reference instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = &amp;[1_usize, 2] as &amp;[usize]; // ok!</pre></div>  <h3 id="E0621" class="section-header">E0621</h3> <p>This error code indicates a mismatch between the lifetimes appearing in the function signature (i.e., the parameter types and the return type) and the data-flow found in the function body.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo&lt;'a&gt;(x: &amp;'a i32, y: &amp;i32) -&gt; &amp;'a i32 { // error: explicit lifetime
                                             //        required in the type of
                                             //        `y`
    if x &gt; y { x } else { y }
}</pre></div> <p>In the code above, the function is returning data borrowed from either <code>x</code> or <code>y</code>, but the <code>'a</code> annotation indicates that it is returning data only from <code>x</code>. To fix the error, the signature and the body must be made to match. Typically, this is done by updating the function signature. So, in this case, we change the type of <code>y</code> to <code>&amp;'a i32</code>, like so:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;'a&gt;(x: &amp;'a i32, y: &amp;'a i32) -&gt; &amp;'a i32 {
    if x &gt; y { x } else { y }
}</pre></div> <p>Now the signature indicates that the function data borrowed from either <code>x</code> or <code>y</code>. Alternatively, you could change the body to not return data from <code>y</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;'a&gt;(x: &amp;'a i32, y: &amp;i32) -&gt; &amp;'a i32 {
    x
}</pre></div>  <h3 id="E0622" class="section-header">E0622</h3> <p>An intrinsic was declared without being a function.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(intrinsics)]
extern "rust-intrinsic" {
    pub static breakpoint : unsafe extern "rust-intrinsic" fn();
    // error: intrinsic must be a function
}

fn main() { unsafe { breakpoint(); } }</pre></div> <p>An intrinsic is a function available for use in a given programming language whose implementation is handled specially by the compiler. In order to fix this error, just declare a function.</p>   <h3 id="E0624" class="section-header">E0624</h3> <p>A private item was used outside of its scope.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod inner {
    pub struct Foo;

    impl Foo {
        fn method(&amp;self) {}
    }
}

let foo = inner::Foo;
foo.method(); // error: method `method` is private</pre></div> <p>Two possibilities are available to solve this issue:</p> <ol> <li>Only use the item in the scope it has been defined:</li> </ol> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod inner {
    pub struct Foo;

    impl Foo {
        fn method(&amp;self) {}
    }

    pub fn call_method(foo: &amp;Foo) { // We create a public function.
        foo.method(); // Which calls the item.
    }
}

let foo = inner::Foo;
inner::call_method(&amp;foo); // And since the function is public, we can call the
                          // method through it.</pre></div> <ol start="2"> <li>Make the item public:</li> </ol> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod inner {
    pub struct Foo;

    impl Foo {
        pub fn method(&amp;self) {} // It's now public.
    }
}

let foo = inner::Foo;
foo.method(); // Ok!</pre></div>   <h3 id="E0626" class="section-header">E0626</h3> <p>This error occurs because a borrow in a generator persists across a yield point.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let mut b = || {
    let a = &amp;String::new(); // &lt;-- This borrow...
    yield (); // ...is still in scope here, when the yield occurs.
    println!("{}", a);
};
Pin::new(&amp;mut b).resume();</pre></div> <p>At present, it is not permitted to have a yield that occurs while a borrow is still in scope. To resolve this error, the borrow must either be "contained" to a smaller scope that does not overlap the yield or else eliminated in another way. So, for example, we might resolve the previous example by removing the borrow and just storing the integer by value:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut b = || {
    let a = 3;
    yield ();
    println!("{}", a);
};
Pin::new(&amp;mut b).resume();</pre></div> <p>This is a very simple case, of course. In more complex cases, we may wish to have more than one reference to the value that was borrowed -- in those cases, something like the <code>Rc</code> or <code>Arc</code> types may be useful.</p> <p>This error also frequently arises with iteration:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let mut b = || {
  let v = vec![1,2,3];
  for &amp;x in &amp;v { // &lt;-- borrow of `v` is still in scope...
    yield x; // ...when this yield occurs.
  }
};
Pin::new(&amp;mut b).resume();</pre></div> <p>Such cases can sometimes be resolved by iterating "by value" (or using <code>into_iter()</code>) to avoid borrowing:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut b = || {
  let v = vec![1,2,3];
  for x in v { // &lt;-- Take ownership of the values instead!
    yield x; // &lt;-- Now yield is OK.
  }
};
Pin::new(&amp;mut b).resume();</pre></div> <p>If taking ownership is not an option, using indices can work too:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut b = || {
  let v = vec![1,2,3];
  let len = v.len(); // (*)
  for i in 0..len {
    let x = v[i]; // (*)
    yield x; // &lt;-- Now yield is OK.
  }
};
Pin::new(&amp;mut b).resume();

// (*) -- Unfortunately, these temporaries are currently required.
// See &lt;https://github.com/rust-lang/rust/issues/43122&gt;.</pre></div>        <h3 id="E0633" class="section-header">E0633</h3> <p>The <code>unwind</code> attribute was malformed.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#[unwind()] // error: expected one argument
pub extern fn something() {}

fn main() {}</pre></div> <p>The <code>#[unwind]</code> attribute should be used as follows:</p> <ul> <li> <p><code>#[unwind(aborts)]</code> -- specifies that if a non-Rust ABI function should abort the process if it attempts to unwind. This is the safer and preferred option.</p> </li> <li> <p><code>#[unwind(allowed)]</code> -- specifies that a non-Rust ABI function should be allowed to unwind. This can easily result in Undefined Behavior (UB), so be careful.</p> </li> </ul> <p>NB. The default behavior here is "allowed", but this is unspecified and likely to change in the future.</p>   <h3 id="E0635" class="section-header">E0635</h3> <p>The <code>#![feature]</code> attribute specified an unknown feature.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(nonexistent_rust_feature)] // error: unknown feature</pre></div>  <h3 id="E0636" class="section-header">E0636</h3> <p>A <code>#![feature]</code> attribute was declared multiple times.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![allow(stable_features)]
#![feature(rust1)]
#![feature(rust1)] // error: the feature `rust1` has already been declared</pre></div>   <h3 id="E0638" class="section-header">E0638</h3> <p>This error indicates that the struct, enum or enum variant must be matched non-exhaustively as it has been marked as <code>non_exhaustive</code>.</p> <p>When applied within a crate, downstream users of the crate will need to use the <code>_</code> pattern when matching enums and use the <code>..</code> pattern when matching structs. Downstream crates cannot match against non-exhaustive enum variants.</p> <p>For example, in the below example, since the enum is marked as <code>non_exhaustive</code>, it is required that downstream crates match non-exhaustively on it.</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
use std::error::Error as StdError;

#[non_exhaustive] pub enum Error {
   Message(String),
   Other,
}

impl StdError for Error {
   fn description(&amp;self) -&gt; &amp;str {
        // This will not error, despite being marked as non_exhaustive, as this
        // enum is defined within the current crate, it can be matched
        // exhaustively.
        match *self {
           Message(ref s) =&gt; s,
           Other =&gt; "other or unknown error",
        }
   }
}</pre></div> <p>An example of matching non-exhaustively on the above enum is provided below:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
use mycrate::Error;

// This will not error as the non_exhaustive Error enum has been matched with a
// wildcard.
match error {
   Message(ref s) =&gt; ...,
   Other =&gt; ...,
   _ =&gt; ...,
}</pre></div> <p>Similarly, for structs, match with <code>..</code> to avoid this error.</p>  <h3 id="E0639" class="section-header">E0639</h3> <p>This error indicates that the struct, enum or enum variant cannot be instantiated from outside of the defining crate as it has been marked as <code>non_exhaustive</code> and as such more fields/variants may be added in future that could cause adverse side effects for this code.</p> <p>It is recommended that you look for a <code>new</code> function or equivalent in the crate's documentation.</p>    <h3 id="E0642" class="section-header">E0642</h3> <p>Trait methods currently cannot take patterns as arguments.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo((x, y): (i32, i32)); // error: patterns aren't allowed
                                //        in trait methods
}</pre></div> <p>You can instead use a single name for the argument:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn foo(x_and_y: (i32, i32)); // ok!
}</pre></div>  <h3 id="E0643" class="section-header">E0643</h3> <p>This error indicates that there is a mismatch between generic parameters and impl Trait parameters in a trait declaration versus its impl.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait Foo {
    fn foo(&amp;self, _: &amp;impl Iterator);
}
impl Foo for () {
    fn foo&lt;U: Iterator&gt;(&amp;self, _: &amp;U) { } // error method `foo` has incompatible
                                          // signature for trait
}</pre></div>  <h3 id="E0644" class="section-header">E0644</h3> <p>A closure or generator was constructed that references its own type.</p> <p>Erroneous example:</p> <pre>fn fix&lt;F&gt;(f: &amp;F)
  where F: Fn(&amp;F)
{
  f(&amp;f);
}

fn main() {
  fix(&amp;|y| {
    // Here, when `x` is called, the parameter `y` is equal to `x`.
  });
}
</pre> <p>Rust does not permit a closure to directly reference its own type, either through an argument (as in the example above) or by capturing itself through its environment. This restriction helps keep closure inference tractable.</p> <p>The easiest fix is to rewrite your closure into a top-level function, or into a method. In some cases, you may also be able to have your closure call itself by capturing a <code>&amp;Fn()</code> object or <code>fn()</code> pointer that refers to itself. That is permitting, since the closure would be invoking itself via a virtual call, and hence does not directly reference its own <em>type</em>.</p>   <h3 id="E0646" class="section-header">E0646</h3> <p>It is not possible to define <code>main</code> with a where clause. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn main() where i32: Copy { // error: main function is not allowed to have
                            // a where clause
}</pre></div>  <h3 id="E0647" class="section-header">E0647</h3> <p>It is not possible to define <code>start</code> with a where clause. Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(start)]

#[start]
fn start(_: isize, _: *const *const u8) -&gt; isize where (): Copy {
    //^ error: start function is not allowed to have a where clause
    0
}</pre></div>  <h3 id="E0648" class="section-header">E0648</h3> <p><code>export_name</code> attributes may not contain null characters (<code>\0</code>).</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[export_name="\0foo"] // error: `export_name` may not contain null characters
pub fn bar() {}</pre></div>   <h3 id="E0658" class="section-header">E0658</h3> <p>An unstable feature was used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(u128)] // error: use of unstable library feature 'repr128'
enum Foo {
    Bar(u64),
}</pre></div> <p>If you're using a stable or a beta version of rustc, you won't be able to use any unstable features. In order to do so, please switch to a nightly version of rustc (by using rustup).</p> <p>If you're using a nightly version of rustc, just add the corresponding feature to be able to use it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr128)]

#[repr(u128)] // ok!
enum Foo {
    Bar(u64),
}</pre></div>  <h3 id="E0659" class="section-header">E0659</h3> <p>An item usage is ambiguous.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
pub mod moon {
    pub fn foo() {}
}

pub mod earth {
    pub fn foo() {}
}

mod collider {
    pub use moon::*;
    pub use earth::*;
}

fn main() {
    collider::foo(); // ERROR: `foo` is ambiguous
}</pre></div> <p>This error generally appears when two items with the same name are imported into a module. Here, the <code>foo</code> functions are imported and reexported from the <code>collider</code> module and therefore, when we're using <code>collider::foo()</code>, both functions collide.</p> <p>To solve this error, the best solution is generally to keep the path before the item when using it. Example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
pub mod moon {
    pub fn foo() {}
}

pub mod earth {
    pub fn foo() {}
}

mod collider {
    pub use moon;
    pub use earth;
}

fn main() {
    collider::moon::foo(); // ok!
    collider::earth::foo(); // ok!
}</pre></div>    <h3 id="E0668" class="section-header">E0668</h3> <p>Malformed inline assembly rejected by LLVM.</p> <p>LLVM checks the validity of the constraints and the assembly string passed to it. This error implies that LLVM seems something wrong with the inline assembly call.</p> <p>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430):</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#![feature(asm)]

fn main() {
    let rax: u64;
    unsafe {
        asm!("" :"={rax"(rax));
        println!("Accumulator is: {}", rax);
    }
}</pre></div>  <h3 id="E0669" class="section-header">E0669</h3> <p>Cannot convert inline assembly operand to a single LLVM value.</p> <p>This error usually happens when trying to pass in a value to an input inline assembly operand that is actually a pair of values. In particular, this can happen when trying to pass in a slice, for instance a <code>&amp;str</code>. In Rust, these values are represented internally as a pair of values, the pointer and its length. When passed as an input operand, this pair of values can not be coerced into a register and thus we must fail with an error.</p>  <h3 id="E0670" class="section-header">E0670</h3> <p>Rust 2015 does not permit the use of <code>async fn</code>.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
async fn foo() {}</pre></div> <p>Switch to the Rust 2018 edition to use <code>async fn</code>.</p>  <h3 id="E0671" class="section-header">E0671</h3> <p>Const parameters cannot depend on type parameters. The following is therefore invalid:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(const_generics)]

fn const_id&lt;T, const N: T&gt;() -&gt; T { // error: const parameter
                                    // depends on type parameter
    N
}</pre></div>    <h3 id="E0689" class="section-header">E0689</h3> <p>This error indicates that the numeric value for the method being passed exists but the type of the numeric value or binding could not be identified.</p> <p>The error happens on numeric literals:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
2.0.neg();</pre></div> <p>and on numeric bindings without an identified concrete type:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let x = 2.0;
x.neg();  // same error as above</pre></div> <p>Because of this, you must give the numeric literal or binding a type:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::ops::Neg;

let _ = 2.0_f32.neg();
let x: f32 = 2.0;
let _ = x.neg();
let _ = (2.0 as f32).neg();</pre></div>  <h3 id="E0690" class="section-header">E0690</h3> <p>A struct with the representation hint <code>repr(transparent)</code> had zero or more than one fields that were not guaranteed to be zero-sized.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(transparent)]
struct LengthWithUnit&lt;U&gt; { // error: transparent struct needs exactly one
    value: f32,            //        non-zero-sized field, but has 2
    unit: U,
}</pre></div> <p>Because transparent structs are represented exactly like one of their fields at run time, said field must be uniquely determined. If there is no field, or if there are multiple fields, it is not clear how the struct should be represented. Note that fields of zero-typed types (e.g., <code>PhantomData</code>) can also exist alongside the field that contains the actual data, they do not count for this error. When generic types are involved (as in the above example), an error is reported because the type parameter could be non-zero-sized.</p> <p>To combine <code>repr(transparent)</code> with type parameters, <code>PhantomData</code> may be useful:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::marker::PhantomData;

#[repr(transparent)]
struct LengthWithUnit&lt;U&gt; {
    value: f32,
    unit: PhantomData&lt;U&gt;,
}</pre></div>  <h3 id="E0691" class="section-header">E0691</h3> <p>A struct, enum, or union with the <code>repr(transparent)</code> representation hint contains a zero-sized field that requires non-trivial alignment.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(repr_align)]

#[repr(align(32))]
struct ForceAlign32;

#[repr(transparent)]
struct Wrapper(f32, ForceAlign32); // error: zero-sized field in transparent
                                   //        struct has alignment larger than 1</pre></div> <p>A transparent struct, enum, or union is supposed to be represented exactly like the piece of data it contains. Zero-sized fields with different alignment requirements potentially conflict with this property. In the example above, <code>Wrapper</code> would have to be aligned to 32 bytes even though <code>f32</code> has a smaller alignment requirement.</p> <p>Consider removing the over-aligned zero-sized field:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(transparent)]
struct Wrapper(f32);</pre></div> <p>Alternatively, <code>PhantomData&lt;T&gt;</code> has alignment 1 for all <code>T</code>, so you can use it if you need to keep the field for some reason:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_align)]

use std::marker::PhantomData;

#[repr(align(32))]
struct ForceAlign32;

#[repr(transparent)]
struct Wrapper(f32, PhantomData&lt;ForceAlign32&gt;);</pre></div> <p>Note that empty arrays <code>[T; 0]</code> have the same alignment requirement as the element type <code>T</code>. Also note that the error is conservatively reported even when the alignment of the zero-sized type is less than or equal to the data field's alignment.</p>  <h3 id="E0692" class="section-header">E0692</h3> <p>A <code>repr(transparent)</code> type was also annotated with other, incompatible representation hints.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(transparent, C)] // error: incompatible representation hints
struct Grams(f32);</pre></div> <p>A type annotated as <code>repr(transparent)</code> delegates all representation concerns to another type, so adding more representation hints is contradictory. Remove either the <code>transparent</code> hint or the other hints, like this:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(transparent)]
struct Grams(f32);</pre></div> <p>Alternatively, move the other attributes to the contained type:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(C)]
struct Foo {
    x: i32,
    // ...
}

#[repr(transparent)]
struct FooWrapper(Foo);</pre></div> <p>Note that introducing another <code>struct</code> just to have a place for the other attributes may have unintended side effects on the representation:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#[repr(transparent)]
struct Grams(f32);

#[repr(C)]
struct Float(f32);

#[repr(transparent)]
struct Grams2(Float); // this is not equivalent to `Grams` above</pre></div> <p>Here, <code>Grams2</code> is a not equivalent to <code>Grams</code> -- the former transparently wraps a (non-transparent) struct containing a single float, while <code>Grams</code> is a transparent wrapper around a float. This can make a difference for the ABI.</p>    <h3 id="E0695" class="section-header">E0695</h3> <p>A <code>break</code> statement without a label appeared inside a labeled block.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
loop {
    'a: {
        break;
    }
}</pre></div> <p>Make sure to always label the <code>break</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
'l: loop {
    'a: {
        break 'l;
    }
}</pre></div> <p>Or if you want to <code>break</code> the labeled block:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
loop {
    'a: {
        break 'a;
    }
    break;
}</pre></div>    <h3 id="E0698" class="section-header">E0698</h3> <p>When using generators (or async) all type variables must be bound so a generator can be constructed.</p> <p>Erroneous code example:</p> <pre>#![feature(futures_api, async_await, await_macro)]
async fn bar&lt;T&gt;() -&gt; () {}

async fn foo() {
  await!(bar());  // error: cannot infer type for `T`
}
</pre> <p>In the above example <code>T</code> is unknowable by the compiler. To fix this you must bind <code>T</code> to a concrete type such as <code>String</code> so that a generator can then be constructed:</p> <div class="information">ⓘThis code runs with edition 2018</div>
<div class="example-wrap"><pre class="rust rust-example-rendered edition " data-language="rust">
#![feature(futures_api, async_await, await_macro)]
async fn bar&lt;T&gt;() -&gt; () {}

async fn foo() {
  await!(bar::&lt;String&gt;());
  //          ^^^^^^^^ specify type explicitly
}</pre></div>  <h3 id="E0699" class="section-header">E0699</h3> <p>A method was called on a raw pointer whose inner type wasn't completely known.</p> <p>For example, you may have done something like:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let foo = &amp;1;
let bar = foo as *const _;
if bar.is_null() {
    // ...
}</pre></div> <p>Here, the type of <code>bar</code> isn't known; it could be a pointer to anything. Instead, specify a type for the pointer (preferably something that makes sense for the thing you're pointing to):</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let foo = &amp;1;
let bar = foo as *const i32;
if bar.is_null() {
    // ...
}</pre></div> <p>Even though <code>is_null()</code> exists as a method on any raw pointer, Rust shows this error because Rust allows for <code>self</code> to have arbitrary types (behind the arbitrary_self_types feature flag).</p> <p>This means that someone can specify such a function:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
impl Foo {
    fn is_null(self: *const Self) -&gt; bool {
        // do something else
    }
}</pre></div> <p>and now when you call <code>.is_null()</code> on a raw pointer to <code>Foo</code>, there's ambiguity.</p> <p>Given that we don't know what type the pointer is, and there's potential ambiguity for some types, we disallow calling methods on raw pointers when the type is unknown.</p>  <h3 id="E0700" class="section-header">E0700</h3> <p>The <code>impl Trait</code> return type captures lifetime parameters that do not appear within the <code>impl Trait</code> itself.</p> <p>Erroneous code example:</p> <pre>use std::cell::Cell;

trait Trait&lt;'a&gt; { }

impl&lt;'a, 'b&gt; Trait&lt;'b&gt; for Cell&lt;&amp;'a u32&gt; { }

fn foo&lt;'x, 'y&gt;(x: Cell&lt;&amp;'x u32&gt;) -&gt; impl Trait&lt;'y&gt;
where 'x: 'y
{
    x
}
</pre> <p>Here, the function <code>foo</code> returns a value of type <code>Cell&lt;&amp;'x u32&gt;</code>, which references the lifetime <code>'x</code>. However, the return type is declared as <code>impl Trait&lt;'y&gt;</code> -- this indicates that <code>foo</code> returns "some type that implements <code>Trait&lt;'y&gt;</code>", but it also indicates that the return type <strong>only captures data referencing the lifetime <code>'y</code></strong>. In this case, though, we are referencing data with lifetime <code>'x</code>, so this function is in error.</p> <p>To fix this, you must reference the lifetime <code>'x</code> from the return type. For example, changing the return type to <code>impl Trait&lt;'y&gt; + 'x</code> would work:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::Cell;

trait Trait&lt;'a&gt; { }

impl&lt;'a,'b&gt; Trait&lt;'b&gt; for Cell&lt;&amp;'a u32&gt; { }

fn foo&lt;'x, 'y&gt;(x: Cell&lt;&amp;'x u32&gt;) -&gt; impl Trait&lt;'y&gt; + 'x
where 'x: 'y
{
    x
}</pre></div>  <h3 id="E0701" class="section-header">E0701</h3> <p>This error indicates that a <code>#[non_exhaustive]</code> attribute was incorrectly placed on something other than a struct or enum.</p> <p>Examples of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">

#[non_exhaustive]
trait Foo { }</pre></div>   <h3 id="E0704" class="section-header">E0704</h3> <p>This error indicates that a incorrect visibility restriction was specified.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
mod foo {
    pub(foo) struct Bar {
        x: i32
    }
}</pre></div> <p>To make struct <code>Bar</code> only visible in module <code>foo</code> the <code>in</code> keyword should be used:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
mod foo {
    pub(in crate::foo) struct Bar {
        x: i32
    }
}</pre></div> <p>For more information see the Rust Reference on <a href="../reference/visibility-and-privacy/">Visibility</a>.</p>  <h3 id="E0705" class="section-header">E0705</h3> <p>A <code>#![feature]</code> attribute was declared for a feature that is stable in the current edition, but not in all editions.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#![feature(rust_2018_preview)]
#![feature(test_2018_feature)] // error: the feature
                               // `test_2018_feature` is
                               // included in the Rust 2018 edition</pre></div>        <h3 id="E0712" class="section-header">E0712</h3> <p>This error occurs because a borrow of a thread-local variable was made inside a function which outlived the lifetime of the function.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(nll)]
#![feature(thread_local)]

#[thread_local]
static FOO: u8 = 3;

fn main() {
    let a = &amp;FOO; // error: thread-local variable borrowed past end of function

    std::thread::spawn(move || {
        println!("{}", a);
    });
}</pre></div>  <h3 id="E0713" class="section-header">E0713</h3> <p>This error occurs when an attempt is made to borrow state past the end of the lifetime of a type that implements the <code>Drop</code> trait.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(nll)]

pub struct S&lt;'a&gt; { data: &amp;'a mut String }

impl&lt;'a&gt; Drop for S&lt;'a&gt; {
    fn drop(&amp;mut self) { self.data.push_str("being dropped"); }
}

fn demo&lt;'a&gt;(s: S&lt;'a&gt;) -&gt; &amp;'a mut String { let p = &amp;mut *s.data; p }</pre></div> <p>Here, <code>demo</code> tries to borrow the string data held within its argument <code>s</code> and then return that borrow. However, <code>S</code> is declared as implementing <code>Drop</code>.</p> <p>Structs implementing the <code>Drop</code> trait have an implicit destructor that gets called when they go out of scope. This destructor gets exclusive access to the fields of the struct when it runs.</p> <p>This means that when <code>s</code> reaches the end of <code>demo</code>, its destructor gets exclusive access to its <code>&amp;mut</code>-borrowed string data. allowing another borrow of that string data (<code>p</code>), to exist across the drop of <code>s</code> would be a violation of the principle that <code>&amp;mut</code>-borrows have exclusive, unaliased access to their referenced data.</p> <p>This error can be fixed by changing <code>demo</code> so that the destructor does not run while the string-data is borrowed; for example by taking <code>S</code> by reference:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(nll)]

pub struct S&lt;'a&gt; { data: &amp;'a mut String }

impl&lt;'a&gt; Drop for S&lt;'a&gt; {
    fn drop(&amp;mut self) { self.data.push_str("being dropped"); }
}

fn demo&lt;'a&gt;(s: &amp;'a mut S&lt;'a&gt;) -&gt; &amp;'a mut String { let p = &amp;mut *(*s).data; p }</pre></div> <p>Note that this approach needs a reference to S with lifetime <code>'a</code>. Nothing shorter than <code>'a</code> will suffice: a shorter lifetime would imply that after <code>demo</code> finishes executing, something else (such as the destructor!) could access <code>s.data</code> after the end of that shorter lifetime, which would again violate the <code>&amp;mut</code>-borrow's exclusive access.</p>  <h3 id="E0714" class="section-header">E0714</h3> <p>A <code>#[marker]</code> trait contained an associated item.</p> <p>The items of marker traits cannot be overridden, so there's no need to have them when they cannot be changed per-type anyway. If you wanted them for ergonomic reasons, consider making an extension trait instead.</p>  <h3 id="E0715" class="section-header">E0715</h3> <p>An <code>impl</code> for a <code>#[marker]</code> trait tried to override an associated item.</p> <p>Because marker traits are allowed to have multiple implementations for the same type, it's not allowed to override anything in those implementations, as it would be ambiguous which override should actually be used.</p>  <h3 id="E0716" class="section-header">E0716</h3> <p>This error indicates that a temporary value is being dropped while a borrow is still in active use.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn foo() -&gt; i32 { 22 }
fn bar(x: &amp;i32) -&gt; &amp;i32 { x }
let p = bar(&amp;foo());
         // ------ creates a temporary
let q = *p;</pre></div> <p>Here, the expression <code>&amp;foo()</code> is borrowing the expression <code>foo()</code>. As <code>foo()</code> is a call to a function, and not the name of a variable, this creates a <strong>temporary</strong> -- that temporary stores the return value from <code>foo()</code> so that it can be borrowed. You could imagine that <code>let p = bar(&amp;foo());</code> is equivalent to this:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let p = {
  let tmp = foo(); // the temporary
  bar(&amp;tmp)
}; // &lt;-- tmp is freed as we exit this block
let q = p;</pre></div> <p>Whenever a temporary is created, it is automatically dropped (freed) according to fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing statement -- in this case, after the <code>let</code>. This is illustrated in the example above by showing that <code>tmp</code> would be freed as we exit the block.</p> <p>To fix this problem, you need to create a local variable to store the value in rather than relying on a temporary. For example, you might change the original program to the following:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo() -&gt; i32 { 22 }
fn bar(x: &amp;i32) -&gt; &amp;i32 { x }
let value = foo(); // dropped at the end of the enclosing block
let p = bar(&amp;value);
let q = *p;</pre></div> <p>By introducing the explicit <code>let value</code>, we allocate storage that will last until the end of the enclosing block (when <code>value</code> goes out of scope). When we borrow <code>&amp;value</code>, we are borrowing a local variable that already exists, and hence no temporary is created.</p> <p>Temporaries are not always dropped at the end of the enclosing statement. In simple cases where the <code>&amp;</code> expression is immediately stored into a variable, the compiler will automatically extend the lifetime of the temporary until the end of the enclosing block. Therefore, an alternative way to fix the original program is to write <code>let tmp = &amp;foo()</code> and not <code>let tmp = foo()</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn foo() -&gt; i32 { 22 }
fn bar(x: &amp;i32) -&gt; &amp;i32 { x }
let value = &amp;foo();
let p = bar(value);
let q = *p;</pre></div> <p>Here, we are still borrowing <code>foo()</code>, but as the borrow is assigned directly into a variable, the temporary will not be dropped until the end of the enclosing block. Similar rules apply when temporaries are stored into aggregate structures like a tuple or struct:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// Here, two temporaries are created, but
// as they are stored directly into `value`,
// they are not dropped until the end of the
// enclosing block.
fn foo() -&gt; i32 { 22 }
let value = (&amp;foo(), &amp;foo());</pre></div>   <h3 id="E0718" class="section-header">E0718</h3> <p>This error indicates that a <code>#[lang = ".."]</code> attribute was placed on the wrong type of item.</p> <p>Examples of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(lang_items)]

#[lang = "arc"]
static X: u32 = 42;</pre></div>   <h3 id="E0720" class="section-header">E0720</h3> <p>An <code>impl Trait</code> type expands to a recursive type.</p> <p>An <code>impl Trait</code> type must be expandable to a concrete type that contains no <code>impl Trait</code> types. For example the following example tries to create an <code>impl Trait</code> type <code>T</code> that is equal to <code>[T, T]</code>:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
fn make_recursive_type() -&gt; impl Sized {
    [make_recursive_type(), make_recursive_type()]
}</pre></div>   <h3 id="E0723" class="section-header">E0723</h3> <p>An feature unstable in <code>const</code> contexts was used.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait T {}

impl T for () {}

const fn foo() -&gt; impl T { // error: `impl Trait` in const fn is unstable
    ()
}</pre></div> <p>To enable this feature on a nightly version of rustc, add the <code>const_fn</code> feature flag:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(const_fn)]

trait T {}

impl T for () {}

const fn foo() -&gt; impl T {
    ()
}</pre></div>   <h3 id="E0725" class="section-header">E0725</h3> <p>A feature attribute named a feature that was disallowed in the compiler command line flags.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
#![feature(never_type)] // error: the feature `never_type` is not in
                        // the list of allowed features</pre></div> <p>Delete the offending feature attribute, or add it to the list of allowed features in the <code>-Z allow_features</code> flag.</p>     <h3 id="E0729" class="section-header">E0729</h3> <p>Support for Non-Lexical Lifetimes (NLL) has been included in the Rust compiler since 1.31, and has been enabled on the 2015 edition since 1.36. The new borrow checker for NLL uncovered some bugs in the old borrow checker, which in some cases allowed unsound code to compile, resulting in memory safety issues.</p> <h3 id="what-do-i-do" class="section-header">What do I do?</h3> <p>Change your code so the warning does no longer trigger. For backwards compatibility, this unsound code may still compile (with a warning) right now. However, at some point in the future, the compiler will no longer accept this code and will throw a hard error.</p> <h3 id="shouldnt-you-fix-the-old-borrow-checker" class="section-header">Shouldn't you fix the old borrow checker?</h3> <p>The old borrow checker has known soundness issues that are basically impossible to fix. The new NLL-based borrow checker is the fix.</p> <h3 id="can-i-turn-these-warnings-into-errors-by-denying-a-lint" class="section-header">Can I turn these warnings into errors by denying a lint?</h3> <p>No.</p> <h3 id="when-are-these-warnings-going-to-turn-into-errors" class="section-header">When are these warnings going to turn into errors?</h3> <p>No formal timeline for turning the warnings into errors has been set. See <a href="https://github.com/rust-lang/rust/issues/58781" target="_blank">GitHub issue 58781</a> for more information.</p> <h3 id="why-do-i-get-this-message-with-code-that-doesnt-involve-borrowing" class="section-header">Why do I get this message with code that doesn't involve borrowing?</h3> <p>There are some known bugs that trigger this message.</p>  <h3 id="E0730" class="section-header">E0730</h3> <p>An array without a fixed length was pattern-matched.</p> <p>Example of erroneous code:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#![feature(const_generics)]

fn is_123&lt;const N: usize&gt;(x: [u32; N]) -&gt; bool {
    match x {
        [1, 2, 3] =&gt; true, // error: cannot pattern-match on an
                           //        array without a fixed length
        _ =&gt; false
    }
}</pre></div> <p>Ensure that the pattern is consistent with the size of the matched array. Additional elements can be matched with <code>..</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(slice_patterns)]

let r = &amp;[1, 2, 3, 4];
match r {
    &amp;[a, b, ..] =&gt; { // ok!
        println!("a={}, b={}", a, b);
    }
}</pre></div>  <h3 id="E0731" class="section-header">E0731</h3> <p>An enum with the representation hint <code>repr(transparent)</code> had zero or more than one variants.</p> <p>Erroneous code example:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
#[repr(transparent)]
enum Status { // error: transparent enum needs exactly one variant, but has 2
    Errno(u32),
    Ok,
}</pre></div> <p>Because transparent enums are represented exactly like one of their variants at run time, said variant must be uniquely determined. If there is no variant, or if there are multiple variants, it is not clear how the enum should be represented.</p>  <h3 id="E0732" class="section-header">E0732</h3> <p>An <code>enum</code> with a discriminant must specify a <code>#[repr(inttype)]</code>.</p> <p>A <code>#[repr(inttype)]</code> must be provided on an <code>enum</code> if it has a non-unit variant with a discriminant, or where there are both unit variants with discriminants and non-unit variants. This restriction ensures that there is a well-defined way to extract a variant's discriminant from a value; for instance:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(arbitrary_enum_discriminant)]

#[repr(u8)]
enum Enum {
    Unit = 3,
    Tuple(u16) = 2,
    Struct {
        a: u8,
        b: u16,
    } = 1,
}

fn discriminant(v : &amp;Enum) -&gt; u8 {
    unsafe { *(v as *const Enum as *const u8) }
}

assert_eq!(3, discriminant(&amp;Enum::Unit));
assert_eq!(2, discriminant(&amp;Enum::Tuple(5)));
assert_eq!(1, discriminant(&amp;Enum::Struct{a: 7, b: 11}));</pre></div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error-index.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/error-index.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
