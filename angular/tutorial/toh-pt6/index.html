
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>6. HTTP - Angular - W3cubDocs</title>
  
  <meta name="description" content=" In this tutorial, you&#39;ll add the following data persistence features with help from Angular&#39;s HttpClient. ">
  <meta name="keywords" content="http, -, angular">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/angular/tutorial/toh-pt6/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/angular.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/angular/" class="_nav-link" title="" style="margin-left:0;">Angular</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _angular">
				
				
<h1 id="http">HTTP</h1> <p>In this tutorial, you'll add the following data persistence features with help from Angular's <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code>.</p> <ul> <li>The <code>HeroService</code> gets hero data with HTTP requests.</li> <li>Users can add, edit, and delete heroes and save these changes over HTTP.</li> <li>Users can search for heroes by name.</li> </ul> <p>When you're done with this page, the app should look like this live example.</p> <h2 id="enable-http-services">Enable HTTP services</h2> <p><code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> is Angular's mechanism for communicating with a remote server over HTTP.</p> <p>Make <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> available everywhere in the app in two steps. First, add it to the root <code>AppModule</code> by importing it:</p> <pre header="src/app/app.module.ts (HttpClientModule import)" data-language="typescript">import { HttpClientModule }    from '@angular/common/http';</pre> <p>Next, still in the <code>AppModule</code>, add <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> to the <code>imports</code> array:</p> <pre header="src/app/app.module.ts (imports array excerpt)" data-language="typescript">@NgModule({
  imports: [
    HttpClientModule,
  ],
})</pre> <h2 id="simulate-a-data-server">Simulate a data server</h2> <p>This tutorial sample mimics communication with a remote data server by using the <a href="https://github.com/angular/in-memory-web-api" title="In-memory Web API" target="_blank">In-memory Web API</a> module.</p> <p>After installing the module, the app will make requests to and receive responses from the <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> without knowing that the <em>In-memory Web API</em> is intercepting those requests, applying them to an in-memory data store, and returning simulated responses.</p> <p>By using the In-memory Web API, you won't have to set up a server to learn about <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code>.</p> <blockquote class="alert is-important"> <p><strong>Important:</strong> the In-memory Web API module has nothing to do with HTTP in Angular.</p> <p>If you're just reading this tutorial to learn about <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code>, you can <a href="../toh-pt6/#import-heroes">skip over</a> this step. If you're coding along with this tutorial, stay here and add the In-memory Web API now.</p> </blockquote> <p>Install the In-memory Web API package from npm with the following command:</p> <pre data-language="sh">npm install angular-in-memory-web-api --save</pre> <p>In the <code>AppModule</code>, import the <code>HttpClientInMemoryWebApiModule</code> and the <code>InMemoryDataService</code> class, which you will create in a moment.</p> <pre header="src/app/app.module.ts (In-memory Web API imports)" data-language="typescript">import { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';
import { InMemoryDataService }  from './in-memory-data.service';</pre> <p>After the <code><a href="../../api/common/http/httpclientmodule/" class="code-anchor">HttpClientModule</a></code>, add the <code>HttpClientInMemoryWebApiModule</code> to the <code>AppModule</code> <code>imports</code> array and configure it with the <code>InMemoryDataService</code>.</p> <pre header="src/app/app.module.ts (imports array excerpt)" data-language="typescript">HttpClientModule,

// The HttpClientInMemoryWebApiModule module intercepts HTTP requests
// and returns simulated server responses.
// Remove it when a real server is ready to receive requests.
HttpClientInMemoryWebApiModule.forRoot(
  InMemoryDataService, { dataEncapsulation: false }
)</pre> <p>The <code><a href="../../api/router/routermodule/#forRoot" class="code-anchor">forRoot()</a></code> configuration method takes an <code>InMemoryDataService</code> class that primes the in-memory database.</p> <p>Generate the class <code>src/app/in-memory-data.service.ts</code> with the following command:</p> <pre data-language="sh">ng generate service InMemoryData</pre> <p>Replace the default contents of <code>in-memory-data.service.ts</code> with the following:</p> <pre header="src/app/in-memory-data.service.ts" data-language="typescript">import { InMemoryDbService } from 'angular-in-memory-web-api';
import { Hero } from './hero';
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class InMemoryDataService implements InMemoryDbService {
  createDb() {
    const heroes = [
      { id: 11, name: 'Dr Nice' },
      { id: 12, name: 'Narco' },
      { id: 13, name: 'Bombasto' },
      { id: 14, name: 'Celeritas' },
      { id: 15, name: 'Magneta' },
      { id: 16, name: 'RubberMan' },
      { id: 17, name: 'Dynama' },
      { id: 18, name: 'Dr IQ' },
      { id: 19, name: 'Magma' },
      { id: 20, name: 'Tornado' }
    ];
    return {heroes};
  }

  // Overrides the genId method to ensure that a hero always has an id.
  // If the heroes array is empty,
  // the method below returns the initial number (11).
  // if the heroes array is not empty, the method below returns the highest
  // hero id + 1.
  genId(heroes: Hero[]): number {
    return heroes.length &gt; 0 ? Math.max(...heroes.map(hero =&gt; hero.id)) + 1 : 11;
  }
}</pre> <p>The <code>in-memory-data.service.ts</code> file replaces <code>mock-heroes.ts</code>, which is now safe to delete.</p> <p>When the server is ready, you'll detach the In-memory Web API, and the app's requests will go through to the server.</p>  <h2 id="heroes-and-http">Heroes and HTTP</h2> <p>In the <code>HeroService</code>, import <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> and <code><a href="../../api/common/http/httpheaders/" class="code-anchor">HttpHeaders</a></code>:</p> <pre header="src/app/hero.service.ts (import HTTP symbols)" data-language="typescript">import { HttpClient, HttpHeaders } from '@angular/common/http';</pre> <p>Still in the <code>HeroService</code>, inject <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> into the constructor in a private property called <code><a href="../../api/common/http/" class="code-anchor">http</a></code>.</p> <pre header="src/app/hero.service.ts" data-language="typescript">constructor(
  private http: HttpClient,
  private messageService: MessageService) { }</pre> <p>Notice that you keep injecting the <code>MessageService</code> but since you'll call it so frequently, wrap it in a private <code><a href="../../api/animations/browser/testing/mockanimationdriver/#log" class="code-anchor">log</a>()</code> method:</p> <pre header="src/app/hero.service.ts" data-language="typescript">/** Log a HeroService message with the MessageService */
private log(message: string) {
  this.messageService.add(`HeroService: ${message}`);
}</pre> <p>Define the <code>heroesUrl</code> of the form <code>:base/:collectionName</code> with the address of the heroes resource on the server. Here <code>base</code> is the resource to which requests are made, and <code>collectionName</code> is the heroes data object in the <code>in-memory-data-service.ts</code>.</p> <pre header="src/app/hero.service.ts" data-language="typescript">private heroesUrl = 'api/heroes';  // URL to web api</pre> <h3 id="get-heroes-with-httpclient">Get heroes with <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code>
</h3> <p>The current <code>HeroService.getHeroes()</code> uses the RxJS <code>of()</code> function to return an array of mock heroes as an <code>Observable&lt;Hero[]&gt;</code>.</p> <pre header="src/app/hero.service.ts (getHeroes with RxJs 'of()')" data-language="typescript">getHeroes(): Observable&lt;Hero[]&gt; {
  return of(HEROES);
}</pre> <p>Convert that method to use <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> as follows:</p> <pre header="src/app/hero.service.ts" data-language="typescript">/** GET heroes from the server */
getHeroes (): Observable&lt;Hero[]&gt; {
  return this.http.get&lt;Hero[]&gt;(this.heroesUrl)
}</pre> <p>Refresh the browser. The hero data should successfully load from the mock server.</p> <p>You've swapped <code>of()</code> for <code>http.get()</code> and the app keeps working without any other changes because both functions return an <code>Observable&lt;Hero[]&gt;</code>.</p> <h3 id="httpclient-methods-return-one-value">
<code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> methods return one value</h3> <p>All <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> methods return an RxJS <code>Observable</code> of something.</p> <p>HTTP is a request/response protocol. You make a request, it returns a single response.</p> <p>In general, an observable <em>can</em> return multiple values over time. An observable from <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> always emits a single value and then completes, never to emit again.</p> <p>This particular <code><a href="../../api/common/http/httpclient/#get" class="code-anchor">HttpClient.get()</a></code> call returns an <code>Observable&lt;Hero[]&gt;</code>; that is, "<em>an observable of hero arrays</em>". In practice, it will only return a single hero array.</p> <h3 id="httpclientget-returns-response-data">
<code><a href="../../api/common/http/httpclient/#get" class="code-anchor">HttpClient.get()</a></code> returns response data</h3> <p><code><a href="../../api/common/http/httpclient/#get" class="code-anchor">HttpClient.get()</a></code> returns the body of the response as an untyped JSON object by default. Applying the optional type specifier, <code>&lt;Hero[]&gt;</code> , gives you a typed result object.</p> <p>The server's data API determines the shape of the JSON data. The <em>Tour of Heroes</em> data API returns the hero data as an array.</p> <blockquote class="alert is-helpful"> <p>Other APIs may bury the data that you want within an object. You might have to dig that data out by processing the <code>Observable</code> result with the RxJS <code><a href="../../api/core/querylist/#map" class="code-anchor">map()</a></code> operator.</p> <p>Although not discussed here, there's an example of <code><a href="../../api/core/querylist/#map" class="code-anchor">map()</a></code> in the <code>getHeroNo404()</code> method included in the sample source code.</p> </blockquote> <h3 id="error-handling">Error handling</h3> <p>Things go wrong, especially when you're getting data from a remote server. The <code>HeroService.getHeroes()</code> method should catch errors and do something appropriate.</p> <p>To catch errors, you <strong>"pipe" the observable</strong> result from <code>http.get()</code> through an RxJS <code>catchError()</code> operator.</p> <p>Import the <code>catchError</code> symbol from <code>rxjs/operators</code>, along with some other operators you'll need later.</p> <pre header="src/app/hero.service.ts" data-language="typescript">import { catchError, map, tap } from 'rxjs/operators';</pre> <p>Now extend the observable result with the <code>pipe()</code> method and give it a <code>catchError()</code> operator.</p> <pre header="src/app/hero.service.ts" data-language="typescript">getHeroes (): Observable&lt;Hero[]&gt; {
  return this.http.get&lt;Hero[]&gt;(this.heroesUrl)
    .pipe(
      catchError(this.handleError&lt;Hero[]&gt;('getHeroes', []))
    );
}</pre> <p>The <code>catchError()</code> operator intercepts an <strong><code>Observable</code> that failed</strong>. It passes the error an error handler that can do what it wants with the error.</p> <p>The following <code><a href="../../api/core/errorhandler/#handleError" class="code-anchor">handleError()</a></code> method reports the error and then returns an innocuous result so that the application keeps working.</p> <h4 id="handleerror"><code>handleError</code></h4> <p>The following <code><a href="../../api/core/errorhandler/#handleError" class="code-anchor">handleError()</a></code> will be shared by many <code>HeroService</code> methods so it's generalized to meet their different needs.</p> <p>Instead of handling the error directly, it returns an error handler function to <code>catchError</code> that it has configured with both the name of the operation that failed and a safe return value.</p> <pre header="src/app/hero.service.ts" data-language="typescript">/**
 * Handle Http operation that failed.
 * Let the app continue.
 * @param operation - name of the operation that failed
 * @param result - optional value to return as the observable result
 */
private handleError&lt;T&gt; (operation = 'operation', result?: T) {
  return (error: any): Observable&lt;T&gt; =&gt; {

    // TODO: send the error to remote logging infrastructure
    console.error(error); // log to console instead

    // TODO: better job of transforming error for user consumption
    this.log(`${operation} failed: ${error.message}`);

    // Let the app keep running by returning an empty result.
    return of(result as T);
  };
}</pre> <p>After reporting the error to the console, the handler constructs a user friendly message and returns a safe value to the app so the app can keep working.</p> <p>Because each service method returns a different kind of <code>Observable</code> result, <code><a href="../../api/core/errorhandler/#handleError" class="code-anchor">handleError()</a></code> takes a type parameter so it can return the safe value as the type that the app expects.</p> <h3 id="tap-into-the-observable">Tap into the Observable</h3> <p>The <code>HeroService</code> methods will <strong>tap</strong> into the flow of observable values and send a message, via the <code><a href="../../api/animations/browser/testing/mockanimationdriver/#log" class="code-anchor">log</a>()</code> method, to the message area at the bottom of the page.</p> <p>They'll do that with the RxJS <code>tap()</code> operator, which looks at the observable values, does something with those values, and passes them along. The <code>tap()</code> call back doesn't touch the values themselves.</p> <p>Here is the final version of <code>getHeroes()</code> with the <code>tap()</code> that logs the operation.</p> <pre header="src/app/hero.service.ts" data-language="typescript">/** GET heroes from the server */
getHeroes (): Observable&lt;Hero[]&gt; {
  return this.http.get&lt;Hero[]&gt;(this.heroesUrl)
    .pipe(
      tap(_ =&gt; this.log('fetched heroes')),
      catchError(this.handleError&lt;Hero[]&gt;('getHeroes', []))
    );
}</pre> <h3 id="get-hero-by-id">Get hero by id</h3> <p>Most web APIs support a <em>get by id</em> request in the form <code>:baseURL/:id</code>.</p> <p>Here, the <em>base URL</em> is the <code>heroesURL</code> defined in the <a href="../toh-pt6/#heroes-and-http">Heroes and HTTP</a> section (<code>api/heroes</code>) and <em>id</em> is the number of the hero that you want to retrieve. For example, <code>api/heroes/11</code>.</p> <p>Update the <code>HeroService</code> <code>getHero()</code> method with the following to make that request:</p> <pre header="src/app/hero.service.ts" data-language="typescript">/** GET hero by id. Will 404 if id not found */
getHero(id: number): Observable&lt;Hero&gt; {
  const url = `${this.heroesUrl}/${id}`;
  return this.http.get&lt;Hero&gt;(url).pipe(
    tap(_ =&gt; this.log(`fetched hero id=${id}`)),
    catchError(this.handleError&lt;Hero&gt;(`getHero id=${id}`))
  );
}</pre> <p>There are three significant differences from <code>getHeroes()</code>:</p> <ul> <li>
<code>getHero()</code> constructs a request URL with the desired hero's id.</li> <li>The server should respond with a single hero rather than an array of heroes.</li> <li>
<code>getHero()</code> returns an <code>Observable&lt;Hero&gt;</code> ("<em>an observable of Hero objects</em>") rather than an observable of hero <em>arrays</em> .</li> </ul> <h2 id="update-heroes">Update heroes</h2> <p>Edit a hero's name in the hero detail view. As you type, the hero name updates the heading at the top of the page. But when you click the "go back button", the changes are lost.</p> <p>If you want changes to persist, you must write them back to the server.</p> <p>At the end of the hero detail template, add a save button with a <code>click</code> event binding that invokes a new component method named <code>save()</code>.</p> <pre header="src/app/hero-detail/hero-detail.component.html (save)" data-language="html">&lt;button (click)="save()"&gt;save&lt;/button&gt;</pre> <p>In the <code>HeroDetail</code> component class, add the following <code>save()</code> method, which persists hero name changes using the hero service <code>updateHero()</code> method and then navigates back to the previous view.</p> <pre header="src/app/hero-detail/hero-detail.component.ts (save)" data-language="typescript">save(): void {
   this.heroService.updateHero(this.hero)
     .subscribe(() =&gt; this.goBack());
 }</pre> <h4 id="add-heroserviceupdatehero">Add <code>HeroService.updateHero()</code>
</h4> <p>The overall structure of the <code>updateHero()</code> method is similar to that of <code>getHeroes()</code>, but it uses <code>http.put()</code> to persist the changed hero on the server. Add the following to the <code>HeroService</code>.</p> <pre header="src/app/hero.service.ts (update)" data-language="typescript">/** PUT: update the hero on the server */
updateHero (hero: Hero): Observable&lt;any&gt; {
  return this.http.put(this.heroesUrl, hero, this.httpOptions).pipe(
    tap(_ =&gt; this.log(`updated hero id=${hero.id}`)),
    catchError(this.handleError&lt;any&gt;('updateHero'))
  );
}</pre> <p>The <code><a href="../../api/common/http/httpclient/#put" class="code-anchor">HttpClient.put()</a></code> method takes three parameters:</p> <ul> <li>the URL</li> <li>the data to update (the modified hero in this case)</li> <li>options</li> </ul> <p>The URL is unchanged. The heroes web API knows which hero to update by looking at the hero's <code>id</code>.</p> <p>The heroes web API expects a special header in HTTP save requests. That header is in the <code>httpOptions</code> constant defined in the <code>HeroService</code>. Add the following to the <code>HeroService</code> class.</p> <pre header="src/app/hero.service.ts" data-language="typescript">httpOptions = {
  headers: new HttpHeaders({ 'Content-Type': 'application/json' })
};</pre> <p>Refresh the browser, change a hero name and save your change. The <code>save()</code> method in <code>HeroDetailComponent</code> navigates to the previous view. The hero now appears in the list with the changed name.</p> <h2 id="add-a-new-hero">Add a new hero</h2> <p>To add a hero, this app only needs the hero's name. You can use an <code>&lt;input&gt;</code> element paired with an add button.</p> <p>Insert the following into the <code>HeroesComponent</code> template, just after the heading:</p> <pre header="src/app/heroes/heroes.component.html (add)" data-language="html">&lt;div&gt;
  &lt;label&gt;Hero name:
    &lt;input #heroName /&gt;
  &lt;/label&gt;
  &lt;!-- (click) passes input value to add() and then clears the input --&gt;
  &lt;button (click)="add(heroName.value); heroName.value=''"&gt;
    add
  &lt;/button&gt;
&lt;/div&gt;</pre> <p>In response to a click event, call the component's click handler, <code>add()</code>, and then clear the input field so that it's ready for another name. Add the following to the <code>HeroesComponent</code> class:</p> <pre header="src/app/heroes/heroes.component.ts (add)" data-language="typescript">add(name: string): void {
  name = name.trim();
  if (!name) { return; }
  this.heroService.addHero({ name } as Hero)
    .subscribe(hero =&gt; {
      this.heroes.push(hero);
    });
}</pre> <p>When the given name is non-blank, the handler creates a <code>Hero</code>-like object from the name (it's only missing the <code>id</code>) and passes it to the services <code>addHero()</code> method.</p> <p>When <code>addHero()</code> saves successfully, the <code>subscribe()</code> callback receives the new hero and pushes it into to the <code>heroes</code> list for display.</p> <p>Add the following <code>addHero()</code> method to the <code>HeroService</code> class.</p> <pre header="src/app/hero.service.ts (addHero)" data-language="typescript">/** POST: add a new hero to the server */
addHero (hero: Hero): Observable&lt;Hero&gt; {
  return this.http.post&lt;Hero&gt;(this.heroesUrl, hero, this.httpOptions).pipe(
    tap((newHero: Hero) =&gt; this.log(`added hero w/ id=${newHero.id}`)),
    catchError(this.handleError&lt;Hero&gt;('addHero'))
  );
}</pre> <p><code>addHero()</code> differs from <code>updateHero()</code> in two ways:</p> <ul> <li>It calls <code><a href="../../api/common/http/httpclient/#post" class="code-anchor">HttpClient.post()</a></code> instead of <code><a href="../../api/common/http/httpclient/#put" class="code-anchor">put()</a></code>.</li> <li>It expects the server to generate an id for the new hero, which it returns in the <code>Observable&lt;Hero&gt;</code> to the caller.</li> </ul> <p>Refresh the browser and add some heroes.</p> <h2 id="delete-a-hero">Delete a hero</h2> <p>Each hero in the heroes list should have a delete button.</p> <p>Add the following button element to the <code>HeroesComponent</code> template, after the hero name in the repeated <code>&lt;li&gt;</code> element.</p> <pre header="src/app/heroes/heroes.component.html" data-language="html">&lt;button class="delete" title="delete hero"
  (click)="delete(hero)"&gt;x&lt;/button&gt;</pre> <p>The HTML for the list of heroes should look like this:</p> <pre header="src/app/heroes/heroes.component.html (list of heroes)" data-language="html">&lt;ul class="heroes"&gt;
  &lt;li *ngFor="let hero of heroes"&gt;
    &lt;a routerLink="/detail/{{hero.id}}"&gt;
      &lt;span class="badge"&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
    &lt;/a&gt;
    &lt;button class="delete" title="delete hero"
      (click)="delete(hero)"&gt;x&lt;/button&gt;
  &lt;/li&gt;
&lt;/ul&gt;</pre> <p>To position the delete button at the far right of the hero entry, add some CSS to the <code>heroes.component.css</code>. You'll find that CSS in the <a href="../toh-pt6/#heroescomponent">final review code</a> below.</p> <p>Add the <code>delete()</code> handler to the component class.</p> <pre header="src/app/heroes/heroes.component.ts (delete)" data-language="typescript">delete(hero: Hero): void {
  this.heroes = this.heroes.filter(h =&gt; h !== hero);
  this.heroService.deleteHero(hero).subscribe();
}</pre> <p>Although the component delegates hero deletion to the <code>HeroService</code>, it remains responsible for updating its own list of heroes. The component's <code>delete()</code> method immediately removes the <em>hero-to-delete</em> from that list, anticipating that the <code>HeroService</code> will succeed on the server.</p> <p>There's really nothing for the component to do with the <code>Observable</code> returned by <code>heroService.delete()</code> <strong>but it must subscribe anyway</strong>.</p> <blockquote class="alert is-important"> <p> If you neglect to <code>subscribe()</code>, the service will not send the delete request to the server. As a rule, an <code>Observable</code> <em>does nothing</em> until something subscribes.</p> <p> Confirm this for yourself by temporarily removing the <code>subscribe()</code>, clicking "Dashboard", then clicking "Heroes". You'll see the full list of heroes again.</p> </blockquote> <p>Next, add a <code>deleteHero()</code> method to <code>HeroService</code> like this.</p> <pre header="src/app/hero.service.ts (delete)" data-language="typescript">/** DELETE: delete the hero from the server */
deleteHero (hero: Hero | number): Observable&lt;Hero&gt; {
  const id = typeof hero === 'number' ? hero : hero.id;
  const url = `${this.heroesUrl}/${id}`;

  return this.http.delete&lt;Hero&gt;(url, this.httpOptions).pipe(
    tap(_ =&gt; this.log(`deleted hero id=${id}`)),
    catchError(this.handleError&lt;Hero&gt;('deleteHero'))
  );
}</pre> <p>Note the following key points:</p> <ul> <li>
<code>deleteHero()</code> calls <code><a href="../../api/common/http/httpclient/#delete" class="code-anchor">HttpClient.delete()</a></code>.</li> <li>The URL is the heroes resource URL plus the <code>id</code> of the hero to delete.</li> <li>You don't send data as you did with <code><a href="../../api/common/http/httpclient/#put" class="code-anchor">put()</a></code> and <code><a href="../../api/common/http/httpclient/#post" class="code-anchor">post()</a></code>.</li> <li>You still send the <code>httpOptions</code>.</li> </ul> <p>Refresh the browser and try the new delete functionality.</p> <h2 id="search-by-name">Search by name</h2> <p>In this last exercise, you learn to chain <code>Observable</code> operators together so you can minimize the number of similar HTTP requests and consume network bandwidth economically.</p> <p>You will add a heroes search feature to the Dashboard. As the user types a name into a search box, you'll make repeated HTTP requests for heroes filtered by that name. Your goal is to issue only as many requests as necessary.</p> <h4 id="heroservicesearchheroes"><code>HeroService.searchHeroes()</code></h4> <p>Start by adding a <code>searchHeroes()</code> method to the <code>HeroService</code>.</p> <pre header="src/app/hero.service.ts" data-language="typescript">/* GET heroes whose name contains search term */
searchHeroes(term: string): Observable&lt;Hero[]&gt; {
  if (!term.trim()) {
    // if not search term, return empty hero array.
    return of([]);
  }
  return this.http.get&lt;Hero[]&gt;(`${this.heroesUrl}/?name=${term}`).pipe(
    tap(_ =&gt; this.log(`found heroes matching "${term}"`)),
    catchError(this.handleError&lt;Hero[]&gt;('searchHeroes', []))
  );
}</pre> <p>The method returns immediately with an empty array if there is no search term. The rest of it closely resembles <code>getHeroes()</code>, the only significant difference being the URL, which includes a query string with the search term.</p> <h3 id="add-search-to-the-dashboard">Add search to the Dashboard</h3> <p>Open the <code>DashboardComponent</code> template and add the hero search element, <code>&lt;app-hero-search&gt;</code>, to the bottom of the markup.</p> <pre header="src/app/dashboard/dashboard.component.html" data-language="html">&lt;h3&gt;Top Heroes&lt;/h3&gt;
&lt;div class="grid grid-pad"&gt;
  &lt;a *ngFor="let hero of heroes" class="col-1-4"
      routerLink="/detail/{{hero.id}}"&gt;
    &lt;div class="module hero"&gt;
      &lt;h4&gt;{{hero.name}}&lt;/h4&gt;
    &lt;/div&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;app-hero-search&gt;&lt;/app-hero-search&gt;</pre> <p>This template looks a lot like the <code>*<a href="../../api/common/ngforof/" class="code-anchor">ngFor</a></code> repeater in the <code>HeroesComponent</code> template.</p> <p>For this to work, the next step is to add a component with a selector that matches <code>&lt;app-hero-search&gt;</code>.</p> <h3 id="create-herosearchcomponent">Create <code>HeroSearchComponent</code>
</h3> <p>Create a <code>HeroSearchComponent</code> with the CLI.</p> <pre data-language="sh">ng generate component hero-search</pre> <p>The CLI generates the three <code>HeroSearchComponent</code> files and adds the component to the <code>AppModule</code> declarations.</p> <p>Replace the generated <code>HeroSearchComponent</code> template with an <code>&lt;input&gt;</code> and a list of matching search results, as follows.</p> <pre header="src/app/hero-search/hero-search.component.html" data-language="html">&lt;div id="search-component"&gt;
  &lt;h4&gt;&lt;label for="search-box"&gt;Hero Search&lt;/label&gt;&lt;/h4&gt;

  &lt;input #searchBox id="search-box" (input)="search(searchBox.value)" /&gt;

  &lt;ul class="search-result"&gt;
    &lt;li *ngFor="let hero of heroes$ | async" &gt;
      &lt;a routerLink="/detail/{{hero.id}}"&gt;
        {{hero.name}}
      &lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</pre> <p>Add private CSS styles to <code>hero-search.component.css</code> as listed in the <a href="../toh-pt6/#herosearchcomponent">final code review</a> below.</p> <p>As the user types in the search box, an input event binding calls the component's <code><a href="../../api/common/upgrade/%24locationshim/#search" class="code-anchor">search()</a></code> method with the new search box value.</p>  <h3 id="asyncpipe"><code><a href="../../api/common/asyncpipe/" class="code-anchor">AsyncPipe</a></code></h3> <p>The <code>*<a href="../../api/common/ngforof/" class="code-anchor">ngFor</a></code> repeats hero objects. Notice that the <code>*<a href="../../api/common/ngforof/" class="code-anchor">ngFor</a></code> iterates over a list called <code>heroes$</code>, not <code>heroes</code>. The <code>$</code> is a convention that indicates <code>heroes$</code> is an <code>Observable</code>, not an array.</p> <pre header="src/app/hero-search/hero-search.component.html" data-language="html">&lt;li *ngFor="let hero of heroes$ | async" &gt;</pre> <p>Since <code>*<a href="../../api/common/ngforof/" class="code-anchor">ngFor</a></code> can't do anything with an <code>Observable</code>, use the pipe character (<code>|</code>) followed by <code><a href="../../api/core/testing/async/" class="code-anchor">async</a></code>. This identifies Angular's <code><a href="../../api/common/asyncpipe/" class="code-anchor">AsyncPipe</a></code> and subscribes to an <code>Observable</code> automatically so you won't have to do so in the component class.</p> <h3 id="edit-the-herosearchcomponent-class">Edit the <code>HeroSearchComponent</code> class</h3> <p>Replace the generated <code>HeroSearchComponent</code> class and metadata as follows.</p> <pre header="src/app/hero-search/hero-search.component.ts" data-language="typescript">import { Component, OnInit } from '@angular/core';

import { Observable, Subject } from 'rxjs';

import {
   debounceTime, distinctUntilChanged, switchMap
 } from 'rxjs/operators';

import { Hero } from '../hero';
import { HeroService } from '../hero.service';

@Component({
  selector: 'app-hero-search',
  templateUrl: './hero-search.component.html',
  styleUrls: [ './hero-search.component.css' ]
})
export class HeroSearchComponent implements OnInit {
  heroes$: Observable&lt;Hero[]&gt;;
  private searchTerms = new Subject&lt;string&gt;();

  constructor(private heroService: HeroService) {}

  // Push a search term into the observable stream.
  search(term: string): void {
    this.searchTerms.next(term);
  }

  ngOnInit(): void {
    this.heroes$ = this.searchTerms.pipe(
      // wait 300ms after each keystroke before considering the term
      debounceTime(300),

      // ignore new term if same as previous term
      distinctUntilChanged(),

      // switch to new search observable each time the term changes
      switchMap((term: string) =&gt; this.heroService.searchHeroes(term)),
    );
  }
}</pre> <p>Notice the declaration of <code>heroes$</code> as an <code>Observable</code>:</p> <pre header="src/app/hero-search/hero-search.component.ts" data-language="typescript">heroes$: Observable&lt;Hero[]&gt;;</pre> <p>You'll set it in <a href="../toh-pt6/#search-pipe"><code>ngOnInit()</code></a>. Before you do, focus on the definition of <code>searchTerms</code>.</p> <h3 id="the-searchterms-rxjs-subject">The <code>searchTerms</code> RxJS subject</h3> <p>The <code>searchTerms</code> property is an RxJS <code>Subject</code>.</p> <pre header="src/app/hero-search/hero-search.component.ts" data-language="typescript">private searchTerms = new Subject&lt;string&gt;();

// Push a search term into the observable stream.
search(term: string): void {
  this.searchTerms.next(term);
}</pre> <p>A <code>Subject</code> is both a source of observable values and an <code>Observable</code> itself. You can subscribe to a <code>Subject</code> as you would any <code>Observable</code>.</p> <p>You can also push values into that <code>Observable</code> by calling its <code>next(value)</code> method as the <code><a href="../../api/common/upgrade/%24locationshim/#search" class="code-anchor">search()</a></code> method does.</p> <p>The event binding to the textbox's <code>input</code> event calls the <code><a href="../../api/common/upgrade/%24locationshim/#search" class="code-anchor">search()</a></code> method.</p> <pre header="src/app/hero-search/hero-search.component.html" data-language="html">&lt;input #searchBox id="search-box" (input)="search(searchBox.value)" /&gt;</pre> <p>Every time the user types in the textbox, the binding calls <code><a href="../../api/common/upgrade/%24locationshim/#search" class="code-anchor">search()</a></code> with the textbox value, a "search term". The <code>searchTerms</code> becomes an <code>Observable</code> emitting a steady stream of search terms.</p>  <h3 id="chaining-rxjs-operators">Chaining RxJS operators</h3> <p>Passing a new search term directly to the <code>searchHeroes()</code> after every user keystroke would create an excessive amount of HTTP requests, taxing server resources and burning through data plans.</p> <p>Instead, the <code>ngOnInit()</code> method pipes the <code>searchTerms</code> observable through a sequence of RxJS operators that reduce the number of calls to the <code>searchHeroes()</code>, ultimately returning an observable of timely hero search results (each a <code>Hero[]</code>).</p> <p>Here's a closer look at the code.</p> <pre header="src/app/hero-search/hero-search.component.ts" data-language="typescript">this.heroes$ = this.searchTerms.pipe(
  // wait 300ms after each keystroke before considering the term
  debounceTime(300),

  // ignore new term if same as previous term
  distinctUntilChanged(),

  // switch to new search observable each time the term changes
  switchMap((term: string) =&gt; this.heroService.searchHeroes(term)),
);</pre> <p>Each operator works as follows:</p> <ul> <li> <p><code>debounceTime(300)</code> waits until the flow of new string events pauses for 300 milliseconds before passing along the latest string. You'll never make requests more frequently than 300ms.</p> </li> <li> <p><code>distinctUntilChanged()</code> ensures that a request is sent only if the filter text changed.</p> </li> <li> <p><code>switchMap()</code> calls the search service for each search term that makes it through <code>debounce()</code> and <code>distinctUntilChanged()</code>. It cancels and discards previous search observables, returning only the latest search service observable.</p> </li> </ul> <blockquote class="alert is-helpful"> <p> With the <a href="http://www.learnrxjs.io/operators/transformation/switchmap.html" target="_blank">switchMap operator</a>, every qualifying key event can trigger an <code><a href="../../api/common/http/httpclient/#get" class="code-anchor">HttpClient.get()</a></code> method call. Even with a 300ms pause between requests, you could have multiple HTTP requests in flight and they may not return in the order sent.</p> <p> <code>switchMap()</code> preserves the original request order while returning only the observable from the most recent HTTP method call. Results from prior calls are canceled and discarded.</p> <p> Note that canceling a previous <code>searchHeroes()</code> Observable doesn't actually abort a pending HTTP request. Unwanted results are simply discarded before they reach your application code.</p> </blockquote> <p>Remember that the component <em>class</em> does not subscribe to the <code>heroes$</code> <em>observable</em>. That's the job of the <a href="../toh-pt6/#asyncpipe"><code>AsyncPipe</code></a> in the template.</p> <h4 id="try-it">Try it</h4> <p>Run the app again. In the <em>Dashboard</em>, enter some text in the search box. If you enter characters that match any existing hero names, you'll see something like this.</p> <figure class="lightbox"> <div class="card"> <img src="data:image/png;base64,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" alt="Hero Search Component" width="240" height="224"> </div> </figure> <h2 id="final-code-review">Final code review</h2> <p>Your app should look like this live example.</p> <p>Here are the code files discussed on this page (all in the <code>src/app/</code> folder).</p>    <h4 id="heroservice-inmemorydataservice-appmodule">
<code>HeroService</code>, <code>InMemoryDataService</code>, <code>AppModule</code>
</h4> <code-tabs> <pre header="hero.service.ts" data-language="typescript">import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';

import { Observable, of } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';

import { Hero } from './hero';
import { MessageService } from './message.service';


@Injectable({ providedIn: 'root' })
export class HeroService {

  private heroesUrl = 'api/heroes';  // URL to web api

  httpOptions = {
    headers: new HttpHeaders({ 'Content-Type': 'application/json' })
  };

  constructor(
    private http: HttpClient,
    private messageService: MessageService) { }

  /** GET heroes from the server */
  getHeroes (): Observable&lt;Hero[]&gt; {
    return this.http.get&lt;Hero[]&gt;(this.heroesUrl)
      .pipe(
        tap(_ =&gt; this.log('fetched heroes')),
        catchError(this.handleError&lt;Hero[]&gt;('getHeroes', []))
      );
  }

  /** GET hero by id. Return `undefined` when id not found */
  getHeroNo404&lt;Data&gt;(id: number): Observable&lt;Hero&gt; {
    const url = `${this.heroesUrl}/?id=${id}`;
    return this.http.get&lt;Hero[]&gt;(url)
      .pipe(
        map(heroes =&gt; heroes[0]), // returns a {0|1} element array
        tap(h =&gt; {
          const outcome = h ? `fetched` : `did not find`;
          this.log(`${outcome} hero id=${id}`);
        }),
        catchError(this.handleError&lt;Hero&gt;(`getHero id=${id}`))
      );
  }

  /** GET hero by id. Will 404 if id not found */
  getHero(id: number): Observable&lt;Hero&gt; {
    const url = `${this.heroesUrl}/${id}`;
    return this.http.get&lt;Hero&gt;(url).pipe(
      tap(_ =&gt; this.log(`fetched hero id=${id}`)),
      catchError(this.handleError&lt;Hero&gt;(`getHero id=${id}`))
    );
  }

  /* GET heroes whose name contains search term */
  searchHeroes(term: string): Observable&lt;Hero[]&gt; {
    if (!term.trim()) {
      // if not search term, return empty hero array.
      return of([]);
    }
    return this.http.get&lt;Hero[]&gt;(`${this.heroesUrl}/?name=${term}`).pipe(
      tap(_ =&gt; this.log(`found heroes matching "${term}"`)),
      catchError(this.handleError&lt;Hero[]&gt;('searchHeroes', []))
    );
  }

  //////// Save methods //////////

  /** POST: add a new hero to the server */
  addHero (hero: Hero): Observable&lt;Hero&gt; {
    return this.http.post&lt;Hero&gt;(this.heroesUrl, hero, this.httpOptions).pipe(
      tap((newHero: Hero) =&gt; this.log(`added hero w/ id=${newHero.id}`)),
      catchError(this.handleError&lt;Hero&gt;('addHero'))
    );
  }

  /** DELETE: delete the hero from the server */
  deleteHero (hero: Hero | number): Observable&lt;Hero&gt; {
    const id = typeof hero === 'number' ? hero : hero.id;
    const url = `${this.heroesUrl}/${id}`;

    return this.http.delete&lt;Hero&gt;(url, this.httpOptions).pipe(
      tap(_ =&gt; this.log(`deleted hero id=${id}`)),
      catchError(this.handleError&lt;Hero&gt;('deleteHero'))
    );
  }

  /** PUT: update the hero on the server */
  updateHero (hero: Hero): Observable&lt;any&gt; {
    return this.http.put(this.heroesUrl, hero, this.httpOptions).pipe(
      tap(_ =&gt; this.log(`updated hero id=${hero.id}`)),
      catchError(this.handleError&lt;any&gt;('updateHero'))
    );
  }

  /**
   * Handle Http operation that failed.
   * Let the app continue.
   * @param operation - name of the operation that failed
   * @param result - optional value to return as the observable result
   */
  private handleError&lt;T&gt; (operation = 'operation', result?: T) {
    return (error: any): Observable&lt;T&gt; =&gt; {

      // TODO: send the error to remote logging infrastructure
      console.error(error); // log to console instead

      // TODO: better job of transforming error for user consumption
      this.log(`${operation} failed: ${error.message}`);

      // Let the app keep running by returning an empty result.
      return of(result as T);
    };
  }

  /** Log a HeroService message with the MessageService */
  private log(message: string) {
    this.messageService.add(`HeroService: ${message}`);
  }
}</pre> <pre header="in-memory-data.service.ts" data-language="typescript">import { InMemoryDbService } from 'angular-in-memory-web-api';
import { Hero } from './hero';
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class InMemoryDataService implements InMemoryDbService {
  createDb() {
    const heroes = [
      { id: 11, name: 'Dr Nice' },
      { id: 12, name: 'Narco' },
      { id: 13, name: 'Bombasto' },
      { id: 14, name: 'Celeritas' },
      { id: 15, name: 'Magneta' },
      { id: 16, name: 'RubberMan' },
      { id: 17, name: 'Dynama' },
      { id: 18, name: 'Dr IQ' },
      { id: 19, name: 'Magma' },
      { id: 20, name: 'Tornado' }
    ];
    return {heroes};
  }

  // Overrides the genId method to ensure that a hero always has an id.
  // If the heroes array is empty,
  // the method below returns the initial number (11).
  // if the heroes array is not empty, the method below returns the highest
  // hero id + 1.
  genId(heroes: Hero[]): number {
    return heroes.length &gt; 0 ? Math.max(...heroes.map(hero =&gt; hero.id)) + 1 : 11;
  }
}</pre> <pre header="app.module.ts" data-language="typescript">import { NgModule }       from '@angular/core';
import { BrowserModule }  from '@angular/platform-browser';
import { FormsModule }    from '@angular/forms';
import { HttpClientModule }    from '@angular/common/http';

import { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';
import { InMemoryDataService }  from './in-memory-data.service';

import { AppRoutingModule }     from './app-routing.module';

import { AppComponent }         from './app.component';
import { DashboardComponent }   from './dashboard/dashboard.component';
import { HeroDetailComponent }  from './hero-detail/hero-detail.component';
import { HeroesComponent }      from './heroes/heroes.component';
import { HeroSearchComponent }  from './hero-search/hero-search.component';
import { MessagesComponent }    from './messages/messages.component';

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    AppRoutingModule,
    HttpClientModule,

    // The HttpClientInMemoryWebApiModule module intercepts HTTP requests
    // and returns simulated server responses.
    // Remove it when a real server is ready to receive requests.
    HttpClientInMemoryWebApiModule.forRoot(
      InMemoryDataService, { dataEncapsulation: false }
    )
  ],
  declarations: [
    AppComponent,
    DashboardComponent,
    HeroesComponent,
    HeroDetailComponent,
    MessagesComponent,
    HeroSearchComponent
  ],
  bootstrap: [ AppComponent ]
})

export class AppModule { }</pre> </code-tabs>  <h4 id="heroescomponent"><code>HeroesComponent</code></h4> <code-tabs> <pre header="heroes/heroes.component.html" data-language="html">&lt;h2&gt;My Heroes&lt;/h2&gt;

&lt;div&gt;
  &lt;label&gt;Hero name:
    &lt;input #heroName /&gt;
  &lt;/label&gt;
  &lt;!-- (click) passes input value to add() and then clears the input --&gt;
  &lt;button (click)="add(heroName.value); heroName.value=''"&gt;
    add
  &lt;/button&gt;
&lt;/div&gt;

&lt;ul class="heroes"&gt;
  &lt;li *ngFor="let hero of heroes"&gt;
    &lt;a routerLink="/detail/{{hero.id}}"&gt;
      &lt;span class="badge"&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
    &lt;/a&gt;
    &lt;button class="delete" title="delete hero"
      (click)="delete(hero)"&gt;x&lt;/button&gt;
  &lt;/li&gt;
&lt;/ul&gt;</pre> <pre header="heroes/heroes.component.ts" data-language="typescript">import { Component, OnInit } from '@angular/core';

import { Hero } from '../hero';
import { HeroService } from '../hero.service';

@Component({
  selector: 'app-heroes',
  templateUrl: './heroes.component.html',
  styleUrls: ['./heroes.component.css']
})
export class HeroesComponent implements OnInit {
  heroes: Hero[];

  constructor(private heroService: HeroService) { }

  ngOnInit() {
    this.getHeroes();
  }

  getHeroes(): void {
    this.heroService.getHeroes()
    .subscribe(heroes =&gt; this.heroes = heroes);
  }

  add(name: string): void {
    name = name.trim();
    if (!name) { return; }
    this.heroService.addHero({ name } as Hero)
      .subscribe(hero =&gt; {
        this.heroes.push(hero);
      });
  }

  delete(hero: Hero): void {
    this.heroes = this.heroes.filter(h =&gt; h !== hero);
    this.heroService.deleteHero(hero).subscribe();
  }

}</pre> <pre header="heroes/heroes.component.css" data-language="css">/* HeroesComponent's private CSS styles */
.heroes {
  margin: 0 0 2em 0;
  list-style-type: none;
  padding: 0;
  width: 15em;
}
.heroes li {
  position: relative;
  cursor: pointer;
  background-color: #EEE;
  margin: .5em;
  padding: .3em 0;
  height: 1.6em;
  border-radius: 4px;
}

.heroes li:hover {
  color: #607D8B;
  background-color: #DDD;
  left: .1em;
}

.heroes a {
  color: #333;
  text-decoration: none;
  position: relative;
  display: block;
  width: 250px;
}

.heroes a:hover {
  color:#607D8B;
}

.heroes .badge {
  display: inline-block;
  font-size: small;
  color: white;
  padding: 0.8em 0.7em 0 0.7em;
  background-color:#405061;
  line-height: 1em;
  position: relative;
  left: -1px;
  top: -4px;
  height: 1.8em;
  min-width: 16px;
  text-align: right;
  margin-right: .8em;
  border-radius: 4px 0 0 4px;
}

button {
  background-color: #eee;
  border: none;
  padding: 5px 10px;
  border-radius: 4px;
  cursor: pointer;
  cursor: hand;
  font-family: Arial;
}

button:hover {
  background-color: #cfd8dc;
}

button.delete {
  position: relative;
  left: 194px;
  top: -32px;
  background-color: gray !important;
  color: white;
}</pre> </code-tabs>  <h4 id="herodetailcomponent"><code>HeroDetailComponent</code></h4> <code-tabs> <pre header="hero-detail/hero-detail.component.html" data-language="html">&lt;div *ngIf="hero"&gt;
  &lt;h2&gt;{{hero.name | uppercase}} Details&lt;/h2&gt;
  &lt;div&gt;&lt;span&gt;id: &lt;/span&gt;{{hero.id}}&lt;/div&gt;
  &lt;div&gt;
    &lt;label&gt;name:
      &lt;input [(ngModel)]="hero.name" placeholder="name"/&gt;
    &lt;/label&gt;
  &lt;/div&gt;
  &lt;button (click)="goBack()"&gt;go back&lt;/button&gt;
  &lt;button (click)="save()"&gt;save&lt;/button&gt;
&lt;/div&gt;</pre> <pre header="hero-detail/hero-detail.component.ts" data-language="typescript">import { Component, OnInit, Input } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Location } from '@angular/common';

import { Hero }         from '../hero';
import { HeroService }  from '../hero.service';

@Component({
  selector: 'app-hero-detail',
  templateUrl: './hero-detail.component.html',
  styleUrls: [ './hero-detail.component.css' ]
})
export class HeroDetailComponent implements OnInit {
  @Input() hero: Hero;

  constructor(
    private route: ActivatedRoute,
    private heroService: HeroService,
    private location: Location
  ) {}

  ngOnInit(): void {
    this.getHero();
  }

  getHero(): void {
    const id = +this.route.snapshot.paramMap.get('id');
    this.heroService.getHero(id)
      .subscribe(hero =&gt; this.hero = hero);
  }

  goBack(): void {
    this.location.back();
  }

 save(): void {
    this.heroService.updateHero(this.hero)
      .subscribe(() =&gt; this.goBack());
  }
}</pre> </code-tabs>  <h4 id="dashboardcomponent"><code>DashboardComponent</code></h4> <code-tabs> <pre header="src/app/dashboard/dashboard.component.html" data-language="html">&lt;h3&gt;Top Heroes&lt;/h3&gt;
&lt;div class="grid grid-pad"&gt;
  &lt;a *ngFor="let hero of heroes" class="col-1-4"
      routerLink="/detail/{{hero.id}}"&gt;
    &lt;div class="module hero"&gt;
      &lt;h4&gt;{{hero.name}}&lt;/h4&gt;
    &lt;/div&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;app-hero-search&gt;&lt;/app-hero-search&gt;</pre> </code-tabs>  <h4 id="herosearchcomponent"><code>HeroSearchComponent</code></h4> <code-tabs> <pre header="hero-search/hero-search.component.html" data-language="html">&lt;div id="search-component"&gt;
  &lt;h4&gt;&lt;label for="search-box"&gt;Hero Search&lt;/label&gt;&lt;/h4&gt;

  &lt;input #searchBox id="search-box" (input)="search(searchBox.value)" /&gt;

  &lt;ul class="search-result"&gt;
    &lt;li *ngFor="let hero of heroes$ | async" &gt;
      &lt;a routerLink="/detail/{{hero.id}}"&gt;
        {{hero.name}}
      &lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</pre> <pre header="hero-search/hero-search.component.ts" data-language="typescript">import { Component, OnInit } from '@angular/core';

import { Observable, Subject } from 'rxjs';

import {
   debounceTime, distinctUntilChanged, switchMap
 } from 'rxjs/operators';

import { Hero } from '../hero';
import { HeroService } from '../hero.service';

@Component({
  selector: 'app-hero-search',
  templateUrl: './hero-search.component.html',
  styleUrls: [ './hero-search.component.css' ]
})
export class HeroSearchComponent implements OnInit {
  heroes$: Observable&lt;Hero[]&gt;;
  private searchTerms = new Subject&lt;string&gt;();

  constructor(private heroService: HeroService) {}

  // Push a search term into the observable stream.
  search(term: string): void {
    this.searchTerms.next(term);
  }

  ngOnInit(): void {
    this.heroes$ = this.searchTerms.pipe(
      // wait 300ms after each keystroke before considering the term
      debounceTime(300),

      // ignore new term if same as previous term
      distinctUntilChanged(),

      // switch to new search observable each time the term changes
      switchMap((term: string) =&gt; this.heroService.searchHeroes(term)),
    );
  }
}</pre> <pre header="hero-search/hero-search.component.css" data-language="css">/* HeroSearch private styles */
.search-result li {
  border-bottom: 1px solid gray;
  border-left: 1px solid gray;
  border-right: 1px solid gray;
  width: 195px;
  height: 16px;
  padding: 5px;
  background-color: white;
  cursor: pointer;
  list-style-type: none;
}

.search-result li:hover {
  background-color: #607D8B;
}

.search-result li a {
  color: #888;
  display: block;
  text-decoration: none;
}

.search-result li a:hover {
  color: white;
}
.search-result li a:active {
  color: white;
}
#search-box {
  width: 200px;
  height: 20px;
}


ul.search-result {
  margin-top: 0;
  padding-left: 0;
}</pre> </code-tabs> <h2 id="summary">Summary</h2> <p>You're at the end of your journey, and you've accomplished a lot.</p> <ul> <li>You added the necessary dependencies to use HTTP in the app.</li> <li>You refactored <code>HeroService</code> to load heroes from a web API.</li> <li>You extended <code>HeroService</code> to support <code><a href="../../api/common/http/httpclient/#post" class="code-anchor">post()</a></code>, <code><a href="../../api/common/http/httpclient/#put" class="code-anchor">put()</a></code>, and <code>delete()</code> methods.</li> <li>You updated the components to allow adding, editing, and deleting of heroes.</li> <li>You configured an in-memory web API.</li> <li>You learned how to use observables.</li> </ul> <p>This concludes the "Tour of Heroes" tutorial. You're ready to learn more about Angular development in the fundamentals section, starting with the <a href="../../guide/architecture/" title="Architecture">Architecture</a> guide.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2019 Google, Inc.<br>Licensed under the Creative Commons Attribution License 4.0.<br>
    <a href="https://angular.io/tutorial/toh-pt6" class="_attribution-link" target="_blank">https://angular.io/tutorial/toh-pt6</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
