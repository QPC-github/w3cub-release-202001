
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Bundler&#58;&#58;Persistent&#58;&#58;Net&#58;&#58;HTTP&#58;&#58;Persistent - Ruby 2.6 - W3cubDocs</title>
  
  <meta name="description" content=" Persistent connections for Net&#58;&#58;HTTP ">
  <meta name="keywords" content="class, bundler, persistent, net, http, -, ruby, ruby~2.6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/ruby~2.6/bundler/persistent/net/http/persistent/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/ruby~2.6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ruby~2.6/" class="_nav-link" title="" style="margin-left:0;">Ruby 2.6</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="class-Bundler::Persistent::Net::HTTP::Persistent" class="class"> class Bundler::Persistent::Net::HTTP::Persistent </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../../../../../object/">Object</a></dd>
</dl> <section class="description"> <p><a href="../persistent/"><code>Persistent</code></a> connections for <a href="../../../../../net/http/"><code>Net::HTTP</code></a></p> <p><a href="../persistent/"><code>Bundler::Persistent::Net::HTTP::Persistent</code></a> maintains persistent connections across all the servers you wish to talk to. For each host:port you communicate with a single persistent connection is created.</p> <p>Multiple <a href="../persistent/"><code>Bundler::Persistent::Net::HTTP::Persistent</code></a> objects will share the same set of connections.</p> <p>For each thread you start a new connection will be created. A <a href="../persistent/"><code>Bundler::Persistent::Net::HTTP::Persistent</code></a> connection will not be shared across threads.</p> <p>You can shut down the HTTP connections when done by calling <a href="../persistent/#method-i-shutdown"><code>shutdown</code></a>. You should name your <a href="../persistent/"><code>Bundler::Persistent::Net::HTTP::Persistent</code></a> object if you intend to call this method.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">require 'bundler/vendor/net-http-persistent/lib/net/http/persistent'

uri = URI 'http://example.com/awesome/web/service'

http = Bundler::Persistent::Net::HTTP::Persistent.new 'my_app_name'

# perform a GET
response = http.request uri

# or

get = Net::HTTP::Get.new uri.request_uri
response = http.request get

# create a POST
post_uri = uri + 'create'
post = Net::HTTP::Post.new post_uri.path
post.set_form_data 'some' =&gt; 'cool data'

# perform the POST, the URI is always required
response http.request post_uri, post
</pre> <p>Note that for GET, HEAD and other requests that do not have a body you want to use URI#request_uri not URI#path. The request_uri contains the query params which are sent in the body for other requests.</p> <h2 id="class-Bundler::Persistent::Net::HTTP::Persistent-label-SSL">SSL</h2> <p>SSL connections are automatically created depending upon the scheme of the <a href="../../../../../uri/"><code>URI</code></a>. SSL connections are automatically verified against the default certificate store for your computer. You can override this by changing <a href="../persistent/#attribute-i-verify_mode"><code>verify_mode</code></a> or by specifying an alternate cert_store.</p> <p>Here are the SSL settings, see the individual methods for documentation:</p> <dl class="rdoc-list note-list">
<dt>
<a href="../persistent/#attribute-i-certificate"><code>certificate</code></a> </dt>
<dd> <p>This client's certificate</p> </dd>
<dt>
<a href="../persistent/#attribute-i-ca_file"><code>ca_file</code></a> </dt>
<dd> <p>The certificate-authority</p> </dd>
<dt>
<a href="../persistent/#attribute-i-cert_store"><code>cert_store</code></a> </dt>
<dd> <p>An SSL certificate store</p> </dd>
<dt>
<a href="../persistent/#attribute-i-private_key"><code>private_key</code></a> </dt>
<dd> <p>The client's SSL private key</p> </dd>
<dt>
<a href="../persistent/#attribute-i-reuse_ssl_sessions"><code>reuse_ssl_sessions</code></a> </dt>
<dd> <p>Reuse a previously opened SSL session for a new connection</p> </dd>
<dt>
<a href="../persistent/#attribute-i-ssl_version"><code>ssl_version</code></a> </dt>
<dd> <p>Which specific SSL version to use</p> </dd>
<dt>
<a href="../persistent/#attribute-i-verify_callback"><code>verify_callback</code></a> </dt>
<dd> <p>For server certificate verification</p> </dd>
<dt>
<a href="../persistent/#attribute-i-verify_mode"><code>verify_mode</code></a> </dt>
<dd> <p>How connections should be verified</p> </dd>
</dl> <h2 id="class-Bundler::Persistent::Net::HTTP::Persistent-label-Proxies">Proxies</h2> <p>A proxy can be set through <a href="../persistent/#method-i-proxy-3D"><code>proxy=</code></a> or at initialization time by providing a second argument to <a href="../persistent/#method-c-new"><code>::new</code></a>. The proxy may be the <a href="../../../../../uri/"><code>URI</code></a> of the proxy server or <code>:ENV</code> which will consult environment variables.</p> <p>See <a href="../persistent/#method-i-proxy-3D"><code>proxy=</code></a> and <a href="../persistent/#method-i-proxy_from_env"><code>proxy_from_env</code></a> for details.</p> <h2 id="class-Bundler::Persistent::Net::HTTP::Persistent-label-Headers">Headers</h2> <p>Headers may be specified for use in every request. <a href="../persistent/#attribute-i-headers"><code>headers</code></a> are appended to any headers on the request. <a href="../persistent/#attribute-i-override_headers"><code>override_headers</code></a> replace existing headers on the request.</p> <p>The difference between the two can be seen in setting the User-Agent. Using <code>http.headers['User-Agent'] = 'MyUserAgent'</code> will send “Ruby, MyUserAgent” while <code>http.override_headers['User-Agent'] = 'MyUserAgent'</code> will send “MyUserAgent”.</p> <h2 id="class-Bundler::Persistent::Net::HTTP::Persistent-label-Tuning">Tuning</h2> <h3 id="class-Bundler::Persistent::Net::HTTP::Persistent-label-Segregation">Segregation</h3> <p>By providing an application name to <a href="../persistent/#method-c-new"><code>::new</code></a> you can separate your connections from the connections of other applications.</p> <h3 id="class-Bundler::Persistent::Net::HTTP::Persistent-label-Idle+Timeout">Idle <a href="../../../../../timeout/"><code>Timeout</code></a>
</h3> <p>If a connection hasn't been used for this number of seconds it will automatically be reset upon the next use to avoid attempting to send to a closed connection. The default value is 5 seconds. nil means no timeout. <a href="../../../../../set/"><code>Set</code></a> through <a href="../persistent/#attribute-i-idle_timeout"><code>idle_timeout</code></a>.</p> <p>Reducing this value may help avoid the “too many connection resets” error when sending non-idempotent requests while increasing this value will cause fewer round-trips.</p> <h3 id="class-Bundler::Persistent::Net::HTTP::Persistent-label-Read+Timeout">Read <a href="../../../../../timeout/"><code>Timeout</code></a>
</h3> <p>The amount of time allowed between reading two chunks from the socket. <a href="../../../../../set/"><code>Set</code></a> through <a href="../persistent/#attribute-i-read_timeout"><code>read_timeout</code></a></p> <h3 id="class-Bundler::Persistent::Net::HTTP::Persistent-label-Max+Requests">Max Requests</h3> <p>The number of requests that should be made before opening a new connection. Typically many keep-alive capable servers tune this to 100 or less, so the 101st request will fail with ECONNRESET. If unset (default), this value has no effect, if set, connections will be reset on the request after max_requests.</p> <h3 id="class-Bundler::Persistent::Net::HTTP::Persistent-label-Open+Timeout">Open <a href="../../../../../timeout/"><code>Timeout</code></a>
</h3> <p>The amount of time to wait for a connection to be opened. <a href="../../../../../set/"><code>Set</code></a> through <a href="../persistent/#attribute-i-open_timeout"><code>open_timeout</code></a>.</p> <h3 id="class-Bundler::Persistent::Net::HTTP::Persistent-label-Socket+Options">
<a href="../../../../../socket/"><code>Socket</code></a> Options</h3> <p><a href="../../../../../socket/"><code>Socket</code></a> options may be set on newly-created connections. See <a href="../persistent/#attribute-i-socket_options"><code>socket_options</code></a> for details.</p> <h3 id="class-Bundler::Persistent::Net::HTTP::Persistent-label-Non-Idempotent+Requests">Non-Idempotent Requests</h3> <p>By default non-idempotent requests will not be retried per RFC 2616. By setting <a href="../persistent/#attribute-i-retry_change_requests"><code>retry_change_requests</code></a> to true requests will automatically be retried once.</p> <p>Only do this when you know that retrying a POST or other non-idempotent request is safe for your application and will not create duplicate resources.</p> <p>The recommended way to handle non-idempotent requests is the following:</p> <pre class="ruby" data-language="ruby">require 'bundler/vendor/net-http-persistent/lib/net/http/persistent'

uri = URI 'http://example.com/awesome/web/service'
post_uri = uri + 'create'

http = Bundler::Persistent::Net::HTTP::Persistent.new 'my_app_name'

post = Net::HTTP::Post.new post_uri.path
# ... fill in POST request

begin
  response = http.request post_uri, post
rescue Bundler::Persistent::Net::HTTP::Persistent::Error

  # POST failed, make a new request to verify the server did not process
  # the request
  exists_uri = uri + '...'
  response = http.get exists_uri

  # Retry if it failed
  retry if response.code == '404'
end
</pre> <p>The method of determining if the resource was created or not is unique to the particular service you are using. Of course, you will want to add protection from infinite looping.</p> <h3 id="class-Bundler::Persistent::Net::HTTP::Persistent-label-Connection+Termination">Connection Termination</h3> <p>If you are done using the <a href="../persistent/"><code>Bundler::Persistent::Net::HTTP::Persistent</code></a> instance you may shut down all the connections in the current thread with <a href="../persistent/#method-i-shutdown"><code>shutdown</code></a>. This is not recommended for normal use, it should only be used when it will be several minutes before you make another HTTP request.</p> <p>If you are using multiple threads, call <a href="../persistent/#method-i-shutdown"><code>shutdown</code></a> in each thread when the thread is done making requests. If you don't call shutdown, that's OK. Ruby will automatically garbage collect and shutdown your HTTP connections when the thread terminates.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="VERSION">VERSION </dt>
<dd>
<p>The version of <a href="../persistent/"><code>Bundler::Persistent::Net::HTTP::Persistent</code></a> you are using</p> </dd>
</dl> </section> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-ca_file"> <span class="method-name">ca_file</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>An SSL certificate authority. Setting this will set <a href="../persistent/#attribute-i-verify_mode"><code>verify_mode</code></a> to VERIFY_PEER.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-cert"> <span class="method-name">cert</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>This client's <a href="../../../../../openssl/x509/certificate/"><code>OpenSSL::X509::Certificate</code></a></p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-cert_store"> <span class="method-name">cert_store</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>An SSL certificate store. Setting this will override the default certificate store. See <a href="../persistent/#attribute-i-verify_mode"><code>verify_mode</code></a> for more information.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-certificate"> <span class="method-name">certificate</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>This client's <a href="../../../../../openssl/x509/certificate/"><code>OpenSSL::X509::Certificate</code></a></p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-debug_output"> <span class="method-name">debug_output</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sends <a href="../persistent/#attribute-i-debug_output"><code>debug_output</code></a> to this <a href="../../../../../io/"><code>IO</code></a> via <a href="../../../../../net/http/#method-i-set_debug_output"><code>Net::HTTP#set_debug_output</code></a>.</p> <p>Never use this method in production code, it causes a serious security hole.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-headers"> <span class="method-name">headers</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Headers that are added to every request using Net::HTTP#add_field</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-http_versions"> <span class="method-name">http_versions</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Maps host:port to an HTTP version. This allows us to enable version specific features.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-idle_timeout"> <span class="method-name">idle_timeout</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Maximum time an unused connection can remain idle before being automatically closed.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-keep_alive"> <span class="method-name">keep_alive</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>The value sent in the Keep-Alive header. Defaults to 30. Not needed for HTTP/1.1 servers.</p> <p>This may not work correctly for HTTP/1.0 servers</p> <p>This method may be removed in a future version as RFC 2616 does not require this header.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-key"> <span class="method-name">key</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>This client's SSL private key</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-max_requests"> <span class="method-name">max_requests</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Maximum number of requests on a connection before it is considered expired and automatically closed.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-name"> <span class="method-name">name</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>A name for this connection. Allows you to keep your connections apart from everybody else's.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-no_proxy"> <span class="method-name">no_proxy</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>List of host suffixes which will not be proxied</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-open_timeout"> <span class="method-name">open_timeout</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Seconds to wait until a connection is opened. See <a href="../../../../../net/http/#attribute-i-open_timeout"><code>Net::HTTP#open_timeout</code></a></p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-override_headers"> <span class="method-name">override_headers</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Headers that are added to every request using Net::HTTP#[]=</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-private_key"> <span class="method-name">private_key</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>This client's SSL private key</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-proxy_uri"> <span class="method-name">proxy_uri</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The URL through which requests will be proxied</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-read_timeout"> <span class="method-name">read_timeout</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Seconds to wait until reading one block. See <a href="../../../../../net/http/#attribute-i-read_timeout"><code>Net::HTTP#read_timeout</code></a></p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-retry_change_requests"> <span class="method-name">retry_change_requests</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Enable retries of non-idempotent requests that change data (e.g. POST requests) when the server has disconnected.</p> <p>This will in the worst case lead to multiple requests with the same data, but it may be useful for some applications. Take care when enabling this option to ensure it is safe to POST or perform other non-idempotent requests to the server.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-reuse_ssl_sessions"> <span class="method-name">reuse_ssl_sessions</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>By default SSL sessions are reused to avoid extra SSL handshakes. <a href="../../../../../set/"><code>Set</code></a> this to false if you have problems communicating with an HTTPS server like:</p> <pre>SSL_connect [...] read finished A: unexpected message (OpenSSL::SSL::SSLError)</pre> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-socket_options"> <span class="method-name">socket_options</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>An array of options for <a href="../../../../../basicsocket/#method-i-setsockopt"><code>Socket#setsockopt</code></a>.</p> <p>By default the TCP_NODELAY option is set on sockets.</p> <p>To set additional options append them to this array:</p> <pre class="ruby" data-language="ruby">http.socket_options &lt;&lt; [Socket::SOL_SOCKET, Socket::SO_KEEPALIVE, 1]
</pre> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-ssl_version"> <span class="method-name">ssl_version</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>SSL version to use.</p> <p>By default, the version will be negotiated automatically between client and server. Ruby 1.9 and newer only.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-verify_callback"> <span class="method-name">verify_callback</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>SSL verification callback. Used when <a href="../persistent/#attribute-i-ca_file"><code>ca_file</code></a> is set.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-verify_mode"> <span class="method-name">verify_mode</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>HTTPS verify mode. Defaults to OpenSSL::SSL::VERIFY_PEER which verifies the server certificate.</p> <p>If no <a href="../persistent/#attribute-i-ca_file"><code>ca_file</code></a> or <a href="../persistent/#attribute-i-cert_store"><code>cert_store</code></a> is set the default system certificate store is used.</p> <p>You can use <code>verify_mode</code> to override any default values.</p> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-detect_idle_timeout"> <span class="method-name">detect_idle_timeout</span><span class="method-args">(uri, max = 10)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="detect_idle_timeout-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 243
def self.detect_idle_timeout uri, max = 10
  uri = URI uri unless URI::Generic === uri
  uri += '/'

  req = Net::HTTP::Head.new uri.request_uri

  http = new 'net-http-persistent detect_idle_timeout'

  connection = http.connection_for uri

  sleep_time = 0

  loop do
    response = connection.request req

    $stderr.puts "HEAD #{uri} =&gt; #{response.code}" if $DEBUG

    unless Net::HTTPOK === response then
      raise Error, "bad response code #{response.code} detecting idle timeout"
    end

    break if sleep_time &gt;= max

    sleep_time += 1

    $stderr.puts "sleeping #{sleep_time}" if $DEBUG
    sleep sleep_time
  end
rescue
  # ignore StandardErrors, we've probably found the idle timeout.
ensure
  http.shutdown

  return sleep_time unless $!
end</pre> </div> <p>Use this method to detect the idle timeout of the host at <code>uri</code>. The value returned can be used to configure <a href="../persistent/#attribute-i-idle_timeout"><code>idle_timeout</code></a>. <code>max</code> controls the maximum idle timeout to detect.</p> <p>After</p> <p>Idle timeout detection is performed by creating a connection then performing a HEAD request in a loop until the connection terminates waiting one additional second per loop.</p> <p>NOTE: This may not work on ruby &gt; 1.9.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(name = nil, proxy = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 482
def initialize name = nil, proxy = nil
  @name = name

  @debug_output     = nil
  @proxy_uri        = nil
  @no_proxy         = []
  @headers          = {}
  @override_headers = {}
  @http_versions    = {}
  @keep_alive       = 30
  @open_timeout     = nil
  @read_timeout     = nil
  @idle_timeout     = 5
  @max_requests     = nil
  @socket_options   = []

  @socket_options &lt;&lt; [Socket::IPPROTO_TCP, Socket::TCP_NODELAY, 1] if
    Socket.const_defined? :TCP_NODELAY

  key = ['net_http_persistent', name].compact
  @generation_key     = [key, 'generations'    ].join('_').intern
  @ssl_generation_key = [key, 'ssl_generations'].join('_').intern
  @request_key        = [key, 'requests'       ].join('_').intern
  @timeout_key        = [key, 'timeouts'       ].join('_').intern

  @certificate        = nil
  @ca_file            = nil
  @private_key        = nil
  @ssl_version        = nil
  @verify_callback    = nil
  @verify_mode        = nil
  @cert_store         = nil

  @generation         = 0 # incremented when proxy URI changes
  @ssl_generation     = 0 # incremented when SSL session variables change

  if HAVE_OPENSSL then
    @verify_mode        = OpenSSL::SSL::VERIFY_PEER
    @reuse_ssl_sessions = OpenSSL::SSL.const_defined? :Session
  end

  @retry_change_requests = false

  @ruby_1 = RUBY_VERSION &lt; '2'
  @retried_on_ruby_2 = !@ruby_1

  self.proxy = proxy if proxy
end</pre> </div> <p>Creates a new <a href="../persistent/"><code>Bundler::Persistent::Net::HTTP::Persistent</code></a>.</p> <p><a href="../../../../../set/"><code>Set</code></a> <code>name</code> to keep your connections apart from everybody else's. Not required currently, but highly recommended. Your library name should be good enough. This parameter will be required in a future version.</p> <p><code>proxy</code> may be set to a <a href="../../../../../uri/http/"><code>URI::HTTP</code></a> or :ENV to pick up proxy options from the environment. See <a href="../persistent/#method-i-proxy_from_env"><code>proxy_from_env</code></a> for details.</p> <p>In order to use a <a href="../../../../../uri/"><code>URI</code></a> for the proxy you may need to do some extra work beyond <a href="../../../../../uri/"><code>URI</code></a> parsing if the proxy requires a password:</p> <pre class="ruby" data-language="ruby">proxy = URI 'http://proxy.example'
proxy.user     = 'AzureDiamond'
proxy.password = 'hunter2'
</pre>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-ca_file-3D"> <span class="method-name">ca_file=</span><span class="method-args">(file)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ca_file-3D-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 546
def ca_file= file
  @ca_file = file

  reconnect_ssl
end</pre> </div> <p>Sets the SSL certificate authority file.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-can_retry-3F"> <span class="method-name">can_retry?</span><span class="method-args">(req, retried_on_ruby_2 = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="can_retry-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 761
def can_retry? req, retried_on_ruby_2 = false
  return @retry_change_requests &amp;&amp; !idempotent?(req) if retried_on_ruby_2

  @retry_change_requests || idempotent?(req)
end</pre> </div> <p>Is the request <code>req</code> idempotent or is <a href="../persistent/#attribute-i-retry_change_requests"><code>retry_change_requests</code></a> allowed.</p> <p>If <code>retried_on_ruby_2</code> is true, true will be returned if we are on ruby, <a href="../persistent/#attribute-i-retry_change_requests"><code>retry_change_requests</code></a> is allowed and the request is not idempotent.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-cert-3D"> <span class="method-name">cert=</span><span class="method-args">(certificate)</span> </div> <div class="method-description"> <p>For <a href="../../../../../net/http/"><code>Net::HTTP</code></a> parity</p> </div> <div class="aliases"> Alias for: <a href="../persistent/#method-i-certificate-3D">certificate=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cert_store-3D"> <span class="method-name">cert_store=</span><span class="method-args">(store)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cert_store-3D-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 556
def cert_store= store
  @cert_store = store

  reconnect_ssl
end</pre> </div> <p>Overrides the default SSL certificate store used for verifying connections.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-certificate-3D"> <span class="method-name">certificate=</span><span class="method-args">(certificate)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="certificate-3D-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 534
def certificate= certificate
  @certificate = certificate

  reconnect_ssl
end</pre> </div> <p>Sets this client's <a href="../../../../../openssl/x509/certificate/"><code>OpenSSL::X509::Certificate</code></a></p>  </div> <div class="aliases"> Also aliased as: <a href="../persistent/#method-i-cert-3D">cert=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-connection_close-3F"> <span class="method-name">connection_close?</span><span class="method-args">(header)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="connection_close-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 771
def connection_close? header
  header.connection_close?
end</pre> </div> <p>Workaround for missing <a href="../../../../../net/httpheader/#method-i-connection_close-3F"><code>Net::HTTPHeader#connection_close?</code></a> on Ruby 1.8</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-connection_for"> <span class="method-name">connection_for</span><span class="method-args">(uri)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="connection_for-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 588
def connection_for uri
  Thread.current[@generation_key]     ||= Hash.new { |h,k| h[k] = {} }
  Thread.current[@ssl_generation_key] ||= Hash.new { |h,k| h[k] = {} }
  Thread.current[@request_key]        ||= Hash.new 0
  Thread.current[@timeout_key]        ||= Hash.new EPOCH

  use_ssl = uri.scheme.downcase == 'https'

  if use_ssl then
    raise Bundler::Persistent::Net::HTTP::Persistent::Error, 'OpenSSL is not available' unless
      HAVE_OPENSSL

    ssl_generation = @ssl_generation

    ssl_cleanup ssl_generation

    connections = Thread.current[@ssl_generation_key][ssl_generation]
  else
    generation = @generation

    cleanup generation

    connections = Thread.current[@generation_key][generation]
  end

  net_http_args = [uri.host, uri.port]
  connection_id = net_http_args.join ':'

  if @proxy_uri and not proxy_bypass? uri.host, uri.port then
    connection_id &lt;&lt; @proxy_connection_id
    net_http_args.concat @proxy_args
  else
    net_http_args.concat [nil, nil, nil, nil]
  end

  connection = connections[connection_id]

  unless connection = connections[connection_id] then
    connections[connection_id] = http_class.new(*net_http_args)
    connection = connections[connection_id]
    ssl connection if use_ssl
  else
    reset connection if expired? connection
  end

  start connection unless connection.started?

  connection.read_timeout = @read_timeout if @read_timeout
  connection.keep_alive_timeout = @idle_timeout if @idle_timeout &amp;&amp; connection.respond_to?(:keep_alive_timeout=)

  connection
rescue Errno::ECONNREFUSED
  address = connection.proxy_address || connection.address
  port    = connection.proxy_port    || connection.port

  raise Error, "connection refused: #{address}:#{port}"
rescue Errno::EHOSTDOWN
  address = connection.proxy_address || connection.address
  port    = connection.proxy_port    || connection.port

  raise Error, "host down: #{address}:#{port}"
end</pre> </div> <p>Creates a new connection for <code>uri</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-connection_keep_alive-3F"> <span class="method-name">connection_keep_alive?</span><span class="method-args">(header)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="connection_keep_alive-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 778
def connection_keep_alive? header
  header.connection_keep_alive?
end</pre> </div> <p>Workaround for missing <a href="../../../../../net/httpheader/#method-i-connection_keep_alive-3F"><code>Net::HTTPHeader#connection_keep_alive?</code></a> on Ruby 1.8</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-error_message"> <span class="method-name">error_message</span><span class="method-args">(connection)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="error_message-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 655
def error_message connection
  requests = Thread.current[@request_key][connection.object_id] - 1 # fixup
  last_use = Thread.current[@timeout_key][connection.object_id]

  age = Time.now - last_use

  "after #{requests} requests on #{connection.object_id}, " \
    "last used #{age} seconds ago"
end</pre> </div> <p>Returns an error message containing the number of requests performed on this connection</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-escape"> <span class="method-name">escape</span><span class="method-args">(str)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="escape-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 668
def escape str
  CGI.escape str if str
end</pre> </div> <p>URI::escape wrapper</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-expired-3F"> <span class="method-name">expired?</span><span class="method-args">(connection)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="expired-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 684
def expired? connection
  requests = Thread.current[@request_key][connection.object_id]
  return true  if     @max_requests &amp;&amp; requests &gt;= @max_requests
  return false unless @idle_timeout
  return true  if     @idle_timeout.zero?

  last_used = Thread.current[@timeout_key][connection.object_id]

  Time.now - last_used &gt; @idle_timeout
end</pre> </div> <p>Returns true if the connection should be reset due to an idle timeout, or maximum request count, false otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-finish"> <span class="method-name">finish</span><span class="method-args">(connection, thread = Thread.current)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="finish-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 716
def finish connection, thread = Thread.current
  if requests = thread[@request_key] then
    requests.delete connection.object_id
  end

  connection.finish
rescue IOError
end</pre> </div> <p>Finishes the <a href="../../../../../net/http/"><code>Net::HTTP</code></a> <code>connection</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-http_version"> <span class="method-name">http_version</span><span class="method-args">(uri)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="http_version-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 740
def http_version uri
  @http_versions["#{uri.host}:#{uri.port}"]
end</pre> </div> <p>Returns the HTTP protocol version for <code>uri</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-idempotent-3F"> <span class="method-name">idempotent?</span><span class="method-args">(req)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="idempotent-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 747
def idempotent? req
  case req
  when Net::HTTP::Delete, Net::HTTP::Get, Net::HTTP::Head,
       Net::HTTP::Options, Net::HTTP::Put, Net::HTTP::Trace then
    true
  end
end</pre> </div> <p>Is <code>req</code> idempotent according to RFC 2616?</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-key-3D"> <span class="method-name">key=</span><span class="method-args">(key)</span> </div> <div class="method-description"> <p>For <a href="../../../../../net/http/"><code>Net::HTTP</code></a> parity</p> </div> <div class="aliases"> Alias for: <a href="../persistent/#method-i-private_key-3D">private_key=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-normalize_uri"> <span class="method-name">normalize_uri</span><span class="method-args">(uri)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="normalize_uri-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 811
def normalize_uri uri
  (uri =~ /^https?:/) ? uri : "http://#{uri}"
end</pre> </div> <p>Adds “http://” to the <a href="../../../../../string/"><code>String</code></a> <code>uri</code> if it is missing.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pipeline"> <span class="method-name">pipeline</span><span class="method-args">(uri, requests) { |responses| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pipeline-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 826
def pipeline uri, requests, &amp;block # :yields: responses
  connection = connection_for uri

  connection.pipeline requests, &amp;block
end</pre> </div> <p>Pipelines <code>requests</code> to the HTTP server at <code>uri</code> yielding responses if a block is given. Returns all responses received.</p> <p>See <a href="http://docs.seattlerb.org/net-http-pipeline/Net/HTTP/Pipeline.html" target="_blank">Net::HTTP::Pipeline</a> for further details.</p> <p>Only if <code>net-http-pipeline</code> was required before <code>net-http-persistent</code> <a href="../persistent/#method-i-pipeline"><code>pipeline</code></a> will be present.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-private_key-3D"> <span class="method-name">private_key=</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="private_key-3D-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 835
def private_key= key
  @private_key = key

  reconnect_ssl
end</pre> </div> <p>Sets this client's SSL private key</p>  </div> <div class="aliases"> Also aliased as: <a href="../persistent/#method-i-key-3D">key=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-proxy-3D"> <span class="method-name">proxy=</span><span class="method-args">(proxy)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="proxy-3D-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 858
def proxy= proxy
  @proxy_uri = case proxy
               when :ENV      then proxy_from_env
               when URI::HTTP then proxy
               when nil       then # ignore
               else raise ArgumentError, 'proxy must be :ENV or a URI::HTTP'
               end

  @no_proxy.clear

  if @proxy_uri then
    @proxy_args = [
      @proxy_uri.host,
      @proxy_uri.port,
      unescape(@proxy_uri.user),
      unescape(@proxy_uri.password),
    ]

    @proxy_connection_id = [nil, *@proxy_args].join ':'

    if @proxy_uri.query then
      @no_proxy = CGI.parse(@proxy_uri.query)['no_proxy'].join(',').downcase.split(',').map { |x| x.strip }.reject { |x| x.empty? }
    end
  end

  reconnect
  reconnect_ssl
end</pre> </div> <p>Sets the proxy server. The <code>proxy</code> may be the <a href="../../../../../uri/"><code>URI</code></a> of the proxy server, the symbol <code>:ENV</code> which will read the proxy from the environment or nil to disable use of a proxy. See <a href="../persistent/#method-i-proxy_from_env"><code>proxy_from_env</code></a> for details on setting the proxy from the environment.</p> <p>If the proxy <a href="../../../../../uri/"><code>URI</code></a> is set after requests have been made, the next request will shut-down and re-open all connections.</p> <p>The <code>no_proxy</code> query parameter can be used to specify hosts which shouldn't be reached via proxy; if set it should be a comma separated list of hostname suffixes, optionally with <code>:port</code> appended, for example <code>example.com,some.host:8080</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-proxy_bypass-3F"> <span class="method-name">proxy_bypass?</span><span class="method-args">(host, port)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="proxy_bypass-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 932
def proxy_bypass? host, port
  host = host.downcase
  host_port = [host, port].join ':'

  @no_proxy.each do |name|
    return true if host[-name.length, name.length] == name or
       host_port[-name.length, name.length] == name
  end

  false
end</pre> </div> <p>Returns true when proxy should by bypassed for host.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-proxy_from_env"> <span class="method-name">proxy_from_env</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="proxy_from_env-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 905
def proxy_from_env
  env_proxy = ENV['http_proxy'] || ENV['HTTP_PROXY']

  return nil if env_proxy.nil? or env_proxy.empty?

  uri = URI normalize_uri env_proxy

  env_no_proxy = ENV['no_proxy'] || ENV['NO_PROXY']

  # '*' is special case for always bypass
  return nil if env_no_proxy == '*'

  if env_no_proxy then
    uri.query = "no_proxy=#{escape(env_no_proxy)}"
  end

  unless uri.user or uri.password then
    uri.user     = escape ENV['http_proxy_user'] || ENV['HTTP_PROXY_USER']
    uri.password = escape ENV['http_proxy_pass'] || ENV['HTTP_PROXY_PASS']
  end

  uri
end</pre> </div> <p>Creates a <a href="../../../../../uri/"><code>URI</code></a> for an HTTP proxy server from <a href="../../../../../env/"><code>ENV</code></a> variables.</p> <p>If <code>HTTP_PROXY</code> is set a proxy will be returned.</p> <p>If <code>HTTP_PROXY_USER</code> or <code>HTTP_PROXY_PASS</code> are set the <a href="../../../../../uri/"><code>URI</code></a> is given the indicated user and password unless HTTP_PROXY contains either of these in the <a href="../../../../../uri/"><code>URI</code></a>.</p> <p>The <code>NO_PROXY</code> <a href="../../../../../env/"><code>ENV</code></a> variable can be used to specify hosts which shouldn't be reached via proxy; if set it should be a comma separated list of hostname suffixes, optionally with <code>:port</code> appended, for example <code>example.com,some.host:8080</code>. When set to <code>*</code> no proxy will be returned.</p> <p>For Windows users, lowercase <a href="../../../../../env/"><code>ENV</code></a> variables are preferred over uppercase <a href="../../../../../env/"><code>ENV</code></a> variables.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reconnect"> <span class="method-name">reconnect</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="reconnect-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 947
def reconnect
  @generation += 1
end</pre> </div> <p>Forces reconnection of HTTP connections.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reconnect_ssl"> <span class="method-name">reconnect_ssl</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="reconnect_ssl-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 954
def reconnect_ssl
  @ssl_generation += 1
end</pre> </div> <p>Forces reconnection of SSL connections.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-request"> <span class="method-name">request</span><span class="method-args">(uri, req = nil, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="request-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 990
def request uri, req = nil, &amp;block
  retried      = false
  bad_response = false

  req = request_setup req || uri

  connection = connection_for uri
  connection_id = connection.object_id

  begin
    Thread.current[@request_key][connection_id] += 1
    response = connection.request req, &amp;block

    if connection_close?(req) or
       (response.http_version &lt;= '1.0' and
        not connection_keep_alive?(response)) or
       connection_close?(response) then
      connection.finish
    end
  rescue Net::HTTPBadResponse =&gt; e
    message = error_message connection

    finish connection

    raise Error, "too many bad responses #{message}" if
      bad_response or not can_retry? req

    bad_response = true
    retry
  rescue *RETRIED_EXCEPTIONS =&gt; e # retried on ruby 2
    request_failed e, req, connection if
      retried or not can_retry? req, @retried_on_ruby_2

    reset connection

    retried = true
    retry
  rescue Errno::EINVAL, Errno::ETIMEDOUT =&gt; e # not retried on ruby 2
    request_failed e, req, connection if retried or not can_retry? req

    reset connection

    retried = true
    retry
  rescue Exception =&gt; e
    finish connection

    raise
  ensure
    Thread.current[@timeout_key][connection_id] = Time.now
  end

  @http_versions["#{uri.host}:#{uri.port}"] ||= response.http_version

  response
end</pre> </div> <p>Makes a request on <code>uri</code>. If <code>req</code> is nil a <a href="../../../../../net/http/get/"><code>Net::HTTP::Get</code></a> is performed against <code>uri</code>.</p> <p>If a block is passed <a href="../persistent/#method-i-request"><code>request</code></a> behaves like <a href="../../../../../net/http/#method-i-request"><code>Net::HTTP#request</code></a> (the body of the response will not have been read).</p> <p><code>req</code> must be a <a href="../../../../../net/httprequest/"><code>Net::HTTPRequest</code></a> subclass (see <a href="../../../../../net/http/"><code>Net::HTTP</code></a> for a list).</p> <p>If there is an error and the request is idempotent according to RFC 2616 it will be retried automatically.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reset"> <span class="method-name">reset</span><span class="method-args">(connection)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="reset-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 961
def reset connection
  Thread.current[@request_key].delete connection.object_id
  Thread.current[@timeout_key].delete connection.object_id

  finish connection

  start connection
rescue Errno::ECONNREFUSED
  e = Error.new "connection refused: #{connection.address}:#{connection.port}"
  e.set_backtrace $@
  raise e
rescue Errno::EHOSTDOWN
  e = Error.new "host down: #{connection.address}:#{connection.port}"
  e.set_backtrace $@
  raise e
end</pre> </div> <p>Finishes then restarts the <a href="../../../../../net/http/"><code>Net::HTTP</code></a> <code>connection</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-shutdown"> <span class="method-name">shutdown</span><span class="method-args">(thread = Thread.current)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="shutdown-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 1105
def shutdown thread = Thread.current
  generation = reconnect
  cleanup generation, thread, @generation_key

  ssl_generation = reconnect_ssl
  cleanup ssl_generation, thread, @ssl_generation_key

  thread[@request_key] = nil
  thread[@timeout_key] = nil
end</pre> </div> <p>Shuts down all connections for <code>thread</code>.</p> <p>Uses the current thread by default.</p> <p>If you've used <a href="../persistent/"><code>Bundler::Persistent::Net::HTTP::Persistent</code></a> across multiple threads you should call this in each thread when you're done making HTTP requests.</p> <p><strong>NOTE</strong>: Calling shutdown for another thread can be dangerous!</p> <p>If the thread is still using the connection it may cause an error! It is best to call <a href="../persistent/#method-i-shutdown"><code>shutdown</code></a> in the thread at the appropriate time instead!</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-shutdown_in_all_threads"> <span class="method-name">shutdown_in_all_threads</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="shutdown_in_all_threads-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 1126
def shutdown_in_all_threads
  Thread.list.each do |thread|
    shutdown thread
  end

  nil
end</pre> </div> <p>Shuts down all connections in all threads</p> <p><strong>NOTE</strong>: THIS METHOD IS VERY DANGEROUS!</p> <p>Do not call this method if other threads are still using their connections! Call <a href="../persistent/#method-i-shutdown"><code>shutdown</code></a> at the appropriate time instead!</p> <p>Use this method only as a last resort!</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ssl"> <span class="method-name">ssl</span><span class="method-args">(connection)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ssl-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 1137
  def ssl connection
    connection.use_ssl = true

    connection.ssl_version = @ssl_version if @ssl_version

    connection.verify_mode = @verify_mode

    if OpenSSL::SSL::VERIFY_PEER == OpenSSL::SSL::VERIFY_NONE and
       not Object.const_defined?(:I_KNOW_THAT_OPENSSL_VERIFY_PEER_EQUALS_VERIFY_NONE_IS_WRONG) then
      warn &lt;&lt;-WARNING
                             !!!SECURITY WARNING!!!

The SSL HTTP connection to:

  #{connection.address}:#{connection.port}

                           !!!MAY NOT BE VERIFIED!!!

On your platform your OpenSSL implementation is broken.

There is no difference between the values of VERIFY_NONE and VERIFY_PEER.

This means that attempting to verify the security of SSL connections may not
work.  This exposes you to man-in-the-middle exploits, snooping on the
contents of your connection and other dangers to the security of your data.

To disable this warning define the following constant at top-level in your
application:

  I_KNOW_THAT_OPENSSL_VERIFY_PEER_EQUALS_VERIFY_NONE_IS_WRONG = nil

      WARNING
    end

    if @ca_file then
      connection.ca_file = @ca_file
      connection.verify_mode = OpenSSL::SSL::VERIFY_PEER
      connection.verify_callback = @verify_callback if @verify_callback
    end

    if @certificate and @private_key then
      connection.cert = @certificate
      connection.key  = @private_key
    end

    connection.cert_store = if @cert_store then
                              @cert_store
                            else
                              store = OpenSSL::X509::Store.new
                              store.set_default_paths
                              store
                            end
  end</pre> </div> <p>Enables SSL on <code>connection</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ssl_version-3D"> <span class="method-name">ssl_version=</span><span class="method-args">(ssl_version)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ssl_version-3D-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 1202
def ssl_version= ssl_version
  @ssl_version = ssl_version

  reconnect_ssl
end</pre> </div> <p>SSL version to use</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-start"> <span class="method-name">start</span><span class="method-args">(connection)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="start-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 698
def start connection
  connection.set_debug_output @debug_output if @debug_output
  connection.open_timeout = @open_timeout if @open_timeout

  connection.start

  socket = connection.instance_variable_get :@socket

  if socket then # for fakeweb
    @socket_options.each do |option|
      socket.io.setsockopt(*option)
    end
  end
end</pre> </div> <p>Starts the <a href="../../../../../net/http/"><code>Net::HTTP</code></a> <code>connection</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-unescape"> <span class="method-name">unescape</span><span class="method-args">(str)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="unescape-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 675
def unescape str
  CGI.unescape str if str
end</pre> </div> <p>URI::unescape wrapper</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-verify_callback-3D"> <span class="method-name">verify_callback=</span><span class="method-args">(callback)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="verify_callback-3D-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 1224
def verify_callback= callback
  @verify_callback = callback

  reconnect_ssl
end</pre> </div> <p>SSL verification callback.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-verify_mode-3D"> <span class="method-name">verify_mode=</span><span class="method-args">(verify_mode)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="verify_mode-3D-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb, line 1215
def verify_mode= verify_mode
  @verify_mode = verify_mode

  reconnect_ssl
end</pre> </div> <p>Sets the HTTPS verify mode. Defaults to OpenSSL::SSL::VERIFY_PEER.</p> <p>Setting this to VERIFY_NONE is a VERY BAD IDEA and should NEVER be used. Securely transfer the correct certificate and update the default certificate store or set the ca file instead.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core © 1993–2017 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library © contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
