
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Tutorial - Fish 3.0 - W3cubDocs</title>
  
  <meta name="description" content="fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. fish supports powerful features like syntax &hellip;">
  <meta name="keywords" content="fish, tutorial, -, fish~3.0">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/fish~3.0/tutorial/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/fish~3.0.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/fish~3.0/" class="_nav-link" title="" style="margin-left:0;">Fish 3.0</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="interior_title">fish tutorial</h1> <h2 id="tut_why_fish">
 Why fish?</h2> <p><code>fish</code> is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. <code>fish</code> supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.</p> <p>If you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then <code>fish</code> might be just what you're looking for!</p> <h2 id="tut_getting_started">
 Getting started</h2> <p>Once installed, just type in <code>fish</code> into your current shell to try it out!</p> <p>You will be greeted by the standard fish prompt, which means you are all set up and can start using fish:</p> <pre class="fish cli-dark" data-language="fish">
&gt; fish
Welcome to fish, the friendly interactive shell
Type help for instructions on how to use fish
you@hostname ~&gt; 
</pre>
<p>This prompt that you see above is the <code>fish</code> default prompt: it shows your username, hostname, and working directory.</p>
<ul> <li>to change this prompt see <a href="#tut_prompt">how to change your prompt</a>
</li> <li>to switch to fish permanently see <a href="#tut_switching_to_fish">switch your default shell to fish</a>
</li> </ul> <p>From now on, we'll pretend your prompt is just a '<code>&gt;</code>' to save space.</p> <h2 id="tut_learning_Fish">
 Learning fish</h2> <p>This tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of <code>fish</code>.</p> <p>If you have a strong understanding of other shells, and want to know what <code>fish</code> does differently, search for the magic phrase <em>unlike other shells</em>, which is used to call out important differences.</p> <h2 id="tut_running_commands">
 Running Commands</h2> <p><code>fish</code> runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:</p> <pre class="fish cli-dark" data-language="fish">
&gt; echo hello world
hello world
</pre>
<p>You can include a literal space in an argument with a backslash, or by using single or double quotes:</p> <pre class="fish cli-dark" data-language="fish">
&gt; mkdir My\ Files
&gt; cp ~/Some\ File 'My Files'
&gt; ls "My Files"
Some File
</pre>
<p>Commands can be chained with semicolons.</p> <h2 id="tut_getting_help">
 Getting Help</h2> <p><code>fish</code> has excellent help and man pages. Run <code>help</code> to open help in a web browser, and <code>man</code> to open it in a man page. You can also ask for help with a specific command, for example, <code>help set</code> to open in a web browser, or <code>man set</code> to see it in the terminal.</p> <pre class="fish cli-dark" data-language="fish">
&gt; man set
set - handle shell variables
  Synopsis...
</pre>
<h2 id="tut_syntax_highlighting">
 Syntax Highlighting</h2> <p>You'll quickly notice that <code>fish</code> performs syntax highlighting as you type. Invalid commands are colored red by default:</p> <pre class="fish cli-dark" data-language="fish">
&gt; /bin/mkd
</pre>
<p>A command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:</p> <pre class="fish cli-dark" data-language="fish">
&gt; /bin/mkdir
</pre>
<p><code>fish</code> will underline valid file paths as you type them:</p> <pre class="fish cli-dark" data-language="fish">
&gt; cat ~/somefi 
</pre>
<p>This tells you that there exists a file that starts with '<code>somefi</code>', which is useful feedback as you type.</p> <p>These colors, and many more, can be changed by running <code>fish_config</code>, or by modifying variables directly.</p> <h2 id="tut_wildcards">
 Wildcards</h2> <p><code>fish</code> supports the familiar wildcard <code>*</code>. To list all JPEG files:</p> <pre class="fish cli-dark" data-language="fish">
&gt; ls *.jpg
lena.jpg
meena.jpg
santa maria.jpg
</pre>
<p>You can include multiple wildcards:</p> <pre class="fish cli-dark" data-language="fish">
&gt; ls l*.p*
lena.png
lesson.pdf
</pre>
<p>Especially powerful is the recursive wildcard ** which searches directories recursively:</p> <pre class="fish cli-dark" data-language="fish">
&gt; ls /var/**.log
/var/log/system.log
/var/run/sntp.log
</pre>
<p>If that directory traversal is taking a long time, you can <span class="key"><em>Control</em><span>-</span><b>C</b></span> out of it.</p> <h2 id="tut_pipes_and_redirections">
 Pipes and Redirections</h2> <p>You can pipe between commands with the usual vertical bar:</p> <pre class="fish cli-dark" data-language="fish">
&gt; echo hello world | wc
       1       2      12
</pre>
<p>stdin and stdout can be redirected via the familiar &lt; and &gt;. stderr is redirected with a &gt;2.</p> <pre class="fish cli-dark" data-language="fish">
&gt; grep fish &lt; /etc/shells &gt; ~/output.txt 2&gt; ~/errors.txt
</pre>
<h2 id="tut_autosuggestions">
 Autosuggestions</h2> <p><code>fish</code> suggests commands as you type, and shows the suggestion to the right of the cursor, in gray. For example:</p> <pre class="fish cli-dark" data-language="fish">
&gt; /bin/hostname
</pre>
<p>It knows about paths and options:</p> <pre class="fish cli-dark" data-language="fish">
&gt; grep --ignore-case
</pre>
<p>And history too. Type a command once, and you can re-summon it by just typing a few letters:</p> <pre class="fish cli-dark" data-language="fish">
&gt; r&lt;\@args{ync} \ ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo}
</pre>
<p>To accept the autosuggestion, hit <span class="key"><b>→</b></span> or <span class="key"><em>Control</em><span>-</span><b>F</b></span>. To accept a single word of the autosuggestion, <span class="key"><em>Alt</em><span>-</span><b>→</b></span> (right arrow). If the autosuggestion is not what you want, just ignore it.</p> <h2 id="tut_tab_completions">
 Tab Completions</h2> <p><code>fish</code> comes with a rich set of tab completions, that work "out of the box."</p> <p>Press <span class="key"><b>Tab</b></span>, and <code>fish</code> will attempt to complete the command, argument, or path:</p> <pre class="fish cli-dark" data-language="fish">
&gt; /pri @key{Tab} → /private/
</pre>
<p>If there's more than one possibility, it will list them:</p> <pre class="fish cli-dark" data-language="fish">
&gt; ~/stuff/s @key{Tab}
~/stuff/script.sh  (Executable, 4.8kB)  ~/stuff/sources/  (Directory)
</pre>
<p>Hit tab again to cycle through the possibilities.</p> <p><code>fish</code> can also complete many commands, like git branches:</p> <pre class="fish cli-dark" data-language="fish">
&gt; git merge pr @key{Tab} → git merge prompt_designer
&gt; git checkout b @key{Tab}
builtin_list_io_merge (Branch) builtin_set_color (Branch) busted_events (Tag)
</pre>
<p>Try hitting tab and see what <code>fish</code> can do!</p> <h2 id="tut_variables">
 Variables</h2> <p>Like other shells, a dollar sign performs variable substitution:</p> <pre class="fish cli-dark" data-language="fish">
&gt; echo My home directory is $HOME
My home directory is /home/tutorial
</pre>
<p>Variable substitution also occurs in double quotes, but not single quotes:</p> <pre class="fish cli-dark" data-language="fish">
&gt; echo "My current directory is $PWD"
My current directory is /home/tutorial
&gt; echo 'My current directory is $PWD'
My current directory is $PWD
</pre>
<p>Unlike other shells, <code>fish</code> has no dedicated syntax for setting variables. Instead it has an ordinary command: <code>set</code>, which takes a variable name, and then its value.</p> <pre class="fish cli-dark" data-language="fish">
&gt; set name 'Mister Noodle'
&gt; echo $name
Mister Noodle
</pre>
<p>(Notice the quotes: without them, <code>Mister</code> and <code>Noodle</code> would have been separate arguments, and <code>$name</code> would have been made into a list of two elements.)</p> <p>Unlike other shells, variables are not further split after substitution:</p> <pre class="fish cli-dark" data-language="fish">
&gt; mkdir $name
&gt; ls
Mister Noodle
</pre>
<p>In bash, this would have created two directories "Mister" and "Noodle". In <code>fish</code>, it created only one: the variable had the value "Mister Noodle", so that is the argument that was passed to <code>mkdir</code>, spaces and all. Other shells use the term "arrays", rather than lists.</p> <h2 id="tut_exit_status">
 Exit Status</h2> <p>Unlike other shells, <code>fish</code> stores the exit status of the last command in <code>$status</code> instead of <code>$?</code>.</p> <pre class="fish cli-dark" data-language="fish">
&gt; false
&gt; echo $status
1
</pre>
<p>Zero is considered success, and non-zero is failure.</p> <h2 id="tut_exports">
 Exports (Shell Variables)</h2> <p>Unlike other shells, <code>fish</code> does not have an export command. Instead, a variable is exported via an option to <code>set</code>, either <code>--export</code> or just <code>-x</code>.</p> <pre class="fish cli-dark" data-language="fish">
&gt; set -x MyVariable SomeValue
&gt; env | grep MyVariable
MyVariable=SomeValue
</pre>
<p>You can erase a variable with <code>-e</code> or <code>--erase</code></p> <pre class="fish cli-dark" data-language="fish">
&gt; set -e MyVariable
&gt; env | grep MyVariable
(no output)
</pre>
<h2 id="tut_lists">
 Lists</h2> <p>The <code>set</code> command above used quotes to ensure that <code>Mister Noodle</code> was one argument. If it had been two arguments, then <code>name</code> would have been a list of length 2. In fact, all variables in <code>fish</code> are really lists, that can contain any number of values, or none at all.</p> <p>Some variables, like <code>$PWD</code>, only have one value. By convention, we talk about that variable's value, but we really mean its first (and only) value.</p> <p>Other variables, like <code>$PATH</code>, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:</p> <pre class="fish cli-dark" data-language="fish">
&gt; echo $PATH
/usr/bin /bin /usr/sbin /sbin /usr/local/bin
</pre>
<p>Note that there are three environment variables that are automatically split on colons to become lists when fish starts running: <code>PATH</code>, <code>CDPATH</code>, <code>MANPATH</code>. Conversely, they are joined on colons when exported to subcommands. All other environment variables (e.g., <code>LD_LIBRARY_PATH</code>) which have similar semantics are treated as simple strings.</p> <p>Lists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.</p> <p>Get the length of a list with <code>count</code>:</p> <pre class="fish cli-dark" data-language="fish">
&gt; count $PATH
5
</pre>
<p>You can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to $PATH:</p> <pre class="fish cli-dark" data-language="fish">
&gt; set PATH $PATH /usr/local/bin
</pre>
<p>You can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:</p> <pre class="fish cli-dark" data-language="fish">
&gt; echo $PATH
/usr/bin /bin /usr/sbin /sbin /usr/local/bin
&gt; echo $PATH[1]
/usr/bin
&gt; echo $PATH[-1]
/usr/local/bin
</pre>
<p>You can also access ranges of elements, known as "slices:"</p> <pre class="fish cli-dark" data-language="fish">
&gt; echo $PATH[1..2]
/usr/bin /bin
&gt; echo $PATH[-1..2]
/usr/local/bin /sbin /usr/sbin /bin
</pre>
<p>You can iterate over a list (or a slice) with a for loop:</p> <pre class="fish cli-dark" data-language="fish">
&gt; for val in $PATH
    echo "entry: $val"
  end
entry: /usr/bin/
entry: /bin
entry: /usr/sbin
entry: /sbin
entry: /usr/local/bin
</pre>
<p>Lists adjacent to other lists or strings are expanded as <a href="../#cartesian-product">cartesian products</a> unless quoted (see <a href="../#expand-variable">Variable expansion</a>):</p> <pre class="fish cli-dark" data-language="fish">
&gt; set a 1 2 3
&gt; set 1 a b c
&gt; echo $a$1
1a 2a 3a 1b 2b 3b 1c 2c 3c
&gt; echo $a" banana"
1 banana 2 banana 3 banana
&gt; echo "$a banana"
1 2 3 banana
</pre>
<p>This is similar to <a href="../#expand-brace">Brace expansion</a>.</p> <h2 id="tut_command_substitutions">
 Command Substitutions</h2> <p>Command substitutions use the output of one command as an argument to another. Unlike other shells, <code>fish</code> does not use backticks ` for command substitutions. Instead, it uses parentheses:</p> <pre class="fish cli-dark" data-language="fish">
&gt; echo In (pwd), running (uname)
In /home/tutorial, running FreeBSD
</pre>
<p>A common idiom is to capture the output of a command in a variable:</p> <pre class="fish cli-dark" data-language="fish">
&gt; set os (uname)
&gt; echo $os
Linux
</pre>
<p>Command substitutions are not expanded within quotes. Instead, you can temporarily close the quotes, add the command substitution, and reopen them, all in the same argument:</p> <pre class="fish cli-dark" data-language="fish">
&gt; touch "testing_"(date +%s)".txt"
&gt; ls *.txt
testing_1360099791.txt
</pre>
<p>Unlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. This can be an issue with commands like <code>pkg-config</code> that print what is meant to be multiple arguments on a single line. To split it on spaces too, use <code>string split</code>.</p> <pre class="fish cli-dark" data-language="fish">
&gt; printf '%s\n' (pkg-config --libs gio-2.0)
-lgio-2.0 -lgobject-2.0 -lglib-2.0
&gt; printf '%s\n' (pkg-config --libs gio-2.0 | string split " ")
-lgio-2.0
-lgobject-2.0
-lglib-2.0
</pre>
<h2 id="tut_semicolon">
 Separating Commands (Semicolon)</h2> <p>Like other shells, fish allows multiple commands either on separate lines or the same line.</p> <p>To write them on the same line, use the semicolon (";"). That means the following two examples are equivalent:</p> <pre class="fish" data-language="fish">
echo fish; echo chips

# or
echo fish
echo chips
</pre>
<h2 id="tut_combiners">
 Combiners (And, Or, Not)</h2> <p>fish supports the familiar <code>&amp;&amp;</code> and <code>||</code> to combine commands, and <code>!</code> to negate them:</p> <pre class="fish cli-dark" data-language="fish">
&gt; ./configure &amp;&amp; make &amp;&amp; sudo make install
</pre>
<p>fish also supports <code>and</code>, <code>or</code>, and <code>not</code>. The first two are job modifiers and have lower precedence. Example usage:</p> <pre class="fish cli-dark" data-language="fish">
&gt; cp file1.txt file1_bak.txt &amp;&amp; cp file2.txt file2_bak.txt ; and echo "Backup successful"; or echo "Backup failed"
Backup failed
</pre>
<p>As mentioned in <a href="#tut_semicolon">the section on the semicolon</a>, this can also be written in multiple lines, like so:</p> <pre class="fish" data-language="fish">
cp file1.txt file1_bak.txt &amp;&amp; cp file2.txt file2_bak.txt
and echo "Backup successful"
or echo "Backup failed"
</pre>
<h2 id="tut_conditionals">
 Conditionals (If, Else, Switch)</h2> <p>Use <code>if</code>, <code>else if</code>, and <code>else</code> to conditionally execute code, based on the exit status of a command.</p> <pre class="fish cli-dark" data-language="fish">
if grep fish /etc/shells
    echo Found fish
else if grep bash /etc/shells
    echo Found bash
else
    echo Got nothing
end
</pre>
<p>To compare strings or numbers or check file properties (whether a file exists or is writeable and such), use <a href="../commands/#test">test</a>, like</p> <pre class="fish cli-dark" data-language="fish">
if test "$fish" = "flounder"
    echo FLOUNDER
end

# or

if test "$number" -gt 5
    echo $number is greater than five
else
    echo $number is five or less
end
</pre>
<p><a href="#tut_combiners">Combiners</a> can also be used to make more complex conditions, like</p> <pre class="fish" data-language="fish">
if grep fish /etc/shells; and command -sq fish
    echo fish is installed and configured
end
</pre>
<p>For even more complex conditions, use <code>begin</code> and <code>end</code> to group parts of them.</p> <p>There is also a <code>switch</code> command:</p> <pre class="fish cli-dark" data-language="fish">
switch (uname)
case Linux
    echo Hi Tux!
case Darwin
    echo Hi Hexley!
case FreeBSD NetBSD DragonFly
    echo Hi Beastie!
case '*'
    echo Hi, stranger!
end
</pre>
<p>Note that <code>case</code> does not fall through, and can accept multiple arguments or (quoted) wildcards.</p> <h2 id="tut_functions">
 Functions</h2> <p>A <code>fish</code> function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in "numbered variables" like <code>$1</code>, but instead in a single list <code>$argv</code>. To create a function, use the <code>function</code> builtin:</p> <pre class="fish cli-dark" data-language="fish">
&gt; function say_hello
     echo Hello $argv
  end
&gt; say_hello
Hello
&gt; say_hello everybody!
Hello everybody!
</pre>
<p>Unlike other shells, <code>fish</code> does not have aliases or special prompt syntax. Functions take their place.</p> <p>You can list the names of all functions with the <code>functions</code> keyword (note the plural!). <code>fish</code> starts out with a number of functions:</p> <pre class="fish cli-dark" data-language="fish">
&gt; functions
alias, cd, delete-or-exit, dirh, dirs, down-or-search, eval, export, fish_command_not_found_setup, fish_config, fish_default_key_bindings, fish_prompt, fish_right_prompt, fish_sigtrap_handler, fish_update_completions, funced, funcsave, grep, help, history, isatty, ls, man, math, nextd, nextd-or-forward-word, open, popd, prevd, prevd-or-backward-word, prompt_pwd, psub, pushd, seq, setenv, trap, type, umask, up-or-search, vared
</pre>
<p>You can see the source for any function by passing its name to <code>functions</code>:</p> <pre class="fish cli-dark" data-language="fish">
&gt; functions ls
function ls --description 'List contents of directory'
    command ls -G $argv
end
</pre>
<h2 id="tut_loops">
 Loops</h2> <p>While loops:</p> <pre class="fish cli-dark" data-language="fish">
&gt; while true
    echo "Loop forever"
end
Loop forever
Loop forever
Loop forever
...
</pre>
<p>For loops can be used to iterate over a list. For example, a list of files:</p> <pre class="fish cli-dark" data-language="fish">
&gt; for file in *.txt
    cp $file $file.bak
end
</pre>
<p>Iterating over a list of numbers can be done with <code>seq</code>:</p> <pre class="fish cli-dark" data-language="fish">
&gt; for x in (seq 5)
    touch file_$x.txt
end
</pre>
<h2 id="tut_prompt">
 Prompt</h2> <p>Unlike other shells, there is no prompt variable like PS1. To display your prompt, <code>fish</code> executes a function with the name <code>fish_prompt</code>, and its output is used as the prompt.</p> <p>You can define your own prompt:</p> <pre class="fish cli-dark" data-language="fish">
&gt; function fish_prompt
    echo "New Prompt % "
end
New Prompt %  
</pre>
<p>Multiple lines are OK. Colors can be set via <code>set_color</code>, passing it named ANSI colors, or hex RGB values:</p> <pre class="fish cli-dark" data-language="fish">
&gt; function fish_prompt
      set_color purple
      date "+%m/%d/%y"
      set_color FF0
      echo (pwd) '&gt;'
      set_color normal
  end
02/06/13
/home/tutorial &gt; 
</pre>
<p>You can choose among some sample prompts by running <code>fish_config prompt</code>. <code>fish</code> also supports RPROMPT through <code>fish_right_prompt</code>.</p> <h2 id="tut_path">
 $PATH</h2> <p><code>$PATH</code> is an environment variable containing the directories in which <code>fish</code> searches for commands. Unlike other shells, $PATH is a <a href="#tut_lists">list</a>, not a colon-delimited string.</p> <p>To prepend /usr/local/bin and /usr/sbin to <code>$PATH</code>, you can write:</p> <pre class="fish cli-dark" data-language="fish">
&gt; set PATH /usr/local/bin /usr/sbin $PATH
</pre>
<p>To remove /usr/local/bin from <code>$PATH</code>, you can write:</p> <pre class="fish cli-dark" data-language="fish">
&gt; set PATH (string match -v /usr/local/bin $PATH)
</pre>
<p>You can do so directly in <code>config.fish</code>, like you might do in other shells with <code>.profile</code>. See <a href="#path_example">this example</a>.</p> <p>A faster way is to modify the <code>$fish_user_paths</code> <a href="#tut_universal">universal variable</a>, which is automatically prepended to <code>$PATH</code>. For example, to permanently add <code>/usr/local/bin</code> to your <code>$PATH</code>, you could write:</p> <pre class="fish cli-dark" data-language="fish">
&gt; set -U fish_user_paths /usr/local/bin $fish_user_paths
</pre>
<p>The advantage is that you don't have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. (Note: you should NOT add this line to <code>config.fish</code>. If you do, the variable will get longer each time you run fish!)</p> <h2 id="tut_startup">
 Startup (Where's .bashrc?)</h2> <p><code>fish</code> starts by executing commands in <code>~/.config/fish/config.fish</code>. You can create it if it does not exist.</p> <p>It is possible to directly create functions and variables in <code>config.fish</code> file, using the commands shown above. For example:</p>  <pre class="fish cli-dark" data-language="fish">
&gt; cat ~/.config/fish/config.fish

set -x PATH $PATH /sbin/

function ll
    ls -lh $argv
end
</pre>
<p>However, it is more common and efficient to use autoloading functions and universal variables.</p> <h2 id="tut_autoload">
 Autoloading Functions</h2> <p>When <code>fish</code> encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in <code>~/.config/fish/functions/</code>.</p> <p>For example, if you wanted to have a function <code>ll</code>, you would add a text file <code>ll.fish</code> to <code>~/.config/fish/functions</code>:</p> <pre class="fish cli-dark" data-language="fish">
&gt; cat ~/.config/fish/functions/ll.fish
function ll
    ls -lh $argv
end
</pre>
<p>This is the preferred way to define your prompt as well:</p> <pre class="fish cli-dark" data-language="fish">
&gt; cat ~/.config/fish/functions/fish_prompt.fish
function fish_prompt
    echo (pwd) "&gt; "
end
</pre>
<p>See the documentation for <a href="../commands/#funced">funced</a> and <a href="../commands/#funcsave">funcsave</a> for ways to create these files automatically.</p> <h2 id="tut_universal">
 Universal Variables</h2> <p>A universal variable is a variable whose value is shared across all instances of <code>fish</code>, now and in the future – even after a reboot. You can make a variable universal with <code>set -U</code>:</p> <pre class="fish cli-dark" data-language="fish">
&gt; set -U EDITOR vim
</pre>
<p>Now in another shell:</p> <pre class="fish cli-dark" data-language="fish">
&gt; echo $EDITOR
vim
</pre>
<h2 id="tut_switching_to_fish">
 Switching to fish?</h2> <p>If you wish to use fish (or any other shell) as your default shell, you need to enter your new shell's executable <code>/usr/local/bin/fish</code> in two places:</p>
<ul> <li>add <code>/usr/local/bin/fish</code> to <code>/etc/shells</code>
</li> <li>change your default shell with <code>chsh -s</code> to <code>/usr/local/bin/fish</code>
</li> </ul> <p>You can use the following commands for this:</p> <p>Add the fish shell <code>/usr/local/bin/fish</code> to <code>/etc/shells</code> with:</p> <pre class="fish cli-dark" data-language="fish">
&gt;echo /usr/local/bin/fish | sudo tee -a /etc/shells
</pre>
<p>Change your default shell to fish with:</p> <pre class="fish cli-dark" data-language="fish">
&gt;chsh -s /usr/local/bin/fish
</pre>
<p>(To change it back to another shell, just substitute <code>/usr/local/bin/fish</code> with <code>/bin/bash</code>, <code>/bin/tcsh</code> or <code>/bin/zsh</code> as appropriate in the steps above.)</p> <h2 id="tut_more">
 Ready for more?</h2> <p>If you want to learn more about fish, there is <a href="../">lots of detailed documentation</a>, an <a href="https://lists.sourceforge.net/lists/listinfo/fish-users" target="_blank">official mailing list</a>, the IRC channel #fish on <code>irc.oftc.net</code>, and the <a href="https://github.com/fish-shell/fish-shell/" target="_blank">github page</a>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2005–2009 Axel Liljencrantz<br>Licensed under the GNU General Public License, version 2.<br>
    <a href="https://fishshell.com/docs/3.0/tutorial.html" class="_attribution-link" target="_blank">https://fishshell.com/docs/3.0/tutorial.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
