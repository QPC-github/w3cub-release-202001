
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>TypeScript 2.0 - TypeScript - W3cubDocs</title>
  
  <meta name="description" content="TypeScript has two special types, Null and Undefined, that have the values null and undefined respectively. Previously it was not possible to &hellip;">
  <meta name="keywords" content="typescript, -">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/typescript/handbook/release-notes/typescript-2-0/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/typescript.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/typescript/" class="_nav-link" title="" style="margin-left:0;">TypeScript</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="post-title"> TypeScript 2.0 </h1>   <h2 id="null--and-undefined-aware-types"> Null- and undefined-aware types  </h2> <p>TypeScript has two special types, Null and Undefined, that have the values <code>null</code> and <code>undefined</code> respectively. Previously it was not possible to explicitly name these types, but <code>null</code> and <code>undefined</code> may now be used as type names regardless of type checking mode.</p> <p>The type checker previously considered <code>null</code> and <code>undefined</code> assignable to anything. Effectively, <code>null</code> and <code>undefined</code> were valid values of <em>every</em> type and it wasn’t possible to specifically exclude them (and therefore not possible to detect erroneous use of them).</p> <h2 id="--strictnullchecks"> <code>--strictNullChecks</code>  </h2> <p><code>--strictNullChecks</code> switches to a new strict null checking mode.</p> <p>In strict null checking mode, the <code>null</code> and <code>undefined</code> values are <em>not</em> in the domain of every type and are only assignable to themselves and <code>any</code> (the one exception being that <code>undefined</code> is also assignable to <code>void</code>). So, whereas <code>T</code> and <code>T | undefined</code> are considered synonymous in regular type checking mode (because <code>undefined</code> is considered a subtype of any <code>T</code>), they are different types in strict type checking mode, and only <code>T | undefined</code> permits <code>undefined</code> values. The same is true for the relationship of <code>T</code> to <code>T | null</code>.</p> <h5 id="example"> Example  </h5> <pre data-language="typescript">// Compiled with --strictNullChecks
let x: number;
let y: number | undefined;
let z: number | null | undefined;
x = 1;  // Ok
y = 1;  // Ok
z = 1;  // Ok
x = undefined;  // Error
y = undefined;  // Ok
z = undefined;  // Ok
x = null;  // Error
y = null;  // Error
z = null;  // Ok
x = y;  // Error
x = z;  // Error
y = x;  // Ok
y = z;  // Error
z = x;  // Ok
z = y;  // Ok
</pre> <h2 id="assigned-before-use-checking"> Assigned-before-use checking  </h2> <p>In strict null checking mode the compiler requires every reference to a local variable of a type that doesn’t include <code>undefined</code> to be preceded by an assignment to that variable in every possible preceding code path.</p> <h5 id="example-1"> Example  </h5> <pre data-language="typescript">// Compiled with --strictNullChecks
let x: number;
let y: number | null;
let z: number | undefined;
x;  // Error, reference not preceded by assignment
y;  // Error, reference not preceded by assignment
z;  // Ok
x = 1;
y = null;
x;  // Ok
y;  // Ok
</pre> <p>The compiler checks that variables are definitely assigned by performing <em>control flow based type analysis</em>. See later for further details on this topic.</p> <h2 id="optional-parameters-and-properties"> Optional parameters and properties  </h2> <p>Optional parameters and properties automatically have <code>undefined</code> added to their types, even when their type annotations don’t specifically include <code>undefined</code>. For example, the following two types are identical:</p> <pre data-language="typescript">// Compiled with --strictNullChecks
type T1 = (x?: number) =&gt; string;        // x has type number | undefined
type T2 = (x?: number | undefined) =&gt; string;  // x has type number | undefined
</pre> <h2 id="non-null-and-non-undefined-type-guards"> Non-null and non-undefined type guards  </h2> <p>A property access or a function call produces a compile-time error if the object or function is of a type that includes <code>null</code> or <code>undefined</code>. However, type guards are extended to support non-null and non-undefined checks.</p> <h5 id="example-2"> Example  </h5> <pre data-language="typescript">// Compiled with --strictNullChecks
declare function f(x: number): string;
let x: number | null | undefined;
if (x) {
  f(x);  // Ok, type of x is number here
}
else {
  f(x);  // Error, type of x is number? here
}
let a = x != null ? f(x) : "";  // Type of a is string
let b = x &amp;&amp; f(x);  // Type of b is string | 0 | null | undefined
</pre> <p>Non-null and non-undefined type guards may use the <code>==</code>, <code>!=</code>, <code>===</code>, or <code>!==</code> operator to compare to <code>null</code> or <code>undefined</code>, as in <code>x != null</code> or <code>x === undefined</code>. The effects on subject variable types accurately reflect JavaScript semantics (e.g. double-equals operators check for both values no matter which one is specified whereas triple-equals only checks for the specified value).</p> <h2 id="dotted-names-in-type-guards"> Dotted names in type guards  </h2> <p>Type guards previously only supported checking local variables and parameters. Type guards now support checking “dotted names” consisting of a variable or parameter name followed one or more property accesses.</p> <h5 id="example-3"> Example  </h5> <pre data-language="typescript">interface Options {
  location?: {
    x?: number;
    y?: number;
  };
}

function foo(options?: Options) {
  if (options &amp;&amp; options.location &amp;&amp; options.location.x) {
    const x = options.location.x;  // Type of x is number
  }
}
</pre> <p>Type guards for dotted names also work with user defined type guard functions and the <code>typeof</code> and <code>instanceof</code> operators and do not depend on the <code>--strictNullChecks</code> compiler option.</p> <p>A type guard for a dotted name has no effect following an assignment to any part of the dotted name. For example, a type guard for <code>x.y.z</code> will have no effect following an assignment to <code>x</code>, <code>x.y</code>, or <code>x.y.z</code>.</p> <h2 id="expression-operators"> Expression operators  </h2> <p>Expression operators permit operand types to include <code>null</code> and/or <code>undefined</code> but always produce values of non-null and non-undefined types.</p> <pre data-language="typescript">// Compiled with --strictNullChecks
function sum(a: number | null, b: number | null) {
  return a + b;  // Produces value of type number
}
</pre> <p>The <code>&amp;&amp;</code> operator adds <code>null</code> and/or <code>undefined</code> to the type of the right operand depending on which are present in the type of the left operand, and the <code>||</code> operator removes both <code>null</code> and <code>undefined</code> from the type of the left operand in the resulting union type.</p> <pre data-language="typescript">// Compiled with --strictNullChecks
interface Entity {
  name: string;
}
let x: Entity | null;
let s = x &amp;&amp; x.name;  // s is of type string | null
let y = x || { name: "test" };  // y is of type Entity
</pre> <h2 id="type-widening"> Type widening  </h2> <p>The <code>null</code> and <code>undefined</code> types are <em>not</em> widened to <code>any</code> in strict null checking mode.</p> <pre data-language="typescript">let z = null;  // Type of z is null
</pre> <p>In regular type checking mode the inferred type of <code>z</code> is <code>any</code> because of widening, but in strict null checking mode the inferred type of <code>z</code> is <code>null</code> (and therefore, absent a type annotation, <code>null</code> is the only possible value for <code>z</code>).</p> <h2 id="non-null-assertion-operator"> Non-null assertion operator  </h2> <p>A new <code>!</code> post-fix expression operator may be used to assert that its operand is non-null and non-undefined in contexts where the type checker is unable to conclude that fact. Specifically, the operation <code>x!</code> produces a value of the type of <code>x</code> with <code>null</code> and <code>undefined</code> excluded. Similar to type assertions of the forms <code>&lt;T&gt;x</code> and <code>x as T</code>, the <code>!</code> non-null assertion operator is simply removed in the emitted JavaScript code.</p> <pre data-language="typescript">// Compiled with --strictNullChecks
function validateEntity(e?: Entity) {
  // Throw exception if e is null or invalid entity
}

function processEntity(e?: Entity) {
  validateEntity(e);
  let s = e!.name;  // Assert that e is non-null and access name
}
</pre> <h2 id="compatibility"> Compatibility  </h2> <p>The new features are designed such that they can be used in both strict null checking mode and regular type checking mode. In particular, the <code>null</code> and <code>undefined</code> types are automatically erased from union types in regular type checking mode (because they are subtypes of all other types), and the <code>!</code> non-null assertion expression operator is permitted but has no effect in regular type checking mode. Thus, declaration files that are updated to use null- and undefined-aware types can still be used in regular type checking mode for backwards compatibility.</p> <p>In practical terms, strict null checking mode requires that all files in a compilation are null- and undefined-aware.</p> <h2 id="control-flow-based-type-analysis"> Control flow based type analysis  </h2> <p>TypeScript 2.0 implements a control flow-based type analysis for local variables and parameters. Previously, the type analysis performed for type guards was limited to <code>if</code> statements and <code>?:</code> conditional expressions and didn’t include effects of assignments and control flow constructs such as <code>return</code> and <code>break</code> statements. With TypeScript 2.0, the type checker analyses all possible flows of control in statements and expressions to produce the most specific type possible (the <em>narrowed type</em>) at any given location for a local variable or parameter that is declared to have a union type.</p> <h5 id="example-4"> Example  </h5> <pre data-language="typescript">function foo(x: string | number | boolean) {
  if (typeof x === "string") {
    x; // type of x is string here
    x = 1;
    x; // type of x is number here
  }
  x; // type of x is number | boolean here
}

function bar(x: string | number) {
  if (typeof x === "number") {
    return;
  }
  x; // type of x is string here
}
</pre> <p>Control flow based type analysis is particularly relevant in <code>--strictNullChecks</code> mode because nullable types are represented using union types:</p> <pre data-language="typescript">function test(x: string | null) {
  if (x === null) {
    return;
  }
  x; // type of x is string in remainder of function
}
</pre> <p>Furthermore, in <code>--strictNullChecks</code> mode, control flow based type analysis includes <em>definite assignment analysis</em> for local variables of types that don’t permit the value <code>undefined</code>.</p> <pre data-language="typescript">function mumble(check: boolean) {
  let x: number; // Type doesn't permit undefined
  x; // Error, x is undefined
  if (check) {
    x = 1;
    x; // Ok
  }
  x; // Error, x is possibly undefined
  x = 2;
  x; // Ok
}
</pre> <h2 id="tagged-union-types"> Tagged union types  </h2> <p>TypeScript 2.0 implements support for tagged (or discriminated) union types. Specifically, the TS compiler now support type guards that narrow union types based on tests of a discriminant property and furthermore extend that capability to <code>switch</code> statements.</p> <h5 id="example-5"> Example  </h5> <pre data-language="typescript">interface Square {
  kind: "square";
  size: number;
}

interface Rectangle {
  kind: "rectangle";
  width: number;
  height: number;
}

interface Circle {
  kind: "circle";
  radius: number;
}

type Shape = Square | Rectangle | Circle;

function area(s: Shape) {
  // In the following switch statement, the type of s is narrowed in each case clause
  // according to the value of the discriminant property, thus allowing the other properties
  // of that variant to be accessed without a type assertion.
  switch (s.kind) {
    case "square": return s.size * s.size;
    case "rectangle": return s.width * s.height;
    case "circle": return Math.PI * s.radius * s.radius;
  }
}

function test1(s: Shape) {
  if (s.kind === "square") {
    s;  // Square
  }
  else {
    s;  // Rectangle | Circle
  }
}

function test2(s: Shape) {
  if (s.kind === "square" || s.kind === "rectangle") {
    return;
  }
  s;  // Circle
}
</pre> <p>A <em>discriminant property type guard</em> is an expression of the form <code>x.p == v</code>, <code>x.p === v</code>, <code>x.p != v</code>, or <code>x.p !== v</code>, where <code>p</code> and <code>v</code> are a property and an expression of a string literal type or a union of string literal types. The discriminant property type guard narrows the type of <code>x</code> to those constituent types of <code>x</code> that have a discriminant property <code>p</code> with one of the possible values of <code>v</code>.</p> <p>Note that we currently only support discriminant properties of string literal types. We intend to later add support for boolean and numeric literal types.</p> <h2 id="the-never-type"> The <code>never</code> type  </h2> <p>TypeScript 2.0 introduces a new primitive type <code>never</code>. The <code>never</code> type represents the type of values that never occur. Specifically, <code>never</code> is the return type for functions that never return and <code>never</code> is the type of variables under type guards that are never true.</p> <p>The <code>never</code> type has the following characteristics:</p> <ul> <li>
<code>never</code> is a subtype of and assignable to every type.</li> <li>No type is a subtype of or assignable to <code>never</code> (except <code>never</code> itself).</li> <li>In a function expression or arrow function with no return type annotation, if the function has no <code>return</code> statements, or only <code>return</code> statements with expressions of type <code>never</code>, and if the end point of the function is not reachable (as determined by control flow analysis), the inferred return type for the function is <code>never</code>.</li> <li>In a function with an explicit <code>never</code> return type annotation, all <code>return</code> statements (if any) must have expressions of type <code>never</code> and the end point of the function must not be reachable.</li> </ul> <p>Because <code>never</code> is a subtype of every type, it is always omitted from union types and it is ignored in function return type inference as long as there are other types being returned.</p> <p>Some examples of functions returning <code>never</code>:</p> <pre data-language="typescript">// Function returning never must have unreachable end point
function error(message: string): never {
  throw new Error(message);
}

// Inferred return type is never
function fail() {
  return error("Something failed");
}

// Function returning never must have unreachable end point
function infiniteLoop(): never {
  while (true) {
  }
}
</pre> <p>Some examples of use of functions returning <code>never</code>:</p> <pre data-language="typescript">// Inferred return type is number
function move1(direction: "up" | "down") {
  switch (direction) {
    case "up":
      return 1;
    case "down":
      return -1;
  }
  return error("Should never get here");
}

// Inferred return type is number
function move2(direction: "up" | "down") {
  return direction === "up" ? 1 :
    direction === "down" ? -1 :
    error("Should never get here");
}

// Inferred return type is T
function check&lt;T&gt;(x: T | undefined) {
  return x || error("Undefined value");
}
</pre> <p>Because <code>never</code> is assignable to every type, a function returning <code>never</code> can be used when a callback returning a more specific type is required:</p> <pre data-language="typescript">function test(cb: () =&gt; string) {
  let s = cb();
  return s;
}

test(() =&gt; "hello");
test(() =&gt; fail());
test(() =&gt; { throw new Error(); })
</pre> <h2 id="read-only-properties-and-index-signatures"> Read-only properties and index signatures  </h2> <p>A property or index signature can now be declared with the <code>readonly</code> modifier is considered read-only.</p> <p>Read-only properties may have initializers and may be assigned to in constructors within the same class declaration, but otherwise assignments to read-only properties are disallowed.</p> <p>In addition, entities are <em>implicitly</em> read-only in several situations:</p> <ul> <li>A property declared with a <code>get</code> accessor and no <code>set</code> accessor is considered read-only.</li> <li>In the type of an enum object, enum members are considered read-only properties.</li> <li>In the type of a module object, exported <code>const</code> variables are considered read-only properties.</li> <li>An entity declared in an <code>import</code> statement is considered read-only.</li> <li>An entity accessed through an ES2015 namespace import is considered read-only (e.g. <code>foo.x</code> is read-only when <code>foo</code> is declared as <code>import * as foo from "foo"</code>).</li> </ul> <h5 id="example-6"> Example  </h5> <pre data-language="typescript">interface Point {
  readonly x: number;
  readonly y: number;
}

var p1: Point = { x: 10, y: 20 };
p1.x = 5;  // Error, p1.x is read-only

var p2 = { x: 1, y: 1 };
var p3: Point = p2;  // Ok, read-only alias for p2
p3.x = 5;  // Error, p3.x is read-only
p2.x = 5;  // Ok, but also changes p3.x because of aliasing
</pre> <pre data-language="typescript">class Foo {
  readonly a = 1;
  readonly b: string;
  constructor() {
    this.b = "hello";  // Assignment permitted in constructor
  }
}
</pre> <pre data-language="typescript">let a: Array&lt;number&gt; = [0, 1, 2, 3, 4];
let b: ReadonlyArray&lt;number&gt; = a;
b[5] = 5;    // Error, elements are read-only
b.push(5);   // Error, no push method (because it mutates array)
b.length = 3;  // Error, length is read-only
a = b;     // Error, mutating methods are missing
</pre> <h2 id="specifying-the-type-of-this-for-functions"> Specifying the type of <code>this</code> for functions  </h2> <p>Following up on specifying the type of <code>this</code> in a class or an interface, functions and methods can now declare the type of <code>this</code> they expect.</p> <p>By default the type of <code>this</code> inside a function is <code>any</code>. Starting with TypeScript 2.0, you can provide an explicit <code>this</code> parameter. <code>this</code> parameters are fake parameters that come first in the parameter list of a function:</p> <pre data-language="typescript">function f(this: void) {
  // make sure `this` is unusable in this standalone function
}
</pre> <h2 id="this-parameters-in-callbacks"> <code>this</code> parameters in callbacks  </h2> <p>Libraries can also use <code>this</code> parameters to declare how callbacks will be invoked.</p> <h5 id="example-7"> Example  </h5> <pre data-language="typescript">interface UIElement {
  addClickListener(onclick: (this: void, e: Event) =&gt; void): void;
}
</pre> <p><code>this: void</code> means that <code>addClickListener</code> expects <code>onclick</code> to be a function that does not require a <code>this</code> type.</p> <p>Now if you annotate calling code with <code>this</code>:</p> <pre data-language="typescript">class Handler {
  info: string;
  onClickBad(this: Handler, e: Event) {
    // oops, used this here. using this callback would crash at runtime
    this.info = e.message;
  };
}
let h = new Handler();
uiElement.addClickListener(h.onClickBad); // error!
</pre> <h2 id="--noimplicitthis"> <code>--noImplicitThis</code>  </h2> <p>A new flag is also added in TypeScript 2.0 to flag all uses of <code>this</code> in functions without an explicit type annotation.</p> <h2 id="glob-support-in-tsconfigjson"> Glob support in <code>tsconfig.json</code>  </h2> <p>Glob support is here!! Glob support has been <a href="https://github.com/Microsoft/TypeScript/issues/1927" target="_blank">one of the most requested features</a>.</p> <p>Glob-like file patterns are supported two properties <code>"include"</code> and <code>"exclude"</code>.</p> <h5 id="example-8"> Example  </h5> <pre data-language="javascripton">{
  "compilerOptions": {
    "module": "commonjs",
    "noImplicitAny": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "outFile": "../../built/local/tsc.js",
    "sourceMap": true
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "**/*.spec.ts"
  ]
}
</pre> <p>The supported glob wildcards are:</p> <ul> <li>
<code>*</code> matches zero or more characters (excluding directory separators)</li> <li>
<code>?</code> matches any one character (excluding directory separators)</li> <li>
<code>**/</code> recursively matches any subdirectory</li> </ul> <p>If a segment of a glob pattern includes only <code>*</code> or <code>.*</code>, then only files with supported extensions are included (e.g. <code>.ts</code>, <code>.tsx</code>, and <code>.d.ts</code> by default with <code>.js</code> and <code>.jsx</code> if <code>allowJs</code> is set to true).</p> <p>If the <code>"files"</code> and <code>"include"</code> are both left unspecified, the compiler defaults to including all TypeScript (<code>.ts</code>, <code>.d.ts</code> and <code>.tsx</code>) files in the containing directory and subdirectories except those excluded using the <code>"exclude"</code> property. JS files (<code>.js</code> and <code>.jsx</code>) are also included if <code>allowJs</code> is set to true.</p> <p>If the <code>"files"</code> or <code>"include"</code> properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the <code>"outDir"</code> compiler option are always excluded unless explicitly included via the <code>"files"</code> property (even when the “<code>exclude</code>” property is specified).</p> <p>Files included using <code>"include"</code> can be filtered using the <code>"exclude"</code> property. However, files included explicitly using the <code>"files"</code> property are always included regardless of <code>"exclude"</code>. The <code>"exclude"</code> property defaults to excluding the <code>node_modules</code>, <code>bower_components</code>, and <code>jspm_packages</code> directories when not specified.</p> <h2 id="module-resolution-enhancements-baseurl-path-mapping-rootdirs-and-tracing"> Module resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing  </h2> <p>TypeScript 2.0 provides a set of additional module resolution knops to <em>inform</em> the compiler where to find declarations for a given module.</p> <p>See <a href="http://www.typescriptlang.org/docs/handbook/module-resolution.html" target="_blank">Module Resolution</a> documentation for more details.</p> <h2 id="base-url"> Base URL  </h2> <p>Using a <code>baseUrl</code> is a common practice in applications using AMD module loaders where modules are “deployed” to a single folder at run-time. All module imports with non-relative names are assumed to be relative to the <code>baseUrl</code>.</p> <h5 id="example-9"> Example  </h5> <pre data-language="javascripton">{
  "compilerOptions": {
  "baseUrl": "./modules"
  }
}
</pre> <p>Now imports to <code>"moduleA"</code> would be looked up in <code>./modules/moduleA</code></p> <pre data-language="typescript">import A from "moduleA";
</pre> <h2 id="path-mapping"> Path mapping  </h2> <p>Sometimes modules are not directly located under <em>baseUrl</em>. Loaders use a mapping configuration to map module names to files at run-time, see <a href="http://requirejs.org/docs/api.html#config-paths" target="_blank">RequireJs documentation</a> and <a href="https://github.com/systemjs/systemjs/blob/master/docs/overview.html#map-config" target="_blank">SystemJS documentation</a>.</p> <p>The TypeScript compiler supports the declaration of such mappings using <code>"paths"</code> property in <code>tsconfig.json</code> files.</p> <h5 id="example-10"> Example  </h5> <p>For instance, an import to a module <code>"jquery"</code> would be translated at runtime to <code>"node_modules/jquery/dist/jquery.slim.min.js"</code>.</p> <pre data-language="javascripton">{
  "compilerOptions": {
  "baseUrl": "./node_modules",
  "paths": {
    "jquery": ["jquery/dist/jquery.slim.min"]
  }
}
</pre> <p>Using <code>"paths"</code> also allow for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another.</p> <h2 id="virtual-directories-with-rootdirs"> Virtual Directories with <code>rootDirs</code>  </h2> <p>Using ‘rootDirs’, you can inform the compiler of the <em>roots</em> making up this “virtual” directory; and thus the compiler can resolve relative modules imports within these “virtual” directories <em>as if</em> were merged together in one directory.</p> <h5 id="example-11"> Example  </h5> <p>Given this project structure:</p> <pre data-language="tree"> src
 └── views
   └── view1.ts (imports './template1')
   └── view2.ts

 generated
 └── templates
     └── views
       └── template1.ts (imports './view2')
</pre> <p>A build step will copy the files in <code>/src/views</code> and <code>/generated/templates/views</code> to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as <code>"./template"</code>.</p> <p><code>"rootDirs"</code> specify a list of <em>roots</em> whose contents are expected to merge at run-time. So following our example, the <code>tsconfig.json</code> file should look like:</p> <pre data-language="javascripton">{
  "compilerOptions": {
  "rootDirs": [
    "src/views",
    "generated/templates/views"
  ]
  }
}
</pre> <h2 id="tracing-module-resolution"> Tracing module resolution  </h2> <p><code>--traceResolution</code> offers a handy way to understand how modules have been resolved by the compiler.</p> <pre data-language="shell">tsc --traceResolution
</pre> <h2 id="shorthand-ambient-module-declarations"> Shorthand ambient module declarations  </h2> <p>If you don’t want to take the time to write out declarations before using a new module, you can now just use a shorthand declaration to get started quickly.</p> <h5 id="declarationsdts"> declarations.d.ts  </h5> <pre data-language="typescript">declare module "hot-new-module";
</pre> <p>All imports from a shorthand module will have the any type.</p> <pre data-language="typescript">import x, {y} from "hot-new-module";
x(y);
</pre> <h2 id="wildcard-character-in-module-names"> Wildcard character in module names  </h2> <p>Importing none-code resources using module loaders extension (e.g. <a href="https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html" target="_blank">AMD</a> or <a href="https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.html" target="_blank">SystemJS</a>) has not been easy before; previously an ambient module declaration had to be defined for each resource.</p> <p>TypeScript 2.0 supports the use of the wildcard character (<code>*</code>) to declare a “family” of module names; this way, a declaration is only required once for an extension, and not for every resource.</p> <h5 id="example-12"> Example  </h5> <pre data-language="typescript">declare module "*!text" {
  const content: string;
  export default content;
}
// Some do it the other way around.
declare module "json!*" {
  const value: any;
  export default value;
}
</pre> <p>Now you can import things that match <code>"*!text"</code> or <code>"json!*"</code>.</p> <pre data-language="typescript">import fileContent from "./xyz.txt!text";
import data from "json!http://example.com/data.json";
console.log(data, fileContent);
</pre> <p>Wildcard module names can be even more useful when migrating from an un-typed code base. Combined with Shorthand ambient module declarations, a set of modules can be easily declared as <code>any</code>.</p> <h5 id="example-13"> Example  </h5> <pre data-language="typescript">declare module "myLibrary/*";
</pre> <p>All imports to any module under <code>myLibrary</code> would be considered to have the type <code>any</code> by the compiler; thus, shutting down any checking on the shapes or types of these modules.</p> <pre data-language="typescript">import { readFile } from "myLibrary/fileSystem/readFile`;

readFile(); // readFile is 'any'
</pre> <h2 id="support-for-umd-module-definitions"> Support for UMD module definitions  </h2> <p>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as <a href="https://github.com/umdjs/umd" target="_blank">UMD</a> or <a href="http://isomorphic.net" target="_blank">Isomorphic</a> modules. These libraries can be accessed through either an import or a global variable.</p> <p>For example:</p> <h5 id="math-libdts"> math-lib.d.ts  </h5> <pre data-language="typescript">export const isPrime(x: number): boolean;
export as namespace mathLib;
</pre> <p>The library can then be used as an import within modules:</p> <pre data-language="typescript">import { isPrime } from "math-lib";
isPrime(2);
mathLib.isPrime(2); // ERROR: can't use the global definition from inside a module
</pre> <p>It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports.)</p> <pre data-language="typescript">mathLib.isPrime(2);
</pre> <h2 id="optional-class-properties"> Optional class properties  </h2> <p>Optional properties and methods can now be declared in classes, similar to what is already permitted in interfaces.</p> <h5 id="example-14"> Example  </h5> <pre data-language="typescript">class Bar {
  a: number;
  b?: number;
  f() {
    return 1;
  }
  g?(): number;  // Body of optional method can be omitted
  h?() {
    return 2;
  }
}
</pre> <p>When compiled in <code>--strictNullChecks</code> mode, optional properties and methods automatically have <code>undefined</code> included in their type. Thus, the <code>b</code> property above is of type <code>number | undefined</code> and the <code>g</code> method above is of type <code>(() =&gt; number) | undefined</code>. Type guards can be used to strip away the <code>undefined</code> part of the type:</p> <pre data-language="typescript">function test(x: Bar) {
  x.a;  // number
  x.b;  // number | undefined
  x.f;  // () =&gt; number
  x.g;  // (() =&gt; number) | undefined
  let f1 = x.f();      // number
  let g1 = x.g &amp;&amp; x.g();   // number | undefined
  let g2 = x.g ? x.g() : 0;  // number
}
</pre> <h2 id="private-and-protected-constructors"> Private and Protected Constructors  </h2> <p>A class constructor may be marked <code>private</code> or <code>protected</code>. A class with private constructor cannot be instantiated outside the class body, and cannot be extended. A class with protected constructor cannot be instantiated outside the class body, but can be extended.</p> <h5 id="example-15"> Example  </h5> <pre data-language="typescript">class Singleton {
  private static instance: Singleton;

  private constructor() { }

  static getInstance() {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }
    return Singleton.instance;
  }
}

let e = new Singleton(); // Error: constructor of 'Singleton' is private.
let v = Singleton.getInstance();
</pre> <h2 id="abstract-properties-and-accessors"> Abstract properties and accessors  </h2> <p>An abstract class can declare abstract properties and/or accessors. Any sub class will need to declare the abstract properties or be marked as abstract. Abstract properties cannot have an initializer. Abstract accessors cannot have bodies.</p> <h5 id="example-16"> Example  </h5> <pre data-language="typescript">abstract class Base {
  abstract name: string;
  abstract get value();
  abstract set value(v: number);
}

class Derived extends Base {
  name = "derived";

  value = 1;
}
</pre> <h2 id="implicit-index-signatures"> Implicit index signatures  </h2> <p>An object literal type is now assignable to a type with an index signature if all known properties in the object literal are assignable to that index signature. This makes it possible to pass a variable that was initialized with an object literal as parameter to a function that expects a map or dictionary:</p> <pre data-language="typescript">function httpService(path: string, headers: { [x: string]: string }) { }

const headers = {
  "Content-Type": "application/x-www-form-urlencoded"
};

httpService("", { "Content-Type": "application/x-www-form-urlencoded" });  // Ok
httpService("", headers);  // Now ok, previously wasn't
</pre> <h2 id="including-built-in-type-declarations-with---lib"> Including built-in type declarations with <code>--lib</code>  </h2> <p>Getting to ES6/ES2015 built-in API declarations were only limited to <code>target: ES6</code>. Enter <code>--lib</code>; with <code>--lib</code> you can specify a list of built-in API declaration groups that you can chose to include in your project. For instance, if you expect your runtime to have support for <code>Map</code>, <code>Set</code> and <code>Promise</code> (e.g. most evergreen browsers today), just include <code>--lib es2015.collection,es2015.promise</code>. Similarly you can exclude declarations you do not want to include in your project, e.g. DOM if you are working on a node project using <code>--lib es5,es6</code>.</p> <p>Here is a list of available API groups:</p> <ul> <li>dom</li> <li>webworker</li> <li>es5</li> <li>es6 / es2015</li> <li>es2015.core</li> <li>es2015.collection</li> <li>es2015.iterable</li> <li>es2015.promise</li> <li>es2015.proxy</li> <li>es2015.reflect</li> <li>es2015.generator</li> <li>es2015.symbol</li> <li>es2015.symbol.wellknown</li> <li>es2016</li> <li>es2016.array.include</li> <li>es2017</li> <li>es2017.object</li> <li>es2017.sharedmemory</li> <li>scripthost</li> </ul> <h5 id="example-17"> Example  </h5> <pre data-language="bash">tsc --target es5 --lib es5,es2015.promise
</pre> <pre data-language="javascripton">"compilerOptions": {
  "lib": ["es5", "es2015.promise"]
}
</pre> <h2 id="flag-unused-declarations-with---nounusedparameters-and---nounusedlocals"> Flag unused declarations with <code>--noUnusedParameters</code> and <code>--noUnusedLocals</code>  </h2> <p>TypeScript 2.0 has two new flags to help you maintain a clean code base. <code>--noUnusedParameters</code> flags any unused function or method parameters errors. <code>--noUnusedLocals</code> flags any unused local (un-exported) declaration like variables, functions, classes, imports, etc… Also, unused private members of a class would be flagged as errors under <code>--noUnusedLocals</code>.</p> <h5 id="example-18"> Example  </h5> <pre data-language="typescript">import B, { readFile } from "./b";
//   ^ Error: `B` declared but never used
readFile();


export function write(message: string, args: string[]) {
  //                 ^^^^  Error: 'arg' declared but never used.
  console.log(message);
}
</pre> <p>Parameters declaration with names starting with <code>_</code> are exempt from the unused parameter checking. e.g.:</p> <pre data-language="typescript">function returnNull(_a) { // OK
  return null;
}
</pre> <h2 id="module-identifiers-allow-for-js-extension"> Module identifiers allow for <code>.js</code> extension  </h2> <p>Before TypeScript 2.0, a module identifier was always assumed to be extension-less; for instance, given an import as <code>import d from "./moduleA.js"</code>, the compiler looked up the definition of <code>"moduleA.js"</code> in <code>./moduleA.js.ts</code> or <code>./moduleA.js.d.ts</code>. This made it hard to use bundling/loading tools like <a href="https://github.com/systemjs/systemjs" target="_blank">SystemJS</a> that expect URI’s in their module identifier.</p> <p>With TypeScript 2.0, the compiler will look up definition of <code>"moduleA.js"</code> in <code>./moduleA.ts</code> or <code>./moduleA.d.t</code>.</p> <h2 id="support-target--es5-with-module-es6"> Support ‘target : es5’ with ‘module: es6’  </h2> <p>Previously flagged as an invalid flag combination, <code>target: es5</code> and ‘module: es6’ is now supported. This should facilitate using ES2015-based tree shakers like <a href="https://github.com/rollup/rollup" target="_blank">rollup</a>.</p> <h2 id="trailing-commas-in-function-parameter-and-argument-lists"> Trailing commas in function parameter and argument lists  </h2> <p>Trailing comma in function parameter and argument lists are now allowed. This is an implementation for a <a href="https://jeffmo.github.io/es-trailing-function-commas/" target="_blank">Stage-3 ECMAScript proposal</a> that emits down to valid ES3/ES5/ES6.</p> <h5 id="example-19"> Example  </h5> <pre data-language="typescript">function foo(
  bar: Bar,
  baz: Baz, // trailing commas are OK in parameter lists
) {
  // Implementation...
}

foo(
  bar,
  baz, // and in argument lists
);
</pre> <h2 id="new---skiplibcheck"> New <code>--skipLibCheck</code>  </h2> <p>TypeScript 2.0 adds a new <code>--skipLibCheck</code> compiler option that causes type checking of declaration files (files with extension <code>.d.ts</code>) to be skipped. When a program includes large declaration files, the compiler spends a lot of time type checking declarations that are already known to not contain errors, and compile times may be significantly shortened by skipping declaration file type checks.</p> <p>Since declarations in one file can affect type checking in other files, some errors may not be detected when <code>--skipLibCheck</code> is specified. For example, if a non-declaration file augments a type declared in a declaration file, errors may result that are only reported when the declaration file is checked. However, in practice such situations are rare.</p> <h2 id="allow-duplicate-identifiers-across-declarations"> Allow duplicate identifiers across declarations  </h2> <p>This has been one common source of duplicate definition errors. Multiple declaration files defining the same members on interfaces.</p> <p>TypeScript 2.0 relaxes this constraint and allows duplicate identifiers across blocks, as long as they have <em>identical</em> types.</p> <p>Within the same block duplicate definitions are still disallowed.</p> <h5 id="example-20"> Example  </h5> <pre data-language="typescript">interface Error {
  stack?: string;
}


interface Error {
  code?: string;
  path?: string;
  stack?: string;  // OK
}

</pre> <h2 id="new---declarationdir"> New <code>--declarationDir</code>  </h2> <p><code>--declarationDir</code> allows for generating declaration files in a different location than JavaScript files.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012-2019 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html" class="_attribution-link" target="_blank">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
