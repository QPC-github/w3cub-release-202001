
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>macro.Context - Haxe - W3cubDocs</title>
  
  <meta name="description" content=" package haxe.macro ">
  <meta name="keywords" content="context, macro, -, haxe">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/haxe/haxe/macro/context/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/haxe.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/haxe/" class="_nav-link" title="" style="margin-left:0;">Haxe</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1> Context</h1>
<p>package <a href="../">haxe.macro</a></p> 
<em>Available on macro, neko</em><blockquote class="indent">
<p>Context provides an API for macro programming.</p> <p>It contains common functions that interact with the macro interpreter to query or set information. Other API functions are available in the tools classes:</p>
<ul>
<li><code><a href="../complextypetools/#ComplexTypeTools">haxe.macro.ComplexTypeTools</a></code></li>
<li><code><a href="../exprtools/#ExprTools">haxe.macro.ExprTools</a></code></li>
<li><code><a href="../typetools/#TypeTools">haxe.macro.TypeTools</a></code></li>
</ul>
</blockquote>
<h2 class="section">Static methods</h2>

<h3 class="anchor" id="addResource"><code><span class="label label-static">static</span> <a href="#addResource">addResource</a> (<span style="white-space:nowrap">name:<a class="type" title="The basic String class." href="../../../string/">String</a>,</span> <span style="white-space:nowrap">data:<a class="type" title="" href="../../io/bytes/">Bytes</a></span>):<a class="type" title="The standard Void type." href="../../../void/">Void</a></code></h3>
<p>Makes resource <code>data</code> available as <code>name</code>.</p> <p>The resource is then available using the <code><a href="../../resource/#Resource">haxe.macro.Resource</a></code> API.</p> <p>If a previous resource was bound to <code>name</code>, it is overwritten.</p> <p>Compilation server : when using the compilation server, the resource is bound to the Haxe module which calls the macro, so it will be included again if that module is reused. If this resource concerns several modules, prefix its name with a $ sign, this will bind it to the macro module instead.</p>

<h3 class="anchor" id="currentPos"><code><span class="label label-static">static</span> <a href="#currentPos">currentPos</a> ():<a class="type" title="Represents a position in a file." href="../position/">Position</a></code></h3>
<p>Returns the position at which the macro was called.</p>

<h3 class="anchor" id="defineModule"><code><span class="label label-static">static</span> <a href="#defineModule">defineModule</a> (<span style="white-space:nowrap">modulePath:<a class="type" title="The basic String class." href="../../../string/">String</a>,</span> <span style="white-space:nowrap">types:<a class="type" title="An Array is a storage for values." href="../../../array/">Array</a>&lt;<a class="type" title="Represents a type definition." href="../typedefinition/">TypeDefinition</a>&gt;,</span> <span style="white-space:nowrap">?imports:<a class="type" title="An Array is a storage for values." href="../../../array/">Array</a>&lt;<a class="type" title="Represents the import expression." href="../importexpr/">ImportExpr</a>&gt;,</span> <span style="white-space:nowrap">?usings:<a class="type" title="An Array is a storage for values." href="../../../array/">Array</a>&lt;<a class="type" title="Represents a type path in the AST." href="../typepath/">TypePath</a>&gt;</span>):<a class="type" title="The standard Void type." href="../../../void/">Void</a></code></h3>
<p>Defines a new module as <code>modulePath</code> with several <code><a href="../typedefinition/#TypeDefinition">TypeDefinition</a></code> <code>types</code>. This is analogous to defining a .hx file.</p> <p>The individual <code>types</code> can reference each other and any identifier respects the <code>imports</code> and <code>usings</code> as usual, expect that imports are not allowed to have <code>.*</code> wildcards or <code>in s</code> shorthands.</p>

<h3 class="anchor" id="defineType"><code><span class="label label-static">static</span> <a href="#defineType">defineType</a> (<span style="white-space:nowrap">t:<a class="type" title="Represents a type definition." href="../typedefinition/">TypeDefinition</a></span>):<a class="type" title="The standard Void type." href="../../../void/">Void</a></code></h3>
<p>Defines a new type from <code><a href="../typedefinition/#TypeDefinition">TypeDefinition</a></code> <code>t</code>.</p>

<h3 class="anchor" id="defined"><code><span class="label label-static">static</span> <a href="#defined">defined</a> (<span style="white-space:nowrap">s:<a class="type" title="The basic String class." href="../../../string/">String</a></span>):<a class="type" title="The standard Boolean type, which can either be true or false." href="../../../bool/">Bool</a></code></h3>
<p>Tells if compiler directive <code>s</code> has been set.</p> <p>Compiler directives are set using the <code>-D</code> command line parameter, or by calling <code><a href="../compiler/#define">haxe.macro.Compiler.define</a></code>.</p>

<h3 class="anchor" id="definedValue"><code><span class="label label-static">static</span> <a href="#definedValue">definedValue</a> (<span style="white-space:nowrap">key:<a class="type" title="The basic String class." href="../../../string/">String</a></span>):<a class="type" title="The basic String class." href="../../../string/">String</a></code></h3>
<p>Returns the value defined for compiler directive <code>key</code>.</p> <p>If no value is defined for <code>key</code>, null is returned.</p> <p>Compiler directive values are set using the <code>-D key=value</code> command line parameter, or by calling <code><a href="../compiler/#define">haxe.macro.Compiler.define</a></code>.</p> <p>The default value is <code>"1"</code>.</p>

<h3 class="anchor" id="error"><code><span class="label label-static">static</span> <a href="#error">error</a> (<span style="white-space:nowrap">msg:<a class="type" title="The basic String class." href="../../../string/">String</a>,</span> <span style="white-space:nowrap">pos:<a class="type" title="Represents a position in a file." href="../position/">Position</a></span>):<a class="type" title="Dynamic is a special type which is compatible with all other types." href="../../../dynamic/">Dynamic</a></code></h3>
<p>Displays a compilation error <code>msg</code> at the given <code><a href="../position/#Position">Position</a></code> <code>pos</code> and aborts the current macro call.</p>

<h3 class="anchor" id="fatalError"><code><span class="label label-static">static</span> <a href="#fatalError">fatalError</a> (<span style="white-space:nowrap">msg:<a class="type" title="The basic String class." href="../../../string/">String</a>,</span> <span style="white-space:nowrap">pos:<a class="type" title="Represents a position in a file." href="../position/">Position</a></span>):<a class="type" title="Dynamic is a special type which is compatible with all other types." href="../../../dynamic/">Dynamic</a></code></h3>
<p>Displays a compilation error <code>msg</code> at the given <code><a href="../position/#Position">Position</a></code> <code>pos</code> and aborts the compilation.</p>

<h3 class="anchor" id="follow"><code><span class="label label-static">static</span> <a href="#follow">follow</a> (<span style="white-space:nowrap">t:<a class="type" title="Represents a type." href="../type/">Type</a>,</span> <span style="white-space:nowrap">?once:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../../bool/">Bool</a></span>):<a class="type" title="Represents a type." href="../type/">Type</a></code></h3>
<p>Follows a type.</p> <p>See <code><a href="../typetools/#follow">haxe.macro.TypeTools.follow</a></code> for details.</p>

<h3 class="anchor" id="followWithAbstracts"><code><span class="label label-meta label-meta-value" title="@:value metadata">@:value({ once : false })</span> <span class="label label-static">static</span> <a href="#followWithAbstracts">followWithAbstracts</a> (<span style="white-space:nowrap">t:<a class="type" title="Represents a type." href="../type/">Type</a>,</span> <span style="white-space:nowrap">once:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../../bool/">Bool</a> = false</span>):<a class="type" title="Represents a type." href="../type/">Type</a></code></h3>
<p>Follows a type, including abstracts' underlying implementation</p> <p>See <code><a href="../typetools/#followWithAbstracts">haxe.macro.TypeTools.followWithAbstracts</a></code> for details.</p>

<h3 class="anchor" id="getBuildFields"><code><span class="label label-static">static</span> <a href="#getBuildFields">getBuildFields</a> ():<a class="type" title="An Array is a storage for values." href="../../../array/">Array</a>&lt;<a class="type" title="Represents a field in the AST." href="../field/">Field</a>&gt;</code></h3>
<p>Returns an <code><a href="../../../array/">Array</a></code> of fields of the class which is to be built.</p> <p>This is only defined for <code>@:build/@:autoBuild</code> macros.</p>

<h3 class="anchor" id="getCallArguments"><code><span class="label label-meta label-meta-require" title="@:require metadata">@:require(haxe_ver &gt;= 3.2)</span> <span class="label label-static">static</span> <a href="#getCallArguments">getCallArguments</a> ():<a class="type" title="Null can be useful in two cases." href="../../../null/">Null</a>&lt;<a class="type" title="An Array is a storage for values." href="../../../array/">Array</a>&lt;<a class="type" title="Represents a node in the AST." href="../expr/">Expr</a>&gt;&gt;</code></h3>
<p>Returns the call arguments that lead to the invocation of the current <code>@:genericBuild</code> macro, if available.</p> <p>Returns <code>null</code> if the current macro is not a <code>@:genericBuild</code> macro.</p>

<h3 class="anchor" id="getClassPath"><code><span class="label label-static">static</span> <a href="#getClassPath">getClassPath</a> ():<a class="type" title="An Array is a storage for values." href="../../../array/">Array</a>&lt;<a class="type" title="The basic String class." href="../../../string/">String</a>&gt;</code></h3>
<p>Returns an <code><a href="../../../array/">Array</a></code> of current class paths in the order of their declaration.</p> <p>Modifying the returned array has no effect on the compiler. Class paths can be added using <code><a href="../compiler/#addClassPath">haxe.macro.Compiler.addClassPath</a></code>.</p>

<h3 class="anchor" id="getDefines"><code><span class="label label-static">static</span> <a href="#getDefines">getDefines</a> ():<a class="type" title="Map allows key to value mapping for arbitrary value types, and many key types." href="../../../map/">Map</a>&lt;<a class="type" title="The basic String class." href="../../../string/">String</a>, <a class="type" title="The basic String class." href="../../../string/">String</a>&gt;</code></h3>
<p>Returns a map of all compiler directives that have been set.</p> <p>Compiler directives are set using the <code>-D</code> command line parameter, or by calling <code><a href="../compiler/#define">haxe.macro.Compiler.define</a></code>.</p> <p>Modifying the returned map has no effect on the compiler.</p>

<h3 class="anchor" id="getExpectedType"><code><span class="label label-meta label-meta-require" title="@:require metadata">@:require(haxe_ver &gt;= 3.1)</span> <span class="label label-static">static</span> <a href="#getExpectedType">getExpectedType</a> ():<a class="type" title="Null can be useful in two cases." href="../../../null/">Null</a>&lt;<a class="type" title="Represents a type." href="../type/">Type</a>&gt;</code></h3>
<p>Returns the type which is expected at the place the macro is called.</p> <p>This affects usages such as <code>var x:<a href="../../../int/">Int</a> = macroCall()</code>, where the expected type will be reported as Int.</p> <p>Might return null if no specific type is expected or if the calling macro is not an expression-macro.</p>

<h3 class="anchor" id="getLocalClass"><code><span class="label label-static">static</span> <a href="#getLocalClass">getLocalClass</a> ():<a class="type" title="Null can be useful in two cases." href="../../../null/">Null</a>&lt;<a class="type" title="Represents a reference to internal compiler structure." href="../ref/">Ref</a>&lt;<a class="type" title="Represents a class type." href="../classtype/">ClassType</a>&gt;&gt;</code></h3>
<p>Returns the current class in which the macro was called.</p> <p>If no such class exists, null is returned.</p>

<h3 class="anchor" id="getLocalImports"><code><span class="label label-static">static</span> <a href="#getLocalImports">getLocalImports</a> ():<a class="type" title="An Array is a storage for values." href="../../../array/">Array</a>&lt;<a class="type" title="Represents the import expression." href="../importexpr/">ImportExpr</a>&gt;</code></h3>
<p>Returns an <code><a href="../../../array/">Array</a></code> of all imports in the context the macro was called.</p> <p>Modifying the returned array has no effect on the compiler.</p>

<h3 class="anchor" id="getLocalMethod"><code><span class="label label-static">static</span> <a href="#getLocalMethod">getLocalMethod</a> ():<a class="type" title="Null can be useful in two cases." href="../../../null/">Null</a>&lt;<a class="type" title="The basic String class." href="../../../string/">String</a>&gt;</code></h3>
<p>Returns the name of the method from which the macro was called.</p> <p>If no such method exists, null is returned.</p>

<h3 class="anchor" id="getLocalModule"><code><span class="label label-static">static</span> <a href="#getLocalModule">getLocalModule</a> ():<a class="type" title="The basic String class." href="../../../string/">String</a></code></h3>
<p>Returns the current module path in/on which the macro was called.</p>

<h3 class="anchor" id="getLocalTVars"><code><span class="label label-meta label-meta-require" title="@:require metadata">@:require(haxe_ver &gt;= 3.102)</span> <span class="label label-static">static</span> <a href="#getLocalTVars">getLocalTVars</a> ():<a class="type" title="Map allows key to value mapping for arbitrary value types, and many key types." href="../../../map/">Map</a>&lt;<a class="type" title="The basic String class." href="../../../string/">String</a>, <a class="type" title="Represents a variable in the typed AST." href="../tvar/">TVar</a>&gt;</code></h3>
<p>Similar to <code>getLocalVars</code>, but returns elements of type <code><a href="../tvar/#TVar">TVar</a></code> instead of <code><a href="../../../type/">Type</a></code>.</p>

<h3 class="anchor" id="getLocalType"><code><span class="label label-static">static</span> <a href="#getLocalType">getLocalType</a> ():<a class="type" title="Null can be useful in two cases." href="../../../null/">Null</a>&lt;<a class="type" title="Represents a type." href="../type/">Type</a>&gt;</code></h3>
<p>Returns the current type in/on which the macro was called.</p> <p>If no such type exists, null is returned.</p>

<h3 class="anchor" id="getLocalUsing"><code><span class="label label-static">static</span> <a href="#getLocalUsing">getLocalUsing</a> ():<a class="type" title="An Array is a storage for values." href="../../../array/">Array</a>&lt;<a class="type" title="Represents a reference to internal compiler structure." href="../ref/">Ref</a>&lt;<a class="type" title="Represents a class type." href="../classtype/">ClassType</a>&gt;&gt;</code></h3>
<p>Returns an <code><a href="../../../array/">Array</a></code> of classes which are available for <code>using</code> usage in the context the macro was called.</p> <p>Modifying the returned array has no effect on the compiler.</p>

<h3 class="anchor" id="getLocalVars"><code><span class="label label-static">static</span> <a href="#getLocalVars">getLocalVars</a> ():<a class="type" title="Map allows key to value mapping for arbitrary value types, and many key types." href="../../../map/">Map</a>&lt;<a class="type" title="The basic String class." href="../../../string/">String</a>, <a class="type" title="Represents a type." href="../type/">Type</a>&gt;</code></h3>
<div class="alert alert-warning alert-deprecated">
<strong>Deprecated:</strong> "Use Context.getLocalTVars() instead"</div>
<p>Returns a map of local variables accessible in the context the macro was called.</p> <p>The keys of the returned map are the variable names, the values are their types.</p> <p>Modifying the returned map has no effect on the compiler.</p>

<h3 class="anchor" id="getModule"><code><span class="label label-static">static</span> <a href="#getModule">getModule</a> (<span style="white-space:nowrap">name:<a class="type" title="The basic String class." href="../../../string/">String</a></span>):<a class="type" title="An Array is a storage for values." href="../../../array/">Array</a>&lt;<a class="type" title="Represents a type." href="../type/">Type</a>&gt;</code></h3>
<p>Resolves a module identified by <code>name</code> and returns an <code><a href="../../../array/">Array</a></code> of all its contained types.</p> <p>The resolution follows the usual class path rules where the last declared class path has priority.</p> <p>If no module can be found, null is returned.</p>

<h3 class="anchor" id="getPosInfos"><code><span class="label label-static">static</span> <a href="#getPosInfos">getPosInfos</a> (<span style="white-space:nowrap">p:<a class="type" title="Represents a position in a file." href="../position/">Position</a></span>):{min:<a class="type" title="The standard Int type." href="../../../int/">Int</a>, max:<a class="type" title="The standard Int type." href="../../../int/">Int</a>, file:<a class="type" title="The basic String class." href="../../../string/">String</a>}</code></h3>
<p>Returns the information stored in <code><a href="../position/#Position">Position</a></code> <code>p</code>.</p>

<h3 class="anchor" id="getResources"><code><span class="label label-static">static</span> <a href="#getResources">getResources</a> ():<a class="type" title="Map allows key to value mapping for arbitrary value types, and many key types." href="../../../map/">Map</a>&lt;<a class="type" title="The basic String class." href="../../../string/">String</a>, <a class="type" title="" href="../../io/bytes/">Bytes</a>&gt;</code></h3>
<p>Returns a map of all registered resources for this compilation unit.</p> <p>Modifying the returned map has no effect on the compilation, use <code><a href="../context/#addResource">haxe.macro.Context.addResource</a></code> to add new resources to the compilation unit.</p>

<h3 class="anchor" id="getType"><code><span class="label label-static">static</span> <a href="#getType">getType</a> (<span style="white-space:nowrap">name:<a class="type" title="The basic String class." href="../../../string/">String</a></span>):<a class="type" title="Represents a type." href="../type/">Type</a></code></h3>
<p>Resolves a type identified by <code>name</code>.</p> <p>The resolution follows the usual class path rules where the last declared class path has priority.</p> <p>If no type can be found, an exception of type <code><a href="../../../string/">String</a></code> is thrown.</p>

<h3 class="anchor" id="getTypedExpr"><code><span class="label label-static">static</span> <a href="#getTypedExpr">getTypedExpr</a> (<span style="white-space:nowrap">t:<a class="type" title="Represents a typed AST node." href="../typedexpr/">TypedExpr</a></span>):<a class="type" title="Represents a node in the AST." href="../expr/">Expr</a></code></h3>
<p>Returns a syntax-level expression corresponding to typed expression <code>t</code>.</p> <p>This process may lose some information.</p>

<h3 class="anchor" id="makeExpr"><code><span class="label label-static">static</span> <a href="#makeExpr">makeExpr</a> (<span style="white-space:nowrap">v:<a class="type" title="Dynamic is a special type which is compatible with all other types." href="../../../dynamic/">Dynamic</a>,</span> <span style="white-space:nowrap">pos:<a class="type" title="Represents a position in a file." href="../position/">Position</a></span>):<a class="type" title="Represents a node in the AST." href="../expr/">Expr</a></code></h3>
<p>Builds an expression from <code>v</code>.</p> <p>This method generates AST nodes depending on the macro-runtime value of <code>v</code>. As such, only basic types and enums are supported and the behavior for other types is undefined.</p> <p>The provided <code><a href="../position/#Position">Position</a></code> <code>pos</code> is used for all generated inner AST nodes.</p>

<h3 class="anchor" id="makePosition"><code><span class="label label-static">static</span> <a href="#makePosition">makePosition</a> (<span style="white-space:nowrap">inf:{min:<a class="type" title="The standard Int type." href="../../../int/">Int</a>, max:<a class="type" title="The standard Int type." href="../../../int/">Int</a>, file:<a class="type" title="The basic String class." href="../../../string/">String</a>}</span>):<a class="type" title="Represents a position in a file." href="../position/">Position</a></code></h3>
<p>Builds a <code><a href="../position/#Position">Position</a></code> from <code>inf</code>.</p>

<h3 class="anchor" id="onAfterGenerate"><code><span class="label label-meta label-meta-require" title="@:require metadata">@:require(haxe_ver &gt;= 3.1)</span> <span class="label label-static">static</span> <a href="#onAfterGenerate">onAfterGenerate</a> (<span style="white-space:nowrap">callback:<a class="type" title="The standard Void type." href="../../../void/">Void</a> ‑&gt; <a class="type" title="The standard Void type." href="../../../void/">Void</a></span>):<a class="type" title="The standard Void type." href="../../../void/">Void</a></code></h3>
<p>Adds a callback function <code>callback</code> which is invoked after the compiler generation phase.</p> <p>Compilation has completed at this point and cannot be influenced anymore. However, contextual information is still available.</p>

<h3 class="anchor" id="onAfterTyping"><code><span class="label label-static">static</span> <a href="#onAfterTyping">onAfterTyping</a> (<span style="white-space:nowrap">callback:<a class="type" title="An Array is a storage for values." href="../../../array/">Array</a>&lt;<a class="type" title="Represents a module type." href="../moduletype/">ModuleType</a>&gt; ‑&gt; <a class="type" title="The standard Void type." href="../../../void/">Void</a></span>):<a class="type" title="The standard Void type." href="../../../void/">Void</a></code></h3>
<p>Adds a callback function <code>callback</code> which is invoked after the compiler is done typing, but before optimization. The callback receives the types which have been typed.</p> <p>It is possible to define new types in the callback, in which case it will be called again with the new types as argument.</p>

<h3 class="anchor" id="onGenerate"><code><span class="label label-static">static</span> <a href="#onGenerate">onGenerate</a> (<span style="white-space:nowrap">callback:<a class="type" title="An Array is a storage for values." href="../../../array/">Array</a>&lt;<a class="type" title="Represents a type." href="../type/">Type</a>&gt; ‑&gt; <a class="type" title="The standard Void type." href="../../../void/">Void</a></span>):<a class="type" title="The standard Void type." href="../../../void/">Void</a></code></h3>
<p>Adds a callback function <code>callback</code> which is invoked after the compiler's typing phase, just before its generation phase.</p> <p>The callback receives an <code><a href="../../../array/">Array</a></code> containing all types which are about to be generated. Modifications are limited to metadata, it is mainly intended to obtain information.</p>

<h3 class="anchor" id="onMacroContextReused"><code><span class="label label-static">static</span> <a href="#onMacroContextReused">onMacroContextReused</a> (<span style="white-space:nowrap">callb:<a class="type" title="The standard Void type." href="../../../void/">Void</a> ‑&gt; <a class="type" title="The standard Boolean type, which can either be true or false." href="../../../bool/">Bool</a></span>):<a class="type" title="The standard Void type." href="../../../void/">Void</a></code></h3>
<p>Register a callback function that will be called every time the macro context cached is reused with a new compilation. This enable to reset some static vars since the code might have been changed. If the callback returns false, the macro context is discarded and another one is created.</p>

<h3 class="anchor" id="onTypeNotFound"><code><span class="label label-static">static</span> <a href="#onTypeNotFound">onTypeNotFound</a> (<span style="white-space:nowrap">callback:<a class="type" title="The basic String class." href="../../../string/">String</a> ‑&gt; <a class="type" title="Represents a type definition." href="../typedefinition/">TypeDefinition</a></span>):<a class="type" title="The standard Void type." href="../../../void/">Void</a></code></h3>
<p>Adds a callback function <code>callback</code> which is invoked when a type name cannot be resolved.</p> <p>The callback may return a type definition, which is then used for the expected type. If it returns null, the type is considered to still not exist.</p>

<h3 class="anchor" id="parse"><code><span class="label label-static">static</span> <a href="#parse">parse</a> (<span style="white-space:nowrap">expr:<a class="type" title="The basic String class." href="../../../string/">String</a>,</span> <span style="white-space:nowrap">pos:<a class="type" title="Represents a position in a file." href="../position/">Position</a></span>):<a class="type" title="Represents a node in the AST." href="../expr/">Expr</a></code></h3>
<p>Parses <code>expr</code> as Haxe code, returning the corresponding AST.</p> <p>String interpolation of single quote strings within <code>expr</code> is not supported.</p> <p>The provided <code><a href="../position/#Position">Position</a></code> <code>pos</code> is used for all generated inner AST nodes.</p>

<h3 class="anchor" id="parseInlineString"><code><span class="label label-static">static</span> <a href="#parseInlineString">parseInlineString</a> (<span style="white-space:nowrap">expr:<a class="type" title="The basic String class." href="../../../string/">String</a>,</span> <span style="white-space:nowrap">pos:<a class="type" title="Represents a position in a file." href="../position/">Position</a></span>):<a class="type" title="Represents a node in the AST." href="../expr/">Expr</a></code></h3>
<p>Similar to <code>parse</code>, but error positions are reported within the provided String <code>expr</code>.</p>

<h3 class="anchor" id="registerModuleDependency"><code><span class="label label-static">static</span> <a href="#registerModuleDependency">registerModuleDependency</a> (<span style="white-space:nowrap">modulePath:<a class="type" title="The basic String class." href="../../../string/">String</a>,</span> <span style="white-space:nowrap">externFile:<a class="type" title="The basic String class." href="../../../string/">String</a></span>):<a class="type" title="The standard Void type." href="../../../void/">Void</a></code></h3>
<p>Evaluates <code>e</code> as macro code.</p> <p>Any call to this function takes effect when the macro is executed, not during typing. As a consequence, this function can not introduce new local variables into the macro context and may have other restrictions.</p> <p>Usage example:</p> <pre><code class="prettyprint haxe">var e = macro function(i) return i * 2;
var f:Int -&gt; Int = haxe.macro.Context.eval(e);
trace(f(2)); // 4</code></pre> <p>Code passed in from outside the macro cannot reference anything in its context, such as local variables. However, it is possible to reference static methods.</p> <p>This method should be considered experimental.</p> <p>If <code>e</code> is null, the result is unspecified.</p>

<h3 class="anchor" id="registerModuleReuseCall"><code><span class="label label-static">static</span> <a href="#registerModuleReuseCall">registerModuleReuseCall</a> (<span style="white-space:nowrap">modulePath:<a class="type" title="The basic String class." href="../../../string/">String</a>,</span> <span style="white-space:nowrap">macroCall:<a class="type" title="The basic String class." href="../../../string/">String</a></span>):<a class="type" title="The standard Void type." href="../../../void/">Void</a></code></h3>
<p>Register a macro call to be performed every time the module <code>modulePath</code> is reused by the compilation cache, meaning that neither the module itself nor its dependencies was changed since last compilation.</p> <p>The <code>macroCall</code> should be a String containing valid Haxe expression, similar to <code>--init</code> macros (see https://haxe.org/manual/macro-initialization.html). Multiple calls with the exact same <code>macroCall</code> value will only register the callback once.</p> <p>This also triggers loading of given module and its dependencies, if it's not yet loaded, but given macro call will not be called on the first module load.</p> <p>If the compilation cache is not used, <code>macroCall</code> expressions will not be called, but calling this function will still trigger loading of given <code>modulePath</code>.</p>

<h3 class="anchor" id="resolvePath"><code><span class="label label-static">static</span> <a href="#resolvePath">resolvePath</a> (<span style="white-space:nowrap">file:<a class="type" title="The basic String class." href="../../../string/">String</a></span>):<a class="type" title="The basic String class." href="../../../string/">String</a></code></h3>
<p>Resolves a file name <code>file</code> based on the current class paths.</p> <p>The resolution follows the usual class path rules where the last declared class path has priority.</p> <p>If a class path was declared relative, this method returns the relative file path. Otherwise it returns the absolute file path.</p>

<h3 class="anchor" id="resolveType"><code><span class="label label-meta label-meta-require" title="@:require metadata">@:require(haxe_ver &gt;= 3.3)</span> <span class="label label-static">static</span> <a href="#resolveType">resolveType</a> (<span style="white-space:nowrap">t:<a class="type" title="Represents a type syntax in the AST." href="../complextype/">ComplexType</a>,</span> <span style="white-space:nowrap">p:<a class="type" title="Represents a position in a file." href="../position/">Position</a></span>):<a class="type" title="Represents a type." href="../type/">Type</a></code></h3>
<p>Resolve type <code>t</code> and returns the corresponding <code><a href="../../../type/">Type</a></code>.</p> <p>Resolving the type may result in a compiler error which can be caught using <code>try ... catch</code>. Resolution is performed based on the current context in which the macro is called.</p>

<h3 class="anchor" id="signature"><code><span class="label label-static">static</span> <a href="#signature">signature</a> (<span style="white-space:nowrap">v:<a class="type" title="Dynamic is a special type which is compatible with all other types." href="../../../dynamic/">Dynamic</a></span>):<a class="type" title="The basic String class." href="../../../string/">String</a></code></h3>
<p>Returns a hashed MD5 signature of value <code>v</code>.</p>

<h3 class="anchor" id="storeTypedExpr"><code><span class="label label-meta label-meta-require" title="@:require metadata">@:require(haxe_ver &gt;= 3.2)</span> <span class="label label-static">static</span> <a href="#storeTypedExpr">storeTypedExpr</a> (<span style="white-space:nowrap">t:<a class="type" title="Represents a typed AST node." href="../typedexpr/">TypedExpr</a></span>):<a class="type" title="Represents a node in the AST." href="../expr/">Expr</a></code></h3>
<p>Store typed expression <code>t</code> internally and give a syntax-level expression that can be returned from a macro and will be replaced by the stored typed expression.</p> <p>If <code>t</code> is null or invalid, an exception is thrown.</p> <p>NOTE: the returned value references an internally stored typed expression that is reset between compilations, so care should be taken when storing the expression returned by this method in a static variable and using the compilation server.</p>

<h3 class="anchor" id="toComplexType"><code><span class="label label-static">static</span> <a href="#toComplexType">toComplexType</a> (<span style="white-space:nowrap">t:<a class="type" title="Represents a type." href="../type/">Type</a></span>):<a class="type" title="Null can be useful in two cases." href="../../../null/">Null</a>&lt;<a class="type" title="Represents a type syntax in the AST." href="../complextype/">ComplexType</a>&gt;</code></h3>
<p>Returns the <code><a href="../complextype/#ComplexType">ComplexType</a></code> corresponding to the given <code><a href="../../../type/">Type</a></code> <code>t</code>.</p> <p>See <code><a href="../typetools/#toComplexType">haxe.macro.TypeTools.toComplexType</a></code> for details.</p>

<h3 class="anchor" id="typeExpr"><code><span class="label label-meta label-meta-require" title="@:require metadata">@:require(haxe_ver &gt;= 3.1)</span> <span class="label label-static">static</span> <a href="#typeExpr">typeExpr</a> (<span style="white-space:nowrap">e:<a class="type" title="Represents a node in the AST." href="../expr/">Expr</a></span>):<a class="type" title="Represents a typed AST node." href="../typedexpr/">TypedExpr</a></code></h3>
<p>Types expression <code>e</code> and returns the corresponding <code><a href="../typedexpr/#TypedExpr">TypedExpr</a></code>.</p> <p>Typing the expression may result in a compiler error which can be caught using <code>try ... catch</code>.</p>

<h3 class="anchor" id="typeof"><code><span class="label label-static">static</span> <a href="#typeof">typeof</a> (<span style="white-space:nowrap">e:<a class="type" title="Represents a node in the AST." href="../expr/">Expr</a></span>):<a class="type" title="Represents a type." href="../type/">Type</a></code></h3>
<p>Types expression <code>e</code> and returns its type.</p> <p>Typing the expression may result in a compiler error which can be caught using <code>try ... catch</code>.</p>

<h3 class="anchor" id="unify"><code><span class="label label-static">static</span> <a href="#unify">unify</a> (<span style="white-space:nowrap">t1:<a class="type" title="Represents a type." href="../type/">Type</a>,</span> <span style="white-space:nowrap">t2:<a class="type" title="Represents a type." href="../type/">Type</a></span>):<a class="type" title="The standard Boolean type, which can either be true or false." href="../../../bool/">Bool</a></code></h3>
<p>Tries to unify <code>t1</code> and <code>t2</code> and returns <code><a href="../../../bool/">true</a></code> if successful.</p>

<h3 class="anchor" id="warning"><code><span class="label label-static">static</span> <a href="#warning">warning</a> (<span style="white-space:nowrap">msg:<a class="type" title="The basic String class." href="../../../string/">String</a>,</span> <span style="white-space:nowrap">pos:<a class="type" title="Represents a position in a file." href="../position/">Position</a></span>):<a class="type" title="The standard Void type." href="../../../void/">Void</a></code></h3>
<p>Displays a compilation warning <code>msg</code> at the given <code><a href="../position/#Position">Position</a></code> <code>pos</code>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2005–2018 Haxe Foundation<br>Licensed under a MIT license.<br>
    <a href="https://api.haxe.org/haxe/macro/Context.html" class="_attribution-link" target="_blank">https://api.haxe.org/haxe/macro/Context.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
