
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Application - Elixir 1.9 - W3cubDocs</title>
  
  <meta name="description" content=" A module for working with applications and defining application callbacks. ">
  <meta name="keywords" content="application, summary, types, app, key, restart, type, start, state, value, functions, dir, path, delete, env, opts, ensure, all, started, temporary, fetch, env!, format, error, reason, get, module, default, nil, load, loaded, applications, put, config, spec, timeout, stop, unload, callbacks, change, changed, new, removed, prep, args, phase, -, elixir, elixir~1.9">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.9/application/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/elixir~1.9.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.9/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.9</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1>  Application <small>behaviour</small>  </h1>  <p>A module for working with applications and defining application callbacks.</p> <p>Applications are the idiomatic way to package software in Erlang/OTP. To get the idea, they are similar to the "library" concept common in other programming languages, but with some additional characteristics.</p> <p>An application is a component implementing some specific functionality, with a standardized directory structure, configuration, and lifecycle. Applications are <em>loaded</em>, <em>started</em>, and <em>stopped</em>.</p> <h2 id="module-the-application-resource-file" class="section-heading">  The application resource file </h2> <p>Applications are specified in their <a href="http://erlang.org/doc/man/app.html" target="_blank"><em>resource file</em></a>, which is a file called <code class="inline">APP.app</code>, where <code class="inline">APP</code> is the application name. For example, the application resource file of the OTP application <code class="inline">ex_unit</code> is called <code class="inline">ex_unit.app</code>.</p> <p>You'll find the resource file of an application in its <code class="inline">ebin</code> directory, it is generated automatically by Mix. Some of its keys are taken from the keyword lists returned by the <code class="inline">project/0</code> and <code class="inline">application/0</code> functions defined in <code class="inline">mix.exs</code>, and others are generated by Mix itself.</p> <p>You can learn more about the generation of application resource files in the documentation of <a href="https://hexdocs.pm/mix/Mix.Tasks.Compile.App.html" target="_blank"><code class="inline">Mix.Tasks.Compile.App</code></a>, available as well by running <a href="https://hexdocs.pm/mix/Mix.Tasks.Compile.App.html" target="_blank"><code class="inline">mix help compile.app</code></a>.</p> <h2 id="module-the-application-environment" class="section-heading">  The application environment </h2> <p>The key <code class="inline">env</code> of an application resource file has a list of tuples that map atoms to terms, and its contents are known as the application <em>environment</em>. Note that this environment is unrelated to the operating system environment.</p> <p>By default, the environment of an application is an empty list. In a Mix project you can set that key in <code class="inline">application/0</code>:</p> <pre data-language="elixir">def application do
  [env: [redis_host: "localhost"]]
end</pre> <p>and the generated application resource file is going to have it included.</p> <p>The environment is available after loading the application, which is a process explained later:</p> <pre data-language="elixir">Application.load(:APP_NAME)
#=&gt; :ok

Application.get_env(:APP_NAME, :redis_host)
#=&gt; "localhost"</pre> <p>In Mix projects, the environment of the application and its dependencies can be overridden via the <code class="inline">config/config.exs</code> file. If you start the application with Mix, that configuration is available at compile time, and at runtime too, but take into account it is not included in the generated application resource file, and it is not available if you start the application without Mix.</p> <p>For example, someone using your application can override its <code class="inline">:redis_host</code> environment variable as follows:</p> <pre data-language="elixir">config :APP_NAME, redis_host: "redis.local"</pre> <p>The function <a href="#put_env/3"><code class="inline">put_env/3</code></a> allows dynamic configuration of the application environment, but as a rule of thumb each application is responsible for its own environment. Please do not use the functions in this module for directly accessing or modifying the environment of other applications.</p> <p>The application environment can be overridden via the <code class="inline">-config</code> option of <code class="inline">erl</code>, as well as command-line options, as we are going to see below.</p> <h2 id="module-the-application-callback-module" class="section-heading">  The application callback module </h2> <p>The <code class="inline">mod</code> key of an application resource file configures an application callback module and start argument:</p> <pre data-language="elixir">def application do
  [mod: {MyApp, []}]
end</pre> <p>This key is optional, only needed for applications that start a supervision tree.</p> <p>The <code class="inline">MyApp</code> module given to <code class="inline">:mod</code> needs to implement the <a href="#content"><code class="inline">Application</code></a> behaviour. This can be done by putting <code class="inline">use Application</code> in that module and implementing the <a href="#c:start/2"><code class="inline">start/2</code></a> callback, for example:</p> <pre data-language="elixir">defmodule MyApp do
  use Application

  def start(_type, _args) do
    children = []
    Supervisor.start_link(children, strategy: :one_for_one)
  end
end</pre> <p>The <a href="#c:start/2"><code class="inline">start/2</code></a> callback has to spawn and link a supervisor and return <code class="inline">{:ok, pid}</code> or <code class="inline">{:ok, pid, state}</code>, where <code class="inline">pid</code> is the PID of the supervisor, and <code class="inline">state</code> is an optional application state. <code class="inline">args</code> is the second element of the tuple given to the <code class="inline">:mod</code> option.</p> <p>The <code class="inline">type</code> argument passed to <a href="#c:start/2"><code class="inline">start/2</code></a> is usually <code class="inline">:normal</code> unless in a distributed setup where application takeovers and failovers are configured. Distributed applications are beyond the scope of this documentation.</p> <p>When an application is shutting down, its <a href="#c:stop/1"><code class="inline">stop/1</code></a> callback is called after the supervision tree has been stopped by the runtime. This callback allows the application to do any final cleanup. The argument is the state returned by <a href="#c:start/2"><code class="inline">start/2</code></a>, if it did, or <code class="inline">[]</code> otherwise. The return value of <a href="#c:stop/1"><code class="inline">stop/1</code></a> is ignored.</p> <p>By using <a href="#content"><code class="inline">Application</code></a>, modules get a default implementation of <a href="#c:stop/1"><code class="inline">stop/1</code></a> that ignores its argument and returns <code class="inline">:ok</code>, but it can be overridden.</p> <p>Application callback modules may also implement the optional callback <a href="#c:prep_stop/1"><code class="inline">prep_stop/1</code></a>. If present, <a href="#c:prep_stop/1"><code class="inline">prep_stop/1</code></a> is invoked before the supervision tree is terminated. Its argument is the state returned by <a href="#c:start/2"><code class="inline">start/2</code></a>, if it did, or <code class="inline">[]</code> otherwise, and its return value is passed to <a href="#c:stop/1"><code class="inline">stop/1</code></a>.</p> <h2 id="module-the-application-lifecycle" class="section-heading">  The application lifecycle </h2> <h3 id="module-loading-applications" class="section-heading">  Loading applications </h3> <p>Applications are <em>loaded</em>, which means that the runtime finds and processes their resource files:</p> <pre data-language="elixir">Application.load(:ex_unit)
#=&gt; :ok</pre> <p>If an application has included applications, they are also loaded. And the procedure recurses if they in turn have included applications. Included applications are unrelated to applications in Mix umbrella projects, they are an Erlang/OTP concept that has to do with coordinated starts.</p> <p>When an application is loaded, the environment specified in its resource file is merged with any overrides from config files passed to <code class="inline">erl</code> via the <code class="inline">-config</code> option. It is worth highlighting that releases pass <code class="inline">sys.config</code> this way. The resulting environment can still be overridden again via specific <code class="inline">-Application</code> options passed to <code class="inline">erl</code>.</p> <p>Loading an application <em>does not</em> load its modules.</p> <p>In practice, you rarely load applications by hand because that is part of the start process, explained next.</p> <h3 id="module-starting-applications" class="section-heading">  Starting applications </h3> <p>Applications are also <em>started</em>:</p> <pre data-language="elixir">Application.start(:ex_unit)
#=&gt; :ok</pre> <p>Once your application is compiled, running your system is a matter of starting your current application and its dependencies. Differently from other languages, Elixir does not have a <code class="inline">main</code> procedure that is responsible for starting your system. Instead, you start one or more applications, each with their own initialization and termination logic.</p> <p>When an application is started, the runtime loads it if it hasn't been loaded yet (in the technical sense described above). Then, it checks if the dependencies listed in the <code class="inline">applications</code> key of the resource file are already started. Having at least one dependency not started is an error condition, but when you start an application with <a href="https://hexdocs.pm/mix/Mix.Tasks.Run.html" target="_blank"><code class="inline">mix run</code></a>, Mix takes care of starting all the dependencies for you, so in practice you don't need to worry about it unless you are starting applications manually with the API provided by this module.</p> <p>If the application does not have a callback module configured, starting is done at this point. Otherwise, its <a href="#c:start/2"><code class="inline">start/2</code></a> callback if invoked. The PID of the top-level supervisor returned by this function is stored by the runtime for later use, and the returned application state is saved too, if any.</p> <h3 id="module-stopping-applications" class="section-heading">  Stopping applications </h3> <p>Started applications are, finally, <em>stopped</em>:</p> <pre data-language="elixir">Application.stop(:ex_unit)
#=&gt; :ok</pre> <p>Stopping an application without a callback module is defined, but except for some system tracing, it is in practice a no-op.</p> <p>Stopping an application with a callback module has three steps:</p> <ol> <li>If present, invoke the optional callback <a href="#c:prep_stop/1"><code class="inline">prep_stop/1</code></a>. </li> <li>Terminate the top-level supervisor. </li> <li>Invoke the required callback <a href="#c:stop/1"><code class="inline">stop/1</code></a>. </li> </ol> <p>The arguments passed to the callbacks are related to the state optionally returned by <a href="#c:start/2"><code class="inline">start/2</code></a>, and are documented in the section about the callback module above.</p> <p>It is important to highlight that step 2 is a blocking one. Termination of a supervisor triggers a recursive chain of children terminations, therefore orderly shutting down all descendant processes. The <a href="#c:stop/1"><code class="inline">stop/1</code></a> callback is invoked only after termination of the whole supervision tree.</p> <p>Shutting down a live system cleanly can be done by calling <a href="../system/#stop/1"><code class="inline">System.stop/1</code></a>. It will shut down every application in the opposite order they had been started.</p> <p>By default, a SIGTERM from the operating system will automatically translate to <a href="../system/#stop/0"><code class="inline">System.stop/0</code></a>. You can also have more explicit control over operating system signals via the <a href="http://www.erlang.org/doc/man/os.html#set_signal-2" target="_blank"><code class="inline">:os.set_signal/2</code></a> function.</p> <h2 id="module-tooling" class="section-heading">  Tooling </h2> <p>The Mix build tool can also be used to start your applications. For example, <a href="https://hexdocs.pm/mix/Mix.Tasks.Test.html" target="_blank"><code class="inline">mix test</code></a> automatically starts your application dependencies and your application itself before your test runs. <code class="inline">mix run --no-halt</code> boots your current project and can be used to start a long running system. See <a href="https://hexdocs.pm/mix/Mix.Tasks.Run.html" target="_blank"><code class="inline">mix help run</code></a>.</p> <p>Developers can also use tools like <a href="https://github.com/bitwalker/distillery" target="_blank">Distillery</a> that build <strong>releases</strong>. Releases are able to package all of your source code as well as the Erlang VM into a single directory. Releases also give you explicit control over how each application is started and in which order. They also provide a more streamlined mechanism for starting and stopping systems, debugging, logging, as well as system monitoring.</p> <p>Finally, Elixir provides tools such as escripts and archives, which are different mechanisms for packaging your application. Those are typically used when tools must be shared between developers and not as deployment options. See <a href="https://hexdocs.pm/mix/Mix.Tasks.Archive.Build.html" target="_blank"><code class="inline">mix help archive.build</code></a> and <a href="https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html" target="_blank"><code class="inline">mix help escript.build</code></a> for more detail.</p> <h2 id="module-further-information" class="section-heading">  Further information </h2> <p>For further details on applications please check the documentation of the <a href="http://www.erlang.org/doc/man/application.html" target="_blank"><code class="inline">application</code></a> Erlang module, and the <a href="http://www.erlang.org/doc/design_principles/applications.html" target="_blank">Applications</a> section of the <a href="http://erlang.org/doc/design_principles/users_guide.html" target="_blank">OTP Design Principles User's Guide</a>.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:app/0">app()</a> </dt>   <dt class="summary-signature"> <a href="#t:application_key/0">application_key()</a> </dt>   <dt class="summary-signature"> <a href="#t:key/0">key()</a> </dt>   <dt class="summary-signature"> <a href="#t:restart_type/0">restart_type()</a> </dt>   <dt class="summary-signature"> <a href="#t:start_type/0">start_type()</a> </dt>   <dt class="summary-signature"> <a href="#t:state/0">state()</a> </dt>   <dt class="summary-signature"> <a href="#t:value/0">value()</a> </dt>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#app_dir/1">app_dir(app)</a> </dt> <dd class="summary-synopsis"><p>Gets the directory for app.</p></dd>   <dt class="summary-signature"> <a href="#app_dir/2">app_dir(app, path)</a> </dt> <dd class="summary-synopsis"><p>Returns the given path inside <a href="#app_dir/1"><code class="inline">app_dir/1</code></a>.</p></dd>   <dt class="summary-signature"> <a href="#delete_env/3">delete_env(app, key, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Deletes the <code class="inline">key</code> from the given <code class="inline">app</code> environment.</p></dd>   <dt class="summary-signature"> <a href="#ensure_all_started/2">ensure_all_started(app, type \\ :temporary)</a> </dt> <dd class="summary-synopsis"><p>Ensures the given <code class="inline">app</code> and its applications are started.</p></dd>   <dt class="summary-signature"> <a href="#ensure_started/2">ensure_started(app, type \\ :temporary)</a> </dt> <dd class="summary-synopsis"><p>Ensures the given <code class="inline">app</code> is started.</p></dd>   <dt class="summary-signature"> <a href="#fetch_env/2">fetch_env(app, key)</a> </dt> <dd class="summary-synopsis"><p>Returns the value for <code class="inline">key</code> in <code class="inline">app</code>'s environment in a tuple.</p></dd>   <dt class="summary-signature"> <a href="#fetch_env!/2">fetch_env!(app, key)</a> </dt> <dd class="summary-synopsis"><p>Returns the value for <code class="inline">key</code> in <code class="inline">app</code>'s environment.</p></dd>   <dt class="summary-signature"> <a href="#format_error/1">format_error(reason)</a> </dt> <dd class="summary-synopsis"><p>Formats the error reason returned by <a href="#start/2"><code class="inline">start/2</code></a>, <a href="#ensure_started/2"><code class="inline">ensure_started/2</code></a>, <a href="#stop/1"><code class="inline">stop/1</code></a>, <a href="#load/1"><code class="inline">load/1</code></a> and <a href="#unload/1"><code class="inline">unload/1</code></a>, returns a string.</p></dd>   <dt class="summary-signature"> <a href="#get_all_env/1">get_all_env(app)</a> </dt> <dd class="summary-synopsis"><p>Returns all key-value pairs for <code class="inline">app</code>.</p></dd>   <dt class="summary-signature"> <a href="#get_application/1">get_application(module)</a> </dt> <dd class="summary-synopsis"><p>Gets the application for the given module.</p></dd>   <dt class="summary-signature"> <a href="#get_env/3">get_env(app, key, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Returns the value for <code class="inline">key</code> in <code class="inline">app</code>'s environment.</p></dd>   <dt class="summary-signature"> <a href="#load/1">load(app)</a> </dt> <dd class="summary-synopsis"><p>Loads the given <code class="inline">app</code>.</p></dd>   <dt class="summary-signature"> <a href="#loaded_applications/0">loaded_applications()</a> </dt> <dd class="summary-synopsis"><p>Returns a list with information about the applications which have been loaded.</p></dd>   <dt class="summary-signature"> <a href="#put_all_env/2">put_all_env(config, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Puts the environment for multiple apps at the same time.</p></dd>   <dt class="summary-signature"> <a href="#put_env/4">put_env(app, key, value, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Puts the <code class="inline">value</code> in <code class="inline">key</code> for the given <code class="inline">app</code>.</p></dd>   <dt class="summary-signature"> <a href="#spec/1">spec(app)</a> </dt> <dd class="summary-synopsis"><p>Returns the spec for <code class="inline">app</code>.</p></dd>   <dt class="summary-signature"> <a href="#spec/2">spec(app, key)</a> </dt> <dd class="summary-synopsis"><p>Returns the value for <code class="inline">key</code> in <code class="inline">app</code>'s specification.</p></dd>   <dt class="summary-signature"> <a href="#start/2">start(app, type \\ :temporary)</a> </dt> <dd class="summary-synopsis"><p>Starts the given <code class="inline">app</code>.</p></dd>   <dt class="summary-signature"> <a href="#started_applications/1">started_applications(timeout \\ 5000)</a> </dt> <dd class="summary-synopsis"><p>Returns a list with information about the applications which are currently running.</p></dd>   <dt class="summary-signature"> <a href="#stop/1">stop(app)</a> </dt> <dd class="summary-synopsis"><p>Stops the given <code class="inline">app</code>.</p></dd>   <dt class="summary-signature"> <a href="#unload/1">unload(app)</a> </dt> <dd class="summary-synopsis"><p>Unloads the given <code class="inline">app</code>.</p></dd>  </dl> <h2> Callbacks </h2>
<dl class="summary-callbacks summary">   <dt class="summary-signature"> <a href="#c:config_change/3">config_change(changed, new, removed)</a> </dt> <dd class="summary-synopsis"><p>Callback invoked after code upgrade, if the application environment has changed.</p></dd>   <dt class="summary-signature"> <a href="#c:prep_stop/1">prep_stop(state)</a> </dt> <dd class="summary-synopsis"><p>Called before stopping the application.</p></dd>   <dt class="summary-signature"> <a href="#c:start/2">start(start_type, start_args)</a> </dt> <dd class="summary-synopsis"><p>Called when an application is started.</p></dd>   <dt class="summary-signature"> <a href="#c:start_phase/3">start_phase(phase, start_type, phase_args)</a> </dt> <dd class="summary-synopsis"><p>Starts an application in synchronous phases.</p></dd>   <dt class="summary-signature"> <a href="#c:stop/1">stop(state)</a> </dt> <dd class="summary-synopsis"><p>Called after an application has been stopped.</p></dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:app/0">  <h1 class="signature">app()</h1>     </h3>
<pre data-language="elixir">app() :: atom()</pre>     <h3 class="detail-header type" id="t:application_key/0">  <h1 class="signature">application_key()</h1>     </h3>
<pre data-language="elixir">application_key() ::
  :start_phases
  | :mod
  | :applications
  | :included_applications
  | :registered
  | :maxT
  | :maxP
  | :modules
  | :vsn
  | :id
  | :description</pre>     <h3 class="detail-header type" id="t:key/0">  <h1 class="signature">key()</h1>     </h3>
<pre data-language="elixir">key() :: atom()</pre>     <h3 class="detail-header type" id="t:restart_type/0">  <h1 class="signature">restart_type()</h1>     </h3>
<pre data-language="elixir">restart_type() :: :permanent | :transient | :temporary</pre>     <h3 class="detail-header type" id="t:start_type/0">  <h1 class="signature">start_type()</h1>     </h3>
<pre data-language="elixir">start_type() :: :normal | {:takeover, node()} | {:failover, node()}</pre>     <h3 class="detail-header type" id="t:state/0">  <h1 class="signature">state()</h1>     </h3>
<pre data-language="elixir">state() :: term()</pre>     <h3 class="detail-header type" id="t:value/0">  <h1 class="signature">value()</h1>     </h3>
<pre data-language="elixir">value() :: term()</pre>       <h1 class="section-heading" id="functions">  Functions </h1>   <h3 class="detail-header function" id="app_dir/1">  <h1 class="signature">app_dir(app)</h1>     </h3>
<pre data-language="elixir">app_dir(app()) :: String.t()</pre>  <p>Gets the directory for app.</p> <p>This information is returned based on the code path. Here is an example:</p> <pre data-language="elixir">File.mkdir_p!("foo/ebin")
Code.prepend_path("foo/ebin")
Application.app_dir(:foo)
#=&gt; "foo"</pre> <p>Even though the directory is empty and there is no <code class="inline">.app</code> file it is considered the application directory based on the name "foo/ebin". The name may contain a dash <code class="inline">-</code> which is considered to be the app version and it is removed for the lookup purposes:</p> <pre data-language="elixir">File.mkdir_p!("bar-123/ebin")
Code.prepend_path("bar-123/ebin")
Application.app_dir(:bar)
#=&gt; "bar-123"</pre> <p>For more information on code paths, check the <a href="../code/"><code class="inline">Code</code></a> module in Elixir and also Erlang's <a href="http://www.erlang.org/doc/man/code.html" target="_blank"><code class="inline">:code</code> module</a>.</p>    <h3 class="detail-header function" id="app_dir/2">  <h1 class="signature">app_dir(app, path)</h1>     </h3>
<pre data-language="elixir">app_dir(app(), String.t() | [String.t()]) :: String.t()</pre>  <p>Returns the given path inside <a href="#app_dir/1"><code class="inline">app_dir/1</code></a>.</p> <p>If <code class="inline">path</code> is a string, then it will be used as the path inside <a href="#app_dir/1"><code class="inline">app_dir/1</code></a>. If <code class="inline">path</code> is a list of strings, it will be joined (see <a href="../path/#join/1"><code class="inline">Path.join/1</code></a>) and the result will be used as the path inside <a href="#app_dir/1"><code class="inline">app_dir/1</code></a>.</p> <h4 id="app_dir/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">File.mkdir_p!("foo/ebin")
Code.prepend_path("foo/ebin")

Application.app_dir(:foo, "my_path")
#=&gt; "foo/my_path"

Application.app_dir(:foo, ["my", "nested", "path"])
#=&gt; "foo/my/nested/path"</pre>     <h3 class="detail-header function" id="delete_env/3">  <h1 class="signature">delete_env(app, key, opts \\ [])</h1>     </h3>
<pre data-language="elixir">delete_env(app(), key(), timeout: timeout(), persistent: boolean()) :: :ok</pre>  <p>Deletes the <code class="inline">key</code> from the given <code class="inline">app</code> environment.</p> <p>It receives the same options as <a href="#put_env/4"><code class="inline">put_env/4</code></a>. Returns <code class="inline">:ok</code>.</p>     <h3 class="detail-header function" id="ensure_all_started/2">  <h1 class="signature">ensure_all_started(app, type \\ :temporary)</h1>     </h3>
<pre data-language="elixir">ensure_all_started(app(), restart_type()) ::
  {:ok, [app()]} | {:error, {app(), term()}}</pre>  <p>Ensures the given <code class="inline">app</code> and its applications are started.</p> <p>Same as <a href="#start/2"><code class="inline">start/2</code></a> but also starts the applications listed under <code class="inline">:applications</code> in the <code class="inline">.app</code> file in case they were not previously started.</p>     <h3 class="detail-header function" id="ensure_started/2">  <h1 class="signature">ensure_started(app, type \\ :temporary)</h1>     </h3>
<pre data-language="elixir">ensure_started(app(), restart_type()) :: :ok | {:error, term()}</pre>  <p>Ensures the given <code class="inline">app</code> is started.</p> <p>Same as <a href="#start/2"><code class="inline">start/2</code></a> but returns <code class="inline">:ok</code> if the application was already started. This is useful in scripts and in test setup, where test applications need to be explicitly started:</p> <pre data-language="elixir">:ok = Application.ensure_started(:my_test_dep)</pre>    <h3 class="detail-header function" id="fetch_env/2">  <h1 class="signature">fetch_env(app, key)</h1>     </h3>
<pre data-language="elixir">fetch_env(app(), key()) :: {:ok, value()} | :error</pre>  <p>Returns the value for <code class="inline">key</code> in <code class="inline">app</code>'s environment in a tuple.</p> <p>If the configuration parameter does not exist, the function returns <code class="inline">:error</code>.</p>    <h3 class="detail-header function" id="fetch_env!/2">  <h1 class="signature">fetch_env!(app, key)</h1>     </h3>
<pre data-language="elixir">fetch_env!(app(), key()) :: value()</pre>  <p>Returns the value for <code class="inline">key</code> in <code class="inline">app</code>'s environment.</p> <p>If the configuration parameter does not exist, raises <a href="../argumenterror/"><code class="inline">ArgumentError</code></a>.</p>    <h3 class="detail-header function" id="format_error/1">  <h1 class="signature">format_error(reason)</h1>     </h3>
<pre data-language="elixir">format_error(any()) :: String.t()</pre>  <p>Formats the error reason returned by <a href="#start/2"><code class="inline">start/2</code></a>, <a href="#ensure_started/2"><code class="inline">ensure_started/2</code></a>, <a href="#stop/1"><code class="inline">stop/1</code></a>, <a href="#load/1"><code class="inline">load/1</code></a> and <a href="#unload/1"><code class="inline">unload/1</code></a>, returns a string.</p>    <h3 class="detail-header function" id="get_all_env/1">  <h1 class="signature">get_all_env(app)</h1>     </h3>
<pre data-language="elixir">get_all_env(app()) :: [{key(), value()}]</pre>  <p>Returns all key-value pairs for <code class="inline">app</code>.</p>    <h3 class="detail-header function" id="get_application/1">  <h1 class="signature">get_application(module)</h1>     </h3>
<pre data-language="elixir">get_application(atom()) :: atom() | nil</pre>  <p>Gets the application for the given module.</p> <p>The application is located by analyzing the spec of all loaded applications. Returns <code class="inline">nil</code> if the module is not listed in any application spec.</p>     <h3 class="detail-header function" id="get_env/3">  <h1 class="signature">get_env(app, key, default \\ nil)</h1>     </h3>
<pre data-language="elixir">get_env(app(), key(), value()) :: value()</pre>  <p>Returns the value for <code class="inline">key</code> in <code class="inline">app</code>'s environment.</p> <p>If the configuration parameter does not exist, the function returns the <code class="inline">default</code> value.</p> <h4 id="get_env/3-examples" class="section-heading">  Examples </h4> <p><a href="#get_env/3"><code class="inline">get_env/3</code></a> is commonly used to read the configuration of your OTP applications. Since Mix configurations are commonly used to configure applications, we will use this as a point of illustration.</p> <p>Consider a new application <code class="inline">:my_app</code>. <code class="inline">:my_app</code> contains a database engine which supports a pool of databases. The database engine needs to know the configuration for each of those databases, and that configuration is supplied by key-value pairs in environment of <code class="inline">:my_app</code>.</p> <pre data-language="elixir">config :my_app, Databases.RepoOne,
  # A database configuration
  ip: "localhost",
  port: 5433

config :my_app, Databases.RepoTwo,
  # Another database configuration (for the same OTP app)
  ip: "localhost",
  port: 20717

config :my_app, my_app_databases: [Databases.RepoOne, Databases.RepoTwo]</pre> <p>Our database engine used by <code class="inline">:my_app</code> needs to know what databases exist, and what the database configurations are. The database engine can make a call to <code class="inline">get_env(:my_app, :my_app_databases)</code> to retrieve the list of databases (specified by module names). Our database engine can then traverse each repository in the list and then call <code class="inline">get_env(:my_app, Databases.RepoOne)</code> and so forth to retrieve the configuration of each one.</p> <p><strong>Important:</strong> if you are writing a library to be used by other developers, it is generally recommended to avoid the application environment, as the application environment is effectively a global storage. For more information, read our <a href="../library-guidelines/">library guidelines</a>.</p>    <h3 class="detail-header function" id="load/1">  <h1 class="signature">load(app)</h1>     </h3>
<pre data-language="elixir">load(app()) :: :ok | {:error, term()}</pre>  <p>Loads the given <code class="inline">app</code>.</p> <p>In order to be loaded, an <code class="inline">.app</code> file must be in the load paths. All <code class="inline">:included_applications</code> will also be loaded.</p> <p>Loading the application does not start it nor load its modules, but it does load its environment.</p>    <h3 class="detail-header function" id="loaded_applications/0">  <h1 class="signature">loaded_applications()</h1>     </h3>
<pre data-language="elixir">loaded_applications() :: [
  {app(), description :: charlist(), vsn :: charlist()}
]</pre>  <p>Returns a list with information about the applications which have been loaded.</p>     <h3 class="detail-header function" id="put_all_env/2">  <h1 class="signature">put_all_env(config, opts \\ [])</h1>     </h3>
<pre data-language="elixir">put_all_env([{app(), [{key(), value()}]}],
  timeout: timeout(),
  persistent: boolean()
) :: :ok</pre>  <p>Puts the environment for multiple apps at the same time.</p> <p>The given config should not:</p> <ul> <li>have the same application listed more than once </li> <li>have the same key inside the same application listed more than once </li> </ul> <p>If those conditions are not met, the behaviour is undefined (on Erlang/OTP 21 and earlier) or will raise (on Erlang/OTP 22 and later).</p> <p>It receives the same options as <a href="#put_env/4"><code class="inline">put_env/4</code></a>. Returns <code class="inline">:ok</code>.</p>     <h3 class="detail-header function" id="put_env/4">  <h1 class="signature">put_env(app, key, value, opts \\ [])</h1>     </h3>
<pre data-language="elixir">put_env(app(), key(), value(), timeout: timeout(), persistent: boolean()) ::
  :ok</pre>  <p>Puts the <code class="inline">value</code> in <code class="inline">key</code> for the given <code class="inline">app</code>.</p> <h4 id="put_env/4-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:timeout</code> - the timeout for the change (defaults to <code class="inline">5_000</code> milliseconds) </li> <li>
<code class="inline">:persistent</code> - persists the given value on application load and reloads </li> </ul> <p>If <a href="#put_env/4"><code class="inline">put_env/4</code></a> is called before the application is loaded, the application environment values specified in the <code class="inline">.app</code> file will override the ones previously set.</p> <p>The <code class="inline">:persistent</code> option can be set to <code class="inline">true</code> when there is a need to guarantee parameters set with this function will not be overridden by the ones defined in the application resource file on load. This means persistent values will stick after the application is loaded and also on application reload.</p>    <h3 class="detail-header function" id="spec/1">  <h1 class="signature">spec(app)</h1>     </h3>
<pre data-language="elixir">spec(app()) :: [{application_key(), value()}] | nil</pre>  <p>Returns the spec for <code class="inline">app</code>.</p> <p>The following keys are returned:</p> <ul> <li>
<code class="inline">:description</code> </li> <li>
<code class="inline">:id</code> </li> <li>
<code class="inline">:vsn</code> </li> <li>
<code class="inline">:modules</code> </li> <li>
<code class="inline">:maxP</code> </li> <li>
<code class="inline">:maxT</code> </li> <li>
<code class="inline">:registered</code> </li> <li>
<code class="inline">:included_applications</code> </li> <li>
<code class="inline">:applications</code> </li> <li>
<code class="inline">:mod</code> </li> <li>
<code class="inline">:start_phases</code> </li> </ul> <p>Note the environment is not returned as it can be accessed via <a href="#fetch_env/2"><code class="inline">fetch_env/2</code></a>. Returns <code class="inline">nil</code> if the application is not loaded.</p>    <h3 class="detail-header function" id="spec/2">  <h1 class="signature">spec(app, key)</h1>     </h3>
<pre data-language="elixir">spec(app(), application_key()) :: value() | nil</pre>  <p>Returns the value for <code class="inline">key</code> in <code class="inline">app</code>'s specification.</p> <p>See <a href="#spec/1"><code class="inline">spec/1</code></a> for the supported keys. If the given specification parameter does not exist, this function will raise. Returns <code class="inline">nil</code> if the application is not loaded.</p>     <h3 class="detail-header function" id="start/2">  <h1 class="signature">start(app, type \\ :temporary)</h1>     </h3>
<pre data-language="elixir">start(app(), restart_type()) :: :ok | {:error, term()}</pre>  <p>Starts the given <code class="inline">app</code>.</p> <p>If the <code class="inline">app</code> is not loaded, the application will first be loaded using <a href="#load/1"><code class="inline">load/1</code></a>. Any included application, defined in the <code class="inline">:included_applications</code> key of the <code class="inline">.app</code> file will also be loaded, but they won't be started.</p> <p>Furthermore, all applications listed in the <code class="inline">:applications</code> key must be explicitly started before this application is. If not, <code class="inline">{:error, {:not_started, app}}</code> is returned, where <code class="inline">app</code> is the name of the missing application.</p> <p>In case you want to automatically load <strong>and start</strong> all of <code class="inline">app</code>'s dependencies, see <a href="#ensure_all_started/2"><code class="inline">ensure_all_started/2</code></a>.</p> <p>The <code class="inline">type</code> argument specifies the type of the application:</p> <ul> <li>
<p><code class="inline">:permanent</code> - if <code class="inline">app</code> terminates, all other applications and the entire node are also terminated.</p> </li> <li>
<p><code class="inline">:transient</code> - if <code class="inline">app</code> terminates with <code class="inline">:normal</code> reason, it is reported but no other applications are terminated. If a transient application terminates abnormally, all other applications and the entire node are also terminated.</p> </li> <li>
<p><code class="inline">:temporary</code> - if <code class="inline">app</code> terminates, it is reported but no other applications are terminated (the default).</p> </li> </ul> <p>Note that it is always possible to stop an application explicitly by calling <a href="#stop/1"><code class="inline">stop/1</code></a>. Regardless of the type of the application, no other applications will be affected.</p> <p>Note also that the <code class="inline">:transient</code> type is of little practical use, since when a supervision tree terminates, the reason is set to <code class="inline">:shutdown</code>, not <code class="inline">:normal</code>.</p>     <h3 class="detail-header function" id="started_applications/1">  <h1 class="signature">started_applications(timeout \\ 5000)</h1>     </h3>
<pre data-language="elixir">started_applications(timeout()) :: [
  {app(), description :: charlist(), vsn :: charlist()}
]</pre>  <p>Returns a list with information about the applications which are currently running.</p>    <h3 class="detail-header function" id="stop/1">  <h1 class="signature">stop(app)</h1>     </h3>
<pre data-language="elixir">stop(app()) :: :ok | {:error, term()}</pre>  <p>Stops the given <code class="inline">app</code>.</p> <p>When stopped, the application is still loaded.</p>    <h3 class="detail-header function" id="unload/1">  <h1 class="signature">unload(app)</h1>     </h3>
<pre data-language="elixir">unload(app()) :: :ok | {:error, term()}</pre>  <p>Unloads the given <code class="inline">app</code>.</p> <p>It will also unload all <code class="inline">:included_applications</code>. Note that the function does not purge the application modules.</p>      <h1 class="section-heading" id="callbacks">  Callbacks </h1>   <h3 class="detail-header callback" id="c:config_change/3">  <h1 class="signature">config_change(changed, new, removed)</h1>  <span class="note">(optional)</span>    </h3>
<pre data-language="elixir">config_change(changed, new, removed) :: :ok
when changed: keyword(), new: keyword(), removed: [atom()]</pre>  <p>Callback invoked after code upgrade, if the application environment has changed.</p> <p><code class="inline">changed</code> is a keyword list of keys and their changed values in the application environment. <code class="inline">new</code> is a keyword list with all new keys and their values. <code class="inline">removed</code> is a list with all removed keys.</p>    <h3 class="detail-header callback" id="c:prep_stop/1">  <h1 class="signature">prep_stop(state)</h1>  <span class="note">(optional)</span>    </h3>
<pre data-language="elixir">prep_stop(state()) :: state()</pre>  <p>Called before stopping the application.</p> <p>This function is called before the top-level supervisor is terminated. It receives the state returned by <a href="#c:start/2"><code class="inline">start/2</code></a>, if it did, or <code class="inline">[]</code> otherwise. The return value is later passed to <a href="#c:stop/1"><code class="inline">stop/1</code></a>.</p>    <h3 class="detail-header callback" id="c:start/2">  <h1 class="signature">start(start_type, start_args)</h1>     </h3>
<pre data-language="elixir">start(start_type(), start_args :: term()) ::
  {:ok, pid()} | {:ok, pid(), state()} | {:error, reason :: term()}</pre>  <p>Called when an application is started.</p> <p>This function is called when an application is started using <a href="../application/#start/2"><code class="inline">Application.start/2</code></a> (and functions on top of that, such as <a href="../application/#ensure_started/2"><code class="inline">Application.ensure_started/2</code></a>). This function should start the top-level process of the application (which should be the top supervisor of the application's supervision tree if the application follows the OTP design principles around supervision).</p> <p><code class="inline">start_type</code> defines how the application is started:</p> <ul> <li>
<code class="inline">:normal</code> - used if the startup is a normal startup or if the application is distributed and is started on the current node because of a failover from another node and the application specification key <code class="inline">:start_phases</code> is <code class="inline">:undefined</code>. </li> <li>
<code class="inline">{:takeover, node}</code> - used if the application is distributed and is started on the current node because of a failover on the node <code class="inline">node</code>. </li> <li>
<code class="inline">{:failover, node}</code> - used if the application is distributed and is started on the current node because of a failover on node <code class="inline">node</code>, and the application specification key <code class="inline">:start_phases</code> is not <code class="inline">:undefined</code>. </li> </ul> <p><code class="inline">start_args</code> are the arguments passed to the application in the <code class="inline">:mod</code> specification key (e.g., <code class="inline">mod: {MyApp, [:my_args]}</code>).</p> <p>This function should either return <code class="inline">{:ok, pid}</code> or <code class="inline">{:ok, pid, state}</code> if startup is successful. <code class="inline">pid</code> should be the PID of the top supervisor. <code class="inline">state</code> can be an arbitrary term, and if omitted will default to <code class="inline">[]</code>; if the application is later stopped, <code class="inline">state</code> is passed to the <a href="#stop/1"><code class="inline">stop/1</code></a> callback (see the documentation for the <a href="#c:stop/1"><code class="inline">stop/1</code></a> callback for more information).</p> <p><code class="inline">use Application</code> provides no default implementation for the <a href="#start/2"><code class="inline">start/2</code></a> callback.</p>    <h3 class="detail-header callback" id="c:start_phase/3">  <h1 class="signature">start_phase(phase, start_type, phase_args)</h1>  <span class="note">(optional)</span>    </h3>
<pre data-language="elixir">start_phase(phase :: term(), start_type(), phase_args :: term()) ::
  :ok | {:error, reason :: term()}</pre>  <p>Starts an application in synchronous phases.</p> <p>This function is called after <a href="#start/2"><code class="inline">start/2</code></a> finishes but before <a href="../application/#start/2"><code class="inline">Application.start/2</code></a> returns. It will be called once for every start phase defined in the application's (and any included applications') specification, in the order they are listed in.</p>    <h3 class="detail-header callback" id="c:stop/1">  <h1 class="signature">stop(state)</h1>     </h3>
<pre data-language="elixir">stop(state()) :: term()</pre>  <p>Called after an application has been stopped.</p> <p>This function is called after an application has been stopped, i.e., after its supervision tree has been stopped. It should do the opposite of what the <a href="#c:start/2"><code class="inline">start/2</code></a> callback did, and should perform any necessary cleanup. The return value of this callback is ignored.</p> <p><code class="inline">state</code> is the state returned by <a href="#c:start/2"><code class="inline">start/2</code></a>, if it did, or <code class="inline">[]</code> otherwise. If the optional callback <a href="#c:prep_stop/1"><code class="inline">prep_stop/1</code></a> is present, <code class="inline">state</code> is its return value instead.</p> <p><code class="inline">use Application</code> defines a default implementation of this function which does nothing and just returns <code class="inline">:ok</code>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.9.1/Application.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.9.1/Application.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
