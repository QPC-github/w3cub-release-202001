
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Map - Elixir 1.9 - W3cubDocs</title>
  
  <meta name="description" content=" A set of functions for working with maps. ">
  <meta name="keywords" content="map, summary, types, key, value, functions, delete, drop, keys, equal, fetch, fetch!, from, struct, get, default, nil, and, update, fun, update!, lazy, has, merge, new, enumerable, transform, pop, put, replace!, split, take, list, initial, values, -, elixir, elixir~1.9">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.9/map/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/elixir~1.9.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.9/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.9</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1>  Map  </h1>  <p>A set of functions for working with maps.</p> <p>Many functions for maps, which implement the <a href="../enumerable/"><code class="inline">Enumerable</code></a> protocol, are found in the <a href="../enum/"><code class="inline">Enum</code></a> module. Additionally, the following functions for maps are found in <a href="../kernel/"><code class="inline">Kernel</code></a>:</p> <ul> <li>
<a href="../kernel/#map_size/1"><code class="inline">map_size/1</code></a> </li> </ul> <p>Maps are the "go to" key-value data structure in Elixir. Maps can be created with the <code class="inline">%{}</code> syntax, and key-value pairs can be expressed as <code class="inline">key =&gt; value</code>:</p> <pre data-language="elixir">iex&gt; %{}
%{}
iex&gt; %{"one" =&gt; :two, 3 =&gt; "four"}
%{3 =&gt; "four", "one" =&gt; :two}</pre> <p>Key-value pairs in a map do not follow any order (that's why the printed map in the example above has a different order than the map that was created).</p> <p>Maps do not impose any restriction on the key type: anything can be a key in a map. As a key-value structure, maps do not allow duplicated keys. Keys are compared using the exact-equality operator (<a href="../kernel/#===/2"><code class="inline">===/2</code></a>). If colliding keys are defined in a map literal, the last one prevails.</p> <p>When the key in a key-value pair is an atom, the <code class="inline">key: value</code> shorthand syntax can be used (as in many other special forms), provided key-value pairs are put at the end:</p> <pre data-language="elixir">iex&gt; %{"hello" =&gt; "world", a: 1, b: 2}
%{:a =&gt; 1, :b =&gt; 2, "hello" =&gt; "world"}</pre> <p>Keys in maps can be accessed through some of the functions in this module (such as <a href="../map/#get/3"><code class="inline">Map.get/3</code></a> or <a href="../map/#fetch/2"><code class="inline">Map.fetch/2</code></a>) or through the <code class="inline">map[]</code> syntax provided by the <a href="../access/"><code class="inline">Access</code></a> module:</p> <pre data-language="elixir">iex&gt; map = %{a: 1, b: 2}
iex&gt; Map.fetch(map, :a)
{:ok, 1}
iex&gt; map[:b]
2
iex&gt; map["non_existing_key"]
nil</pre> <p>For accessing atom keys, one may also <code class="inline">map.key</code>. Note that while <code class="inline">map[key]</code> will return <code class="inline">nil</code> if <code class="inline">map</code> doesn't contain <code class="inline">key</code>, <code class="inline">map.key</code> will raise if <code class="inline">map</code> doesn't contain the key <code class="inline">:key</code>.</p> <pre data-language="elixir">iex&gt; map = %{foo: "bar", baz: "bong"}
iex&gt; map.foo
"bar"
iex&gt; map.non_existing_key
** (KeyError) key :non_existing_key not found in: %{baz: "bong", foo: "bar"}</pre> <p>The two syntaxes for accessing keys reveal the dual nature of maps. The <code class="inline">map[key]</code> syntax is used for dynamically created maps that may have any key, of any type. <code class="inline">map.key</code> is used with maps that hold a predetermined set of atoms keys, which are expected to always be present. Structs, defined via <a href="../kernel/#defstruct/1"><code class="inline">defstruct/1</code></a>, are one example of such "static maps", where the keys can also be checked during compile time.</p> <p>Maps can be pattern matched on. When a map is on the left-hand side of a pattern match, it will match if the map on the right-hand side contains the keys on the left-hand side and their values match the ones on the left-hand side. This means that an empty map matches every map.</p> <pre data-language="elixir">iex&gt; %{} = %{foo: "bar"}
%{foo: "bar"}
iex&gt; %{a: a} = %{:a =&gt; 1, "b" =&gt; 2, [:c, :e, :e] =&gt; 3}
iex&gt; a
1
iex&gt; %{:c =&gt; 3} = %{:a =&gt; 1, 2 =&gt; :b}
** (MatchError) no match of right hand side value: %{2 =&gt; :b, :a =&gt; 1}</pre> <p>Variables can be used as map keys both when writing map literals as well as when matching:</p> <pre data-language="elixir">iex&gt; n = 1
1
iex&gt; %{n =&gt; :one}
%{1 =&gt; :one}
iex&gt; %{^n =&gt; :one} = %{1 =&gt; :one, 2 =&gt; :two, 3 =&gt; :three}
%{1 =&gt; :one, 2 =&gt; :two, 3 =&gt; :three}</pre> <p>Maps also support a specific update syntax to update the value stored under <em>existing</em> atom keys:</p> <pre data-language="elixir">iex&gt; map = %{one: 1, two: 2}
iex&gt; %{map | one: "one"}
%{one: "one", two: 2}
iex&gt; %{map | three: 3}
** (KeyError) key :three not found</pre> <p>The functions in this module that need to find a specific key work in logarithmic time. This means that the time it takes to find keys grows as the map grows, but it's not directly proportional to the map size. In comparison to finding an element in a list, it performs better because lists have a linear time complexity. Some functions, such as <a href="#keys/1"><code class="inline">keys/1</code></a> and <a href="#values/1"><code class="inline">values/1</code></a>, run in linear time because they need to get to every element in the map.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:key/0">key()</a> </dt>   <dt class="summary-signature"> <a href="#t:value/0">value()</a> </dt>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#delete/2">delete(map, key)</a> </dt> <dd class="summary-synopsis"><p>Deletes the entry in <code class="inline">map</code> for a specific <code class="inline">key</code>.</p></dd>   <dt class="summary-signature"> <a href="#drop/2">drop(map, keys)</a> </dt> <dd class="summary-synopsis"><p>Drops the given <code class="inline">keys</code> from <code class="inline">map</code>.</p></dd>   <dt class="summary-signature"> <a href="#equal?/2">equal?(map1, map2)</a> </dt> <dd class="summary-synopsis"><p>Checks if two maps are equal.</p></dd>   <dt class="summary-signature"> <a href="#fetch/2">fetch(map, key)</a> </dt> <dd class="summary-synopsis"><p>Fetches the value for a specific <code class="inline">key</code> in the given <code class="inline">map</code>.</p></dd>   <dt class="summary-signature"> <a href="#fetch!/2">fetch!(map, key)</a> </dt> <dd class="summary-synopsis"><p>Fetches the value for a specific <code class="inline">key</code> in the given <code class="inline">map</code>, erroring out if <code class="inline">map</code> doesn't contain <code class="inline">key</code>.</p></dd>   <dt class="summary-signature"> <a href="#from_struct/1">from_struct(struct)</a> </dt> <dd class="summary-synopsis"><p>Converts a <code class="inline">struct</code> to map.</p></dd>   <dt class="summary-signature"> <a href="#get/3">get(map, key, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Gets the value for a specific <code class="inline">key</code> in <code class="inline">map</code>.</p></dd>   <dt class="summary-signature"> <a href="#get_and_update/3">get_and_update(map, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Gets the value from <code class="inline">key</code> and updates it, all in one pass.</p></dd>   <dt class="summary-signature"> <a href="#get_and_update!/3">get_and_update!(map, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Gets the value from <code class="inline">key</code> and updates it. Raises if there is no <code class="inline">key</code>.</p></dd>   <dt class="summary-signature"> <a href="#get_lazy/3">get_lazy(map, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Gets the value for a specific <code class="inline">key</code> in <code class="inline">map</code>.</p></dd>   <dt class="summary-signature"> <a href="#has_key?/2">has_key?(map, key)</a> </dt> <dd class="summary-synopsis"><p>Returns whether the given <code class="inline">key</code> exists in the given <code class="inline">map</code>.</p></dd>   <dt class="summary-signature"> <a href="#keys/1">keys(map)</a> </dt> <dd class="summary-synopsis"><p>Returns all keys from <code class="inline">map</code>.</p></dd>   <dt class="summary-signature"> <a href="#merge/2">merge(map1, map2)</a> </dt> <dd class="summary-synopsis"><p>Merges two maps into one.</p></dd>   <dt class="summary-signature"> <a href="#merge/3">merge(map1, map2, fun)</a> </dt> <dd class="summary-synopsis"><p>Merges two maps into one, resolving conflicts through the given <code class="inline">fun</code>.</p></dd>   <dt class="summary-signature"> <a href="#new/0">new()</a> </dt> <dd class="summary-synopsis"><p>Returns a new empty map.</p></dd>   <dt class="summary-signature"> <a href="#new/1">new(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Creates a map from an <code class="inline">enumerable</code>.</p></dd>   <dt class="summary-signature"> <a href="#new/2">new(enumerable, transform)</a> </dt> <dd class="summary-synopsis"><p>Creates a map from an <code class="inline">enumerable</code> via the given transformation function.</p></dd>   <dt class="summary-signature"> <a href="#pop/3">pop(map, key, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Returns and removes the value associated with <code class="inline">key</code> in <code class="inline">map</code>.</p></dd>   <dt class="summary-signature"> <a href="#pop_lazy/3">pop_lazy(map, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Lazily returns and removes the value associated with <code class="inline">key</code> in <code class="inline">map</code>.</p></dd>   <dt class="summary-signature"> <a href="#put/3">put(map, key, value)</a> </dt> <dd class="summary-synopsis"><p>Puts the given <code class="inline">value</code> under <code class="inline">key</code> in <code class="inline">map</code>.</p></dd>   <dt class="summary-signature"> <a href="#put_new/3">put_new(map, key, value)</a> </dt> <dd class="summary-synopsis"><p>Puts the given <code class="inline">value</code> under <code class="inline">key</code> unless the entry <code class="inline">key</code> already exists in <code class="inline">map</code>.</p></dd>   <dt class="summary-signature"> <a href="#put_new_lazy/3">put_new_lazy(map, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Evaluates <code class="inline">fun</code> and puts the result under <code class="inline">key</code> in <code class="inline">map</code> unless <code class="inline">key</code> is already present.</p></dd>   <dt class="summary-signature"> <a href="#replace!/3">replace!(map, key, value)</a> </dt> <dd class="summary-synopsis"><p>Alters the value stored under <code class="inline">key</code> to <code class="inline">value</code>, but only if the entry <code class="inline">key</code> already exists in <code class="inline">map</code>.</p></dd>   <dt class="summary-signature"> <a href="#split/2">split(map, keys)</a> </dt> <dd class="summary-synopsis"><p>Takes all entries corresponding to the given <code class="inline">keys</code> in <code class="inline">map</code> and extracts them into a separate map.</p></dd>   <dt class="summary-signature"> <a href="#take/2">take(map, keys)</a> </dt> <dd class="summary-synopsis"><p>Returns a new map with all the key-value pairs in <code class="inline">map</code> where the key is in <code class="inline">keys</code>.</p></dd>   <dt class="summary-signature"> <a href="#to_list/1">to_list(map)</a> </dt> <dd class="summary-synopsis"><p>Converts <code class="inline">map</code> to a list.</p></dd>   <dt class="summary-signature"> <a href="#update/4">update(map, key, initial, fun)</a> </dt> <dd class="summary-synopsis"><p>Updates the <code class="inline">key</code> in <code class="inline">map</code> with the given function.</p></dd>   <dt class="summary-signature"> <a href="#update!/3">update!(map, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Updates <code class="inline">key</code> with the given function.</p></dd>   <dt class="summary-signature"> <a href="#values/1">values(map)</a> </dt> <dd class="summary-synopsis"><p>Returns all values from <code class="inline">map</code>.</p></dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:key/0">  <h1 class="signature">key()</h1>     </h3>
<pre data-language="elixir">key() :: any()</pre>     <h3 class="detail-header type" id="t:value/0">  <h1 class="signature">value()</h1>     </h3>
<pre data-language="elixir">value() :: any()</pre>       <h1 class="section-heading" id="functions">  Functions </h1>   <h3 class="detail-header function" id="delete/2">  <h1 class="signature">delete(map, key)</h1>     </h3>
<pre data-language="elixir">delete(map(), key()) :: map()</pre>  <p>Deletes the entry in <code class="inline">map</code> for a specific <code class="inline">key</code>.</p> <p>If the <code class="inline">key</code> does not exist, returns <code class="inline">map</code> unchanged.</p> <p>Inlined by the compiler.</p> <h4 id="delete/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.delete(%{a: 1, b: 2}, :a)
%{b: 2}
iex&gt; Map.delete(%{b: 2}, :a)
%{b: 2}</pre>    <h3 class="detail-header function" id="drop/2">  <h1 class="signature">drop(map, keys)</h1>     </h3>
<pre data-language="elixir">drop(map(), [key()]) :: map()</pre>  <p>Drops the given <code class="inline">keys</code> from <code class="inline">map</code>.</p> <p>If <code class="inline">keys</code> contains keys that are not in <code class="inline">map</code>, they're simply ignored.</p> <h4 id="drop/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.drop(%{a: 1, b: 2, c: 3}, [:b, :d])
%{a: 1, c: 3}</pre>    <h3 class="detail-header function" id="equal?/2">  <h1 class="signature">equal?(map1, map2)</h1>     </h3>
<pre data-language="elixir">equal?(map(), map()) :: boolean()</pre>  <p>Checks if two maps are equal.</p> <p>Two maps are considered to be equal if they contain the same keys and those keys contain the same values.</p> <h4 id="equal?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.equal?(%{a: 1, b: 2}, %{b: 2, a: 1})
true
iex&gt; Map.equal?(%{a: 1, b: 2}, %{b: 1, a: 2})
false</pre>    <h3 class="detail-header function" id="fetch/2">  <h1 class="signature">fetch(map, key)</h1>     </h3>
<pre data-language="elixir">fetch(map(), key()) :: {:ok, value()} | :error</pre>  <p>Fetches the value for a specific <code class="inline">key</code> in the given <code class="inline">map</code>.</p> <p>If <code class="inline">map</code> contains the given <code class="inline">key</code> with value <code class="inline">value</code>, then <code class="inline">{:ok, value}</code> is returned. If <code class="inline">map</code> doesn't contain <code class="inline">key</code>, <code class="inline">:error</code> is returned.</p> <p>Inlined by the compiler.</p> <h4 id="fetch/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.fetch(%{a: 1}, :a)
{:ok, 1}
iex&gt; Map.fetch(%{a: 1}, :b)
:error</pre>    <h3 class="detail-header function" id="fetch!/2">  <h1 class="signature">fetch!(map, key)</h1>     </h3>
<pre data-language="elixir">fetch!(map(), key()) :: value()</pre>  <p>Fetches the value for a specific <code class="inline">key</code> in the given <code class="inline">map</code>, erroring out if <code class="inline">map</code> doesn't contain <code class="inline">key</code>.</p> <p>If <code class="inline">map</code> contains the given <code class="inline">key</code>, the corresponding value is returned. If <code class="inline">map</code> doesn't contain <code class="inline">key</code>, a <a href="../keyerror/"><code class="inline">KeyError</code></a> exception is raised.</p> <p>Inlined by the compiler.</p> <h4 id="fetch!/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.fetch!(%{a: 1}, :a)
1
iex&gt; Map.fetch!(%{a: 1}, :b)
** (KeyError) key :b not found in: %{a: 1}</pre>    <h3 class="detail-header function" id="from_struct/1">  <h1 class="signature">from_struct(struct)</h1>     </h3>
<pre data-language="elixir">from_struct(atom() | struct()) :: map()</pre>  <p>Converts a <code class="inline">struct</code> to map.</p> <p>It accepts the struct module or a struct itself and simply removes the <code class="inline">__struct__</code> field from the given struct or from a new struct generated from the given module.</p> <h4 id="from_struct/1-example" class="section-heading">  Example </h4> <pre data-language="elixir">defmodule User do
  defstruct [:name]
end

Map.from_struct(User)
#=&gt; %{name: nil}

Map.from_struct(%User{name: "john"})
#=&gt; %{name: "john"}</pre>     <h3 class="detail-header function" id="get/3">  <h1 class="signature">get(map, key, default \\ nil)</h1>     </h3>
<pre data-language="elixir">get(map(), key(), value()) :: value()</pre>  <p>Gets the value for a specific <code class="inline">key</code> in <code class="inline">map</code>.</p> <p>If <code class="inline">key</code> is present in <code class="inline">map</code> with value <code class="inline">value</code>, then <code class="inline">value</code> is returned. Otherwise, <code class="inline">default</code> is returned.</p> <p>If <code class="inline">default</code> is not provided, <code class="inline">nil</code> is used.</p> <h4 id="get/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.get(%{}, :a)
nil
iex&gt; Map.get(%{a: 1}, :a)
1
iex&gt; Map.get(%{a: 1}, :b)
nil
iex&gt; Map.get(%{a: 1}, :b, 3)
3</pre>    <h3 class="detail-header function" id="get_and_update/3">  <h1 class="signature">get_and_update(map, key, fun)</h1>     </h3>
<pre data-language="elixir">get_and_update(map(), key(), (value() -&gt; {get, value()} | :pop)) ::
  {get, map()}
when get: term()</pre>  <p>Gets the value from <code class="inline">key</code> and updates it, all in one pass.</p> <p><code class="inline">fun</code> is called with the current value under <code class="inline">key</code> in <code class="inline">map</code> (or <code class="inline">nil</code> if <code class="inline">key</code> is not present in <code class="inline">map</code>) and must return a two-element tuple: the "get" value (the retrieved value, which can be operated on before being returned) and the new value to be stored under <code class="inline">key</code> in the resulting new map. <code class="inline">fun</code> may also return <code class="inline">:pop</code>, which means the current value shall be removed from <code class="inline">map</code> and returned (making this function behave like <code class="inline">Map.pop(map, key)</code>).</p> <p>The returned value is a tuple with the "get" value returned by <code class="inline">fun</code> and a new map with the updated value under <code class="inline">key</code>.</p> <h4 id="get_and_update/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.get_and_update(%{a: 1}, :a, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
{1, %{a: "new value!"}}

iex&gt; Map.get_and_update(%{a: 1}, :b, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
{nil, %{b: "new value!", a: 1}}

iex&gt; Map.get_and_update(%{a: 1}, :a, fn _ -&gt; :pop end)
{1, %{}}

iex&gt; Map.get_and_update(%{a: 1}, :b, fn _ -&gt; :pop end)
{nil, %{a: 1}}</pre>    <h3 class="detail-header function" id="get_and_update!/3">  <h1 class="signature">get_and_update!(map, key, fun)</h1>     </h3>
<pre data-language="elixir">get_and_update!(map(), key(), (value() -&gt; {get, value()} | :pop)) ::
  {get, map()}
when get: term()</pre>  <p>Gets the value from <code class="inline">key</code> and updates it. Raises if there is no <code class="inline">key</code>.</p> <p>Behaves exactly like <a href="#get_and_update/3"><code class="inline">get_and_update/3</code></a>, but raises a <a href="../keyerror/"><code class="inline">KeyError</code></a> exception if <code class="inline">key</code> is not present in <code class="inline">map</code>.</p> <h4 id="get_and_update!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.get_and_update!(%{a: 1}, :a, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
{1, %{a: "new value!"}}

iex&gt; Map.get_and_update!(%{a: 1}, :b, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
** (KeyError) key :b not found in: %{a: 1}

iex&gt; Map.get_and_update!(%{a: 1}, :a, fn _ -&gt;
...&gt;   :pop
...&gt; end)
{1, %{}}</pre>    <h3 class="detail-header function" id="get_lazy/3">  <h1 class="signature">get_lazy(map, key, fun)</h1>     </h3>
<pre data-language="elixir">get_lazy(map(), key(), (() -&gt; value())) :: value()</pre>  <p>Gets the value for a specific <code class="inline">key</code> in <code class="inline">map</code>.</p> <p>If <code class="inline">key</code> is present in <code class="inline">map</code> with value <code class="inline">value</code>, then <code class="inline">value</code> is returned. Otherwise, <code class="inline">fun</code> is evaluated and its result is returned.</p> <p>This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again.</p> <h4 id="get_lazy/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; map = %{a: 1}
iex&gt; fun = fn -&gt;
...&gt;   # some expensive operation here
...&gt;   13
...&gt; end
iex&gt; Map.get_lazy(map, :a, fun)
1
iex&gt; Map.get_lazy(map, :b, fun)
13</pre>    <h3 class="detail-header function" id="has_key?/2">  <h1 class="signature">has_key?(map, key)</h1>     </h3>
<pre data-language="elixir">has_key?(map(), key()) :: boolean()</pre>  <p>Returns whether the given <code class="inline">key</code> exists in the given <code class="inline">map</code>.</p> <p>Inlined by the compiler.</p> <h4 id="has_key?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.has_key?(%{a: 1}, :a)
true
iex&gt; Map.has_key?(%{a: 1}, :b)
false</pre>    <h3 class="detail-header function" id="keys/1">  <h1 class="signature">keys(map)</h1>     </h3>
<pre data-language="elixir">keys(map()) :: [key()]</pre>  <p>Returns all keys from <code class="inline">map</code>.</p> <p>Inlined by the compiler.</p> <h4 id="keys/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.keys(%{a: 1, b: 2})
[:a, :b]</pre>    <h3 class="detail-header function" id="merge/2">  <h1 class="signature">merge(map1, map2)</h1>     </h3>
<pre data-language="elixir">merge(map(), map()) :: map()</pre>  <p>Merges two maps into one.</p> <p>All keys in <code class="inline">map2</code> will be added to <code class="inline">map1</code>, overriding any existing one (i.e., the keys in <code class="inline">map2</code> "have precedence" over the ones in <code class="inline">map1</code>).</p> <p>If you have a struct and you would like to merge a set of keys into the struct, do not use this function, as it would merge all keys on the right side into the struct, even if the key is not part of the struct. Instead, use <a href="../kernel/#struct/2"><code class="inline">Kernel.struct/2</code></a>.</p> <p>Inlined by the compiler.</p> <h4 id="merge/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4})
%{a: 3, b: 2, d: 4}</pre>    <h3 class="detail-header function" id="merge/3">  <h1 class="signature">merge(map1, map2, fun)</h1>     </h3>
<pre data-language="elixir">merge(map(), map(), (key(), value(), value() -&gt; value())) :: map()</pre>  <p>Merges two maps into one, resolving conflicts through the given <code class="inline">fun</code>.</p> <p>All keys in <code class="inline">map2</code> will be added to <code class="inline">map1</code>. The given function will be invoked when there are duplicate keys; its arguments are <code class="inline">key</code> (the duplicate key), <code class="inline">value1</code> (the value of <code class="inline">key</code> in <code class="inline">map1</code>), and <code class="inline">value2</code> (the value of <code class="inline">key</code> in <code class="inline">map2</code>). The value returned by <code class="inline">fun</code> is used as the value under <code class="inline">key</code> in the resulting map.</p> <h4 id="merge/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4}, fn _k, v1, v2 -&gt;
...&gt;   v1 + v2
...&gt; end)
%{a: 4, b: 2, d: 4}</pre>    <h3 class="detail-header function" id="new/0">  <h1 class="signature">new()</h1>     </h3>
<pre data-language="elixir">new() :: map()</pre>  <p>Returns a new empty map.</p> <h4 id="new/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.new()
%{}</pre>    <h3 class="detail-header function" id="new/1">  <h1 class="signature">new(enumerable)</h1>     </h3>
<pre data-language="elixir">new(Enumerable.t()) :: map()</pre>  <p>Creates a map from an <code class="inline">enumerable</code>.</p> <p>Duplicated keys are removed; the latest one prevails.</p> <h4 id="new/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.new([{:b, 1}, {:a, 2}])
%{a: 2, b: 1}
iex&gt; Map.new(a: 1, a: 2, a: 3)
%{a: 3}</pre>    <h3 class="detail-header function" id="new/2">  <h1 class="signature">new(enumerable, transform)</h1>     </h3>
<pre data-language="elixir">new(Enumerable.t(), (term() -&gt; {key(), value()})) :: map()</pre>  <p>Creates a map from an <code class="inline">enumerable</code> via the given transformation function.</p> <p>Duplicated keys are removed; the latest one prevails.</p> <h4 id="new/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.new([:a, :b], fn x -&gt; {x, x} end)
%{a: :a, b: :b}</pre>     <h3 class="detail-header function" id="pop/3">  <h1 class="signature">pop(map, key, default \\ nil)</h1>     </h3>
<pre data-language="elixir">pop(map(), key(), value()) :: {value(), map()}</pre>  <p>Returns and removes the value associated with <code class="inline">key</code> in <code class="inline">map</code>.</p> <p>If <code class="inline">key</code> is present in <code class="inline">map</code> with value <code class="inline">value</code>, <code class="inline">{value, new_map}</code> is returned where <code class="inline">new_map</code> is the result of removing <code class="inline">key</code> from <code class="inline">map</code>. If <code class="inline">key</code> is not present in <code class="inline">map</code>, <code class="inline">{default, map}</code> is returned.</p> <h4 id="pop/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.pop(%{a: 1}, :a)
{1, %{}}
iex&gt; Map.pop(%{a: 1}, :b)
{nil, %{a: 1}}
iex&gt; Map.pop(%{a: 1}, :b, 3)
{3, %{a: 1}}</pre>    <h3 class="detail-header function" id="pop_lazy/3">  <h1 class="signature">pop_lazy(map, key, fun)</h1>     </h3>
<pre data-language="elixir">pop_lazy(map(), key(), (() -&gt; value())) :: {value(), map()}</pre>  <p>Lazily returns and removes the value associated with <code class="inline">key</code> in <code class="inline">map</code>.</p> <p>If <code class="inline">key</code> is present in <code class="inline">map</code> with value <code class="inline">value</code>, <code class="inline">{value, new_map}</code> is returned where <code class="inline">new_map</code> is the result of removing <code class="inline">key</code> from <code class="inline">map</code>. If <code class="inline">key</code> is not present in <code class="inline">map</code>, <code class="inline">{fun_result, map}</code> is returned, where <code class="inline">fun_result</code> is the result of applying <code class="inline">fun</code>.</p> <p>This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again.</p> <h4 id="pop_lazy/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; map = %{a: 1}
iex&gt; fun = fn -&gt;
...&gt;   # some expensive operation here
...&gt;   13
...&gt; end
iex&gt; Map.pop_lazy(map, :a, fun)
{1, %{}}
iex&gt; Map.pop_lazy(map, :b, fun)
{13, %{a: 1}}</pre>    <h3 class="detail-header function" id="put/3">  <h1 class="signature">put(map, key, value)</h1>     </h3>
<pre data-language="elixir">put(map(), key(), value()) :: map()</pre>  <p>Puts the given <code class="inline">value</code> under <code class="inline">key</code> in <code class="inline">map</code>.</p> <p>Inlined by the compiler.</p> <h4 id="put/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.put(%{a: 1}, :b, 2)
%{a: 1, b: 2}
iex&gt; Map.put(%{a: 1, b: 2}, :a, 3)
%{a: 3, b: 2}</pre>    <h3 class="detail-header function" id="put_new/3">  <h1 class="signature">put_new(map, key, value)</h1>     </h3>
<pre data-language="elixir">put_new(map(), key(), value()) :: map()</pre>  <p>Puts the given <code class="inline">value</code> under <code class="inline">key</code> unless the entry <code class="inline">key</code> already exists in <code class="inline">map</code>.</p> <h4 id="put_new/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.put_new(%{a: 1}, :b, 2)
%{a: 1, b: 2}
iex&gt; Map.put_new(%{a: 1, b: 2}, :a, 3)
%{a: 1, b: 2}</pre>    <h3 class="detail-header function" id="put_new_lazy/3">  <h1 class="signature">put_new_lazy(map, key, fun)</h1>     </h3>
<pre data-language="elixir">put_new_lazy(map(), key(), (() -&gt; value())) :: map()</pre>  <p>Evaluates <code class="inline">fun</code> and puts the result under <code class="inline">key</code> in <code class="inline">map</code> unless <code class="inline">key</code> is already present.</p> <p>This function is useful in case you want to compute the value to put under <code class="inline">key</code> only if <code class="inline">key</code> is not already present (e.g., the value is expensive to calculate or generally difficult to setup and teardown again).</p> <h4 id="put_new_lazy/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; map = %{a: 1}
iex&gt; fun = fn -&gt;
...&gt;   # some expensive operation here
...&gt;   3
...&gt; end
iex&gt; Map.put_new_lazy(map, :a, fun)
%{a: 1}
iex&gt; Map.put_new_lazy(map, :b, fun)
%{a: 1, b: 3}</pre>    <h3 class="detail-header function" id="replace!/3">  <h1 class="signature">replace!(map, key, value)</h1>  <span class="note">(since 1.5.0)</span>    </h3>
<pre data-language="elixir">replace!(map(), key(), value()) :: map()</pre>  <p>Alters the value stored under <code class="inline">key</code> to <code class="inline">value</code>, but only if the entry <code class="inline">key</code> already exists in <code class="inline">map</code>.</p> <p>If <code class="inline">key</code> is not present in <code class="inline">map</code>, a <a href="../keyerror/"><code class="inline">KeyError</code></a> exception is raised.</p> <p>Inlined by the compiler.</p> <h4 id="replace!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.replace!(%{a: 1, b: 2}, :a, 3)
%{a: 3, b: 2}

iex&gt; Map.replace!(%{a: 1}, :b, 2)
** (KeyError) key :b not found in: %{a: 1}</pre>    <h3 class="detail-header function" id="split/2">  <h1 class="signature">split(map, keys)</h1>     </h3>
<pre data-language="elixir">split(map(), [key()]) :: {map(), map()}</pre>  <p>Takes all entries corresponding to the given <code class="inline">keys</code> in <code class="inline">map</code> and extracts them into a separate map.</p> <p>Returns a tuple with the new map and the old map with removed keys.</p> <p>Keys for which there are no entries in <code class="inline">map</code> are ignored.</p> <h4 id="split/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.split(%{a: 1, b: 2, c: 3}, [:a, :c, :e])
{%{a: 1, c: 3}, %{b: 2}}</pre>    <h3 class="detail-header function" id="take/2">  <h1 class="signature">take(map, keys)</h1>     </h3>
<pre data-language="elixir">take(map(), [key()]) :: map()</pre>  <p>Returns a new map with all the key-value pairs in <code class="inline">map</code> where the key is in <code class="inline">keys</code>.</p> <p>If <code class="inline">keys</code> contains keys that are not in <code class="inline">map</code>, they're simply ignored.</p> <h4 id="take/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.take(%{a: 1, b: 2, c: 3}, [:a, :c, :e])
%{a: 1, c: 3}</pre>    <h3 class="detail-header function" id="to_list/1">  <h1 class="signature">to_list(map)</h1>     </h3>
<pre data-language="elixir">to_list(map()) :: [{term(), term()}]</pre>  <p>Converts <code class="inline">map</code> to a list.</p> <p>Each key-value pair in the map is converted to a two-element tuple <code class="inline">{key, value}</code> in the resulting list.</p> <p>Inlined by the compiler.</p> <h4 id="to_list/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.to_list(%{a: 1})
[a: 1]
iex&gt; Map.to_list(%{1 =&gt; 2})
[{1, 2}]</pre>    <h3 class="detail-header function" id="update/4">  <h1 class="signature">update(map, key, initial, fun)</h1>     </h3>
<pre data-language="elixir">update(map(), key(), value(), (value() -&gt; value())) :: map()</pre>  <p>Updates the <code class="inline">key</code> in <code class="inline">map</code> with the given function.</p> <p>If <code class="inline">key</code> is present in <code class="inline">map</code> with value <code class="inline">value</code>, <code class="inline">fun</code> is invoked with argument <code class="inline">value</code> and its result is used as the new value of <code class="inline">key</code>. If <code class="inline">key</code> is not present in <code class="inline">map</code>, <code class="inline">initial</code> is inserted as the value of <code class="inline">key</code>. The initial value will not be passed through the update function.</p> <h4 id="update/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.update(%{a: 1}, :a, 13, &amp;(&amp;1 * 2))
%{a: 2}
iex&gt; Map.update(%{a: 1}, :b, 11, &amp;(&amp;1 * 2))
%{a: 1, b: 11}</pre>    <h3 class="detail-header function" id="update!/3">  <h1 class="signature">update!(map, key, fun)</h1>     </h3>
<pre data-language="elixir">update!(map(), key(), (value() -&gt; value())) :: map()</pre>  <p>Updates <code class="inline">key</code> with the given function.</p> <p>If <code class="inline">key</code> is present in <code class="inline">map</code> with value <code class="inline">value</code>, <code class="inline">fun</code> is invoked with argument <code class="inline">value</code> and its result is used as the new value of <code class="inline">key</code>. If <code class="inline">key</code> is not present in <code class="inline">map</code>, a <a href="../keyerror/"><code class="inline">KeyError</code></a> exception is raised.</p> <h4 id="update!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.update!(%{a: 1}, :a, &amp;(&amp;1 * 2))
%{a: 2}

iex&gt; Map.update!(%{a: 1}, :b, &amp;(&amp;1 * 2))
** (KeyError) key :b not found in: %{a: 1}</pre>    <h3 class="detail-header function" id="values/1">  <h1 class="signature">values(map)</h1>     </h3>
<pre data-language="elixir">values(map()) :: [value()]</pre>  <p>Returns all values from <code class="inline">map</code>.</p> <p>Inlined by the compiler.</p> <h4 id="values/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Map.values(%{a: 1, b: 2})
[1, 2]</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.9.1/Map.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.9.1/Map.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
