
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Enum - Elixir 1.9 - W3cubDocs</title>
  
  <meta name="description" content=" Provides a set of algorithms to work with enumerables. ">
  <meta name="keywords" content="enum, summary, types, acc, default, element, index, t, functions, all, enumerable, fun, fn, x, -, end, any, at, nil, chunk, every, count, step, leftover, while, after, concat, enumerables, left, right, dedup, drop, amount, nth, each, empty, fetch, fetch!, filter, find, value, flat, map, reduce, group, key, intersperse, into, collectable, transform, join, joiner, mapper, max, fallback, raise, emptyerror, member, min, random, reject, reverse, tail, slice, start, scan, shuffle, range, sort, sorter, &#38;, split, with, sum, take, list, uniq, unzip, offset, zip, elixir, elixir~1.9">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.9/enum/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/elixir~1.9.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.9/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.9</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1>  Enum  </h1>  <p>Provides a set of algorithms to work with enumerables.</p> <p>In Elixir, an enumerable is any data type that implements the <a href="../enumerable/"><code class="inline">Enumerable</code></a> protocol. <a href="../list/"><code class="inline">List</code></a>s (<code class="inline">[1, 2, 3]</code>), <a href="../map/"><code class="inline">Map</code></a>s (<code class="inline">%{foo: 1, bar: 2}</code>) and <a href="../range/"><code class="inline">Range</code></a>s (<code class="inline">1..3</code>) are common data types used as enumerables:</p> <pre data-language="elixir">iex&gt; Enum.map([1, 2, 3], fn x -&gt; x * 2 end)
[2, 4, 6]

iex&gt; Enum.sum([1, 2, 3])
6

iex&gt; Enum.map(1..3, fn x -&gt; x * 2 end)
[2, 4, 6]

iex&gt; Enum.sum(1..3)
6

iex&gt; map = %{"a" =&gt; 1, "b" =&gt; 2}
iex&gt; Enum.map(map, fn {k, v} -&gt; {k, v * 2} end)
[{"a", 2}, {"b", 4}]</pre> <p>However, many other enumerables exist in the language, such as <a href="../mapset/"><code class="inline">MapSet</code></a>s and the data type returned by <a href="../file/#stream!/3"><code class="inline">File.stream!/3</code></a> which allows a file to be traversed as if it was an enumerable.</p> <p>The functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the enumerable. This is expected on operations such as <a href="../enum/#map/2"><code class="inline">Enum.map/2</code></a>. After all, if we want to traverse every element on a list, the longer the list, the more elements we need to traverse, and the longer it will take.</p> <p>This linear behaviour should also be expected on operations like <a href="#count/1"><code class="inline">count/1</code></a>, <a href="#member?/2"><code class="inline">member?/2</code></a>, <a href="#at/2"><code class="inline">at/2</code></a> and similar. While Elixir does allow data types to provide performant variants for such operations, you should not expect it to always be available, since the <a href="#content"><code class="inline">Enum</code></a> module is meant to work with a large variety of data types and not all data types can provide optimized behaviour.</p> <p>Finally, note the functions in the <a href="#content"><code class="inline">Enum</code></a> module are eager: they will traverse the enumerable as soon as they are invoked. This is particularly dangerous when working with infinite enumerables. In such cases, you should use the <a href="../stream/"><code class="inline">Stream</code></a> module, which allows you to lazily express computations, without traversing collections, and work with possibly infinite collections. See the <a href="../stream/"><code class="inline">Stream</code></a> module for examples and documentation.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:acc/0">acc()</a> </dt>   <dt class="summary-signature"> <a href="#t:default/0">default()</a> </dt>   <dt class="summary-signature"> <a href="#t:element/0">element()</a> </dt>   <dt class="summary-signature"> <a href="#t:index/0">index()</a> </dt> <dd class="summary-synopsis"><p>Zero-based index. It can also be a negative integer.</p></dd>   <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#all?/2">all?(enumerable, fun \\ fn x -&gt; x end)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">fun.(element)</code> is truthy for all elements in <code class="inline">enumerable</code>.</p></dd>   <dt class="summary-signature"> <a href="#any?/2">any?(enumerable, fun \\ fn x -&gt; x end)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">fun.(element)</code> is truthy for at least one element in <code class="inline">enumerable</code>.</p></dd>   <dt class="summary-signature"> <a href="#at/3">at(enumerable, index, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Finds the element at the given <code class="inline">index</code> (zero-based).</p></dd>   <dt class="summary-signature"> <a href="#chunk_by/2">chunk_by(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Splits enumerable on every element for which <code class="inline">fun</code> returns a new value.</p></dd>   <dt class="summary-signature"> <a href="#chunk_every/2">chunk_every(enumerable, count)</a> </dt> <dd class="summary-synopsis"><p>Shortcut to <code class="inline">chunk_every(enumerable, count, count)</code>.</p></dd>   <dt class="summary-signature"> <a href="#chunk_every/4">chunk_every(enumerable, count, step, leftover \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns list of lists containing <code class="inline">count</code> elements each, where each new chunk starts <code class="inline">step</code> elements into the <code class="inline">enumerable</code>.</p></dd>   <dt class="summary-signature"> <a href="#chunk_while/4">chunk_while(enumerable, acc, chunk_fun, after_fun)</a> </dt> <dd class="summary-synopsis"><p>Chunks the <code class="inline">enumerable</code> with fine grained control when every chunk is emitted.</p></dd>   <dt class="summary-signature"> <a href="#concat/1">concat(enumerables)</a> </dt> <dd class="summary-synopsis"><p>Given an enumerable of enumerables, concatenates the <code class="inline">enumerables</code> into a single list.</p></dd>   <dt class="summary-signature"> <a href="#concat/2">concat(left, right)</a> </dt> <dd class="summary-synopsis"><p>Concatenates the enumerable on the <code class="inline">right</code> with the enumerable on the <code class="inline">left</code>.</p></dd>   <dt class="summary-signature"> <a href="#count/1">count(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns the size of the <code class="inline">enumerable</code>.</p></dd>   <dt class="summary-signature"> <a href="#count/2">count(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns the count of elements in the <code class="inline">enumerable</code> for which <code class="inline">fun</code> returns a truthy value.</p></dd>   <dt class="summary-signature"> <a href="#dedup/1">dedup(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Enumerates the <code class="inline">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element.</p></dd>   <dt class="summary-signature"> <a href="#dedup_by/2">dedup_by(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Enumerates the <code class="inline">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element.</p></dd>   <dt class="summary-signature"> <a href="#drop/2">drop(enumerable, amount)</a> </dt> <dd class="summary-synopsis"><p>Drops the <code class="inline">amount</code> of elements from the <code class="inline">enumerable</code>.</p></dd>   <dt class="summary-signature"> <a href="#drop_every/2">drop_every(enumerable, nth)</a> </dt> <dd class="summary-synopsis"><p>Returns a list of every <code class="inline">nth</code> element in the <code class="inline">enumerable</code> dropped, starting with the first element.</p></dd>   <dt class="summary-signature"> <a href="#drop_while/2">drop_while(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Drops elements at the beginning of the <code class="inline">enumerable</code> while <code class="inline">fun</code> returns a truthy value.</p></dd>   <dt class="summary-signature"> <a href="#each/2">each(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Invokes the given <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code>.</p></dd>   <dt class="summary-signature"> <a href="#empty?/1">empty?(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Determines if the <code class="inline">enumerable</code> is empty.</p></dd>   <dt class="summary-signature"> <a href="#fetch/2">fetch(enumerable, index)</a> </dt> <dd class="summary-synopsis"><p>Finds the element at the given <code class="inline">index</code> (zero-based).</p></dd>   <dt class="summary-signature"> <a href="#fetch!/2">fetch!(enumerable, index)</a> </dt> <dd class="summary-synopsis"><p>Finds the element at the given <code class="inline">index</code> (zero-based).</p></dd>   <dt class="summary-signature"> <a href="#filter/2">filter(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Filters the <code class="inline">enumerable</code>, i.e. returns only those elements for which <code class="inline">fun</code> returns a truthy value.</p></dd>   <dt class="summary-signature"> <a href="#find/3">find(enumerable, default \\ nil, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns the first element for which <code class="inline">fun</code> returns a truthy value. If no such element is found, returns <code class="inline">default</code>.</p></dd>   <dt class="summary-signature"> <a href="#find_index/2">find_index(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#find/3"><code class="inline">find/3</code></a>, but returns the index (zero-based) of the element instead of the element itself.</p></dd>   <dt class="summary-signature"> <a href="#find_value/3">find_value(enumerable, default \\ nil, fun)</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#find/3"><code class="inline">find/3</code></a>, but returns the value of the function invocation instead of the element itself.</p></dd>   <dt class="summary-signature"> <a href="#flat_map/2">flat_map(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Maps the given <code class="inline">fun</code> over <code class="inline">enumerable</code> and flattens the result.</p></dd>   <dt class="summary-signature"> <a href="#flat_map_reduce/3">flat_map_reduce(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Maps and reduces an <code class="inline">enumerable</code>, flattening the given results (only one level deep).</p></dd>   <dt class="summary-signature"> <a href="#group_by/3">group_by(enumerable, key_fun, value_fun \\ fn x -&gt; x end)</a> </dt> <dd class="summary-synopsis"><p>Splits the <code class="inline">enumerable</code> into groups based on <code class="inline">key_fun</code>.</p></dd>   <dt class="summary-signature"> <a href="#intersperse/2">intersperse(enumerable, element)</a> </dt> <dd class="summary-synopsis"><p>Intersperses <code class="inline">element</code> between each element of the enumeration.</p></dd>   <dt class="summary-signature"> <a href="#into/2">into(enumerable, collectable)</a> </dt> <dd class="summary-synopsis"><p>Inserts the given <code class="inline">enumerable</code> into a <code class="inline">collectable</code>.</p></dd>   <dt class="summary-signature"> <a href="#into/3">into(enumerable, collectable, transform)</a> </dt> <dd class="summary-synopsis"><p>Inserts the given <code class="inline">enumerable</code> into a <code class="inline">collectable</code> according to the transformation function.</p></dd>   <dt class="summary-signature"> <a href="#join/2">join(enumerable, joiner \\ "")</a> </dt> <dd class="summary-synopsis"><p>Joins the given <code class="inline">enumerable</code> into a binary using <code class="inline">joiner</code> as a separator.</p></dd>   <dt class="summary-signature"> <a href="#map/2">map(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns a list where each element is the result of invoking <code class="inline">fun</code> on each corresponding element of <code class="inline">enumerable</code>.</p></dd>   <dt class="summary-signature"> <a href="#map_every/3">map_every(enumerable, nth, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns a list of results of invoking <code class="inline">fun</code> on every <code class="inline">nth</code> element of <code class="inline">enumerable</code>, starting with the first element.</p></dd>   <dt class="summary-signature"> <a href="#map_join/3">map_join(enumerable, joiner \\ "", mapper)</a> </dt> <dd class="summary-synopsis"><p>Maps and joins the given <code class="inline">enumerable</code> in one pass.</p></dd>   <dt class="summary-signature"> <a href="#map_reduce/3">map_reduce(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Invokes the given function to each element in the <code class="inline">enumerable</code> to reduce it to a single element, while keeping an accumulator.</p></dd>   <dt class="summary-signature"> <a href="#max/2">max(enumerable, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</a> </dt> <dd class="summary-synopsis"><p>Returns the maximal element in the <code class="inline">enumerable</code> according to Erlang's term ordering.</p></dd>   <dt class="summary-signature"> <a href="#max_by/3">max_by(enumerable, fun, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</a> </dt> <dd class="summary-synopsis"><p>Returns the maximal element in the <code class="inline">enumerable</code> as calculated by the given function.</p></dd>   <dt class="summary-signature"> <a href="#member?/2">member?(enumerable, element)</a> </dt> <dd class="summary-synopsis"><p>Checks if <code class="inline">element</code> exists within the <code class="inline">enumerable</code>.</p></dd>   <dt class="summary-signature"> <a href="#min/2">min(enumerable, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</a> </dt> <dd class="summary-synopsis"><p>Returns the minimal element in the <code class="inline">enumerable</code> according to Erlang's term ordering.</p></dd>   <dt class="summary-signature"> <a href="#min_by/3">min_by(enumerable, fun, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</a> </dt> <dd class="summary-synopsis"><p>Returns the minimal element in the <code class="inline">enumerable</code> as calculated by the given function.</p></dd>   <dt class="summary-signature"> <a href="#min_max/2">min_max(enumerable, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</a> </dt> <dd class="summary-synopsis"><p>Returns a tuple with the minimal and the maximal elements in the enumerable according to Erlang's term ordering.</p></dd>   <dt class="summary-signature"> <a href="#min_max_by/3">min_max_by(enumerable, fun, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</a> </dt> <dd class="summary-synopsis"><p>Returns a tuple with the minimal and the maximal elements in the enumerable as calculated by the given function.</p></dd>   <dt class="summary-signature"> <a href="#random/1">random(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns a random element of an <code class="inline">enumerable</code>.</p></dd>   <dt class="summary-signature"> <a href="#reduce/2">reduce(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Invokes <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code> with the accumulator.</p></dd>   <dt class="summary-signature"> <a href="#reduce/3">reduce(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Invokes <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code> with the accumulator.</p></dd>   <dt class="summary-signature"> <a href="#reduce_while/3">reduce_while(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Reduces <code class="inline">enumerable</code> until <code class="inline">fun</code> returns <code class="inline">{:halt, term}</code>.</p></dd>   <dt class="summary-signature"> <a href="#reject/2">reject(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns a list of elements in <code class="inline">enumerable</code> excluding those for which the function <code class="inline">fun</code> returns a truthy value.</p></dd>   <dt class="summary-signature"> <a href="#reverse/1">reverse(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns a list of elements in <code class="inline">enumerable</code> in reverse order.</p></dd>   <dt class="summary-signature"> <a href="#reverse/2">reverse(enumerable, tail)</a> </dt> <dd class="summary-synopsis"><p>Reverses the elements in <code class="inline">enumerable</code>, appends the <code class="inline">tail</code>, and returns it as a list.</p></dd>   <dt class="summary-signature"> <a href="#reverse_slice/3">reverse_slice(enumerable, start_index, count)</a> </dt> <dd class="summary-synopsis"><p>Reverses the <code class="inline">enumerable</code> in the range from initial <code class="inline">start_index</code> through <code class="inline">count</code> elements.</p></dd>   <dt class="summary-signature"> <a href="#scan/2">scan(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Applies the given function to each element in the <code class="inline">enumerable</code>, storing the result in a list and passing it as the accumulator for the next computation. Uses the first element in the <code class="inline">enumerable</code> as the starting value.</p></dd>   <dt class="summary-signature"> <a href="#scan/3">scan(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Applies the given function to each element in the <code class="inline">enumerable</code>, storing the result in a list and passing it as the accumulator for the next computation. Uses the given <code class="inline">acc</code> as the starting value.</p></dd>   <dt class="summary-signature"> <a href="#shuffle/1">shuffle(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns a list with the elements of <code class="inline">enumerable</code> shuffled.</p></dd>   <dt class="summary-signature"> <a href="#slice/2">slice(enumerable, index_range)</a> </dt> <dd class="summary-synopsis"><p>Returns a subset list of the given <code class="inline">enumerable</code> by <code class="inline">index_range</code>.</p></dd>   <dt class="summary-signature"> <a href="#slice/3">slice(enumerable, start_index, amount)</a> </dt> <dd class="summary-synopsis"><p>Returns a subset list of the given <code class="inline">enumerable</code>, from <code class="inline">start_index</code> (zero-based) with <code class="inline">amount</code> number of elements if available.</p></dd>   <dt class="summary-signature"> <a href="#sort/1">sort(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Sorts the <code class="inline">enumerable</code> according to Erlang's term ordering.</p></dd>   <dt class="summary-signature"> <a href="#sort/2">sort(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Sorts the <code class="inline">enumerable</code> by the given function.</p></dd>   <dt class="summary-signature"> <a href="#sort_by/3">sort_by(enumerable, mapper, sorter \\ &amp;&lt;=/2)</a> </dt> <dd class="summary-synopsis"><p>Sorts the mapped results of the <code class="inline">enumerable</code> according to the provided <code class="inline">sorter</code> function.</p></dd>   <dt class="summary-signature"> <a href="#split/2">split(enumerable, count)</a> </dt> <dd class="summary-synopsis"><p>Splits the <code class="inline">enumerable</code> into two enumerables, leaving <code class="inline">count</code> elements in the first one.</p></dd>   <dt class="summary-signature"> <a href="#split_while/2">split_while(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Splits enumerable in two at the position of the element for which <code class="inline">fun</code> returns a falsy value (<code class="inline">false</code> or <code class="inline">nil</code>) for the first time.</p></dd>   <dt class="summary-signature"> <a href="#split_with/2">split_with(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Splits the <code class="inline">enumerable</code> in two lists according to the given function <code class="inline">fun</code>.</p></dd>   <dt class="summary-signature"> <a href="#sum/1">sum(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns the sum of all elements.</p></dd>   <dt class="summary-signature"> <a href="#take/2">take(enumerable, amount)</a> </dt> <dd class="summary-synopsis"><p>Takes an <code class="inline">amount</code> of elements from the beginning or the end of the <code class="inline">enumerable</code>.</p></dd>   <dt class="summary-signature"> <a href="#take_every/2">take_every(enumerable, nth)</a> </dt> <dd class="summary-synopsis"><p>Returns a list of every <code class="inline">nth</code> element in the <code class="inline">enumerable</code>, starting with the first element.</p></dd>   <dt class="summary-signature"> <a href="#take_random/2">take_random(enumerable, count)</a> </dt> <dd class="summary-synopsis"><p>Takes <code class="inline">count</code> random elements from <code class="inline">enumerable</code>.</p></dd>   <dt class="summary-signature"> <a href="#take_while/2">take_while(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Takes the elements from the beginning of the <code class="inline">enumerable</code> while <code class="inline">fun</code> returns a truthy value.</p></dd>   <dt class="summary-signature"> <a href="#to_list/1">to_list(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Converts <code class="inline">enumerable</code> to a list.</p></dd>   <dt class="summary-signature"> <a href="#uniq/1">uniq(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Enumerates the <code class="inline">enumerable</code>, removing all duplicated elements.</p></dd>   <dt class="summary-signature"> <a href="#uniq_by/2">uniq_by(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Enumerates the <code class="inline">enumerable</code>, by removing the elements for which function <code class="inline">fun</code> returned duplicate elements.</p></dd>   <dt class="summary-signature"> <a href="#unzip/1">unzip(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Opposite of <a href="#zip/2"><code class="inline">zip/2</code></a>. Extracts two-element tuples from the given <code class="inline">enumerable</code> and groups them together.</p></dd>   <dt class="summary-signature"> <a href="#with_index/2">with_index(enumerable, offset \\ 0)</a> </dt> <dd class="summary-synopsis"><p>Returns the <code class="inline">enumerable</code> with each element wrapped in a tuple alongside its index.</p></dd>   <dt class="summary-signature"> <a href="#zip/1">zip(enumerables)</a> </dt> <dd class="summary-synopsis"><p>Zips corresponding elements from a finite collection of enumerables into one list of tuples.</p></dd>   <dt class="summary-signature"> <a href="#zip/2">zip(enumerable1, enumerable2)</a> </dt> <dd class="summary-synopsis"><p>Zips corresponding elements from two enumerables into one list of tuples.</p></dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:acc/0">  <h1 class="signature">acc()</h1>     </h3>
<pre data-language="elixir">acc() :: any()</pre>     <h3 class="detail-header type" id="t:default/0">  <h1 class="signature">default()</h1>     </h3>
<pre data-language="elixir">default() :: any()</pre>     <h3 class="detail-header type" id="t:element/0">  <h1 class="signature">element()</h1>     </h3>
<pre data-language="elixir">element() :: any()</pre>     <h3 class="detail-header type" id="t:index/0">  <h1 class="signature">index()</h1>     </h3>
<pre data-language="elixir">index() :: integer()</pre>  <p>Zero-based index. It can also be a negative integer.</p>    <h3 class="detail-header type" id="t:t/0">  <h1 class="signature">t()</h1>     </h3>
<pre data-language="elixir">t() :: Enumerable.t()</pre>       <h1 class="section-heading" id="functions">  Functions </h1>    <h3 class="detail-header function" id="all?/2">  <h1 class="signature">all?(enumerable, fun \\ fn x -&gt; x end)</h1>     </h3>
<pre data-language="elixir">all?(t(), (element() -&gt; as_boolean(term()))) :: boolean()</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">fun.(element)</code> is truthy for all elements in <code class="inline">enumerable</code>.</p> <p>Iterates over the <code class="inline">enumerable</code> and invokes <code class="inline">fun</code> on each element. When an invocation of <code class="inline">fun</code> returns a falsy value (<code class="inline">false</code> or <code class="inline">nil</code>) iteration stops immediately and <code class="inline">false</code> is returned. In all other cases <code class="inline">true</code> is returned.</p> <h4 id="all?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.all?([2, 4, 6], fn x -&gt; rem(x, 2) == 0 end)
true

iex&gt; Enum.all?([2, 3, 4], fn x -&gt; rem(x, 2) == 0 end)
false

iex&gt; Enum.all?([], fn x -&gt; x &gt; 0 end)
true</pre> <p>If no function is given, the truthiness of each element is checked during iteration. When an element has a falsy value (<code class="inline">false</code> or <code class="inline">nil</code>) iteration stops immediately and <code class="inline">false</code> is returned. In all other cases <code class="inline">true</code> is returned.</p> <pre data-language="elixir">iex&gt; Enum.all?([1, 2, 3])
true

iex&gt; Enum.all?([1, nil, 3])
false

iex&gt; Enum.all?([])
true</pre>     <h3 class="detail-header function" id="any?/2">  <h1 class="signature">any?(enumerable, fun \\ fn x -&gt; x end)</h1>     </h3>
<pre data-language="elixir">any?(t(), (element() -&gt; as_boolean(term()))) :: boolean()</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">fun.(element)</code> is truthy for at least one element in <code class="inline">enumerable</code>.</p> <p>Iterates over the <code class="inline">enumerable</code> and invokes <code class="inline">fun</code> on each element. When an invocation of <code class="inline">fun</code> returns a truthy value (neither <code class="inline">false</code> nor <code class="inline">nil</code>) iteration stops immediately and <code class="inline">true</code> is returned. In all other cases <code class="inline">false</code> is returned.</p> <h4 id="any?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.any?([2, 4, 6], fn x -&gt; rem(x, 2) == 1 end)
false

iex&gt; Enum.any?([2, 3, 4], fn x -&gt; rem(x, 2) == 1 end)
true

iex&gt; Enum.any?([], fn x -&gt; x &gt; 0 end)
false</pre> <p>If no function is given, the truthiness of each element is checked during iteration. When an element has a truthy value (neither <code class="inline">false</code> nor <code class="inline">nil</code>) iteration stops immediately and <code class="inline">true</code> is returned. In all other cases <code class="inline">false</code> is returned.</p> <pre data-language="elixir">iex&gt; Enum.any?([false, false, false])
false

iex&gt; Enum.any?([false, true, false])
true

iex&gt; Enum.any?([])
false</pre>     <h3 class="detail-header function" id="at/3">  <h1 class="signature">at(enumerable, index, default \\ nil)</h1>     </h3>
<pre data-language="elixir">at(t(), index(), default()) :: element() | default()</pre>  <p>Finds the element at the given <code class="inline">index</code> (zero-based).</p> <p>Returns <code class="inline">default</code> if <code class="inline">index</code> is out of bounds.</p> <p>A negative <code class="inline">index</code> can be passed, which means the <code class="inline">enumerable</code> is enumerated once and the <code class="inline">index</code> is counted from the end (for example, <code class="inline">-1</code> finds the last element).</p> <h4 id="at/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.at([2, 4, 6], 0)
2

iex&gt; Enum.at([2, 4, 6], 2)
6

iex&gt; Enum.at([2, 4, 6], 4)
nil

iex&gt; Enum.at([2, 4, 6], 4, :none)
:none</pre>    <h3 class="detail-header function" id="chunk_by/2">  <h1 class="signature">chunk_by(enumerable, fun)</h1>     </h3>
<pre data-language="elixir">chunk_by(t(), (element() -&gt; any())) :: [list()]</pre>  <p>Splits enumerable on every element for which <code class="inline">fun</code> returns a new value.</p> <p>Returns a list of lists.</p> <h4 id="chunk_by/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &amp;(rem(&amp;1, 2) == 1))
[[1], [2, 2], [3], [4, 4, 6], [7, 7]]</pre>    <h3 class="detail-header function" id="chunk_every/2">  <h1 class="signature">chunk_every(enumerable, count)</h1>  <span class="note">(since 1.5.0)</span>    </h3>
<pre data-language="elixir">chunk_every(t(), pos_integer()) :: [list()]</pre>  <p>Shortcut to <code class="inline">chunk_every(enumerable, count, count)</code>.</p>     <h3 class="detail-header function" id="chunk_every/4">  <h1 class="signature">chunk_every(enumerable, count, step, leftover \\ [])</h1>  <span class="note">(since 1.5.0)</span>    </h3>
<pre data-language="elixir">chunk_every(t(), pos_integer(), pos_integer(), t() | :discard) :: [list()]</pre>  <p>Returns list of lists containing <code class="inline">count</code> elements each, where each new chunk starts <code class="inline">step</code> elements into the <code class="inline">enumerable</code>.</p> <p><code class="inline">step</code> is optional and, if not passed, defaults to <code class="inline">count</code>, i.e. chunks do not overlap.</p> <p>If the last chunk does not have <code class="inline">count</code> elements to fill the chunk, elements are taken from <code class="inline">leftover</code> to fill in the chunk. If <code class="inline">leftover</code> does not have enough elements to fill the chunk, then a partial chunk is returned with less than <code class="inline">count</code> elements.</p> <p>If <code class="inline">:discard</code> is given in <code class="inline">leftover</code>, the last chunk is discarded unless it has exactly <code class="inline">count</code> elements.</p> <h4 id="chunk_every/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.chunk_every([1, 2, 3, 4, 5, 6], 2)
[[1, 2], [3, 4], [5, 6]]

iex&gt; Enum.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, :discard)
[[1, 2, 3], [3, 4, 5]]

iex&gt; Enum.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, [7])
[[1, 2, 3], [3, 4, 5], [5, 6, 7]]

iex&gt; Enum.chunk_every([1, 2, 3, 4], 3, 3, [])
[[1, 2, 3], [4]]

iex&gt; Enum.chunk_every([1, 2, 3, 4], 10)
[[1, 2, 3, 4]]

iex&gt; Enum.chunk_every([1, 2, 3, 4, 5], 2, 3, [])
[[1, 2], [4, 5]]</pre>    <h3 class="detail-header function" id="chunk_while/4">  <h1 class="signature">chunk_while(enumerable, acc, chunk_fun, after_fun)</h1>  <span class="note">(since 1.5.0)</span>    </h3>
<pre data-language="elixir">chunk_while(
  t(),
  acc(),
  (element(), acc() -&gt;
     {:cont, chunk, acc()} | {:cont, acc()} | {:halt, acc()}),
  (acc() -&gt; {:cont, chunk, acc()} | {:cont, acc()})
) :: Enumerable.t()
when chunk: any()</pre>  <p>Chunks the <code class="inline">enumerable</code> with fine grained control when every chunk is emitted.</p> <p><code class="inline">chunk_fun</code> receives the current element and the accumulator and must return <code class="inline">{:cont, element, acc}</code> to emit the given chunk and continue with accumulator or <code class="inline">{:cont, acc}</code> to not emit any chunk and continue with the return accumulator.</p> <p><code class="inline">after_fun</code> is invoked when iteration is done and must also return <code class="inline">{:cont, element, acc}</code> or <code class="inline">{:cont, acc}</code>.</p> <p>Returns a list of lists.</p> <h4 id="chunk_while/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; chunk_fun = fn element, acc -&gt;
...&gt;   if rem(element, 2) == 0 do
...&gt;     {:cont, Enum.reverse([element | acc]), []}
...&gt;   else
...&gt;     {:cont, [element | acc]}
...&gt;   end
...&gt; end
iex&gt; after_fun = fn
...&gt;   [] -&gt; {:cont, []}
...&gt;   acc -&gt; {:cont, Enum.reverse(acc), []}
...&gt; end
iex&gt; Enum.chunk_while(1..10, [], chunk_fun, after_fun)
[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]</pre>    <h3 class="detail-header function" id="concat/1">  <h1 class="signature">concat(enumerables)</h1>     </h3>
<pre data-language="elixir">concat(t()) :: t()</pre>  <p>Given an enumerable of enumerables, concatenates the <code class="inline">enumerables</code> into a single list.</p> <h4 id="concat/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.concat([1..3, 4..6, 7..9])
[1, 2, 3, 4, 5, 6, 7, 8, 9]

iex&gt; Enum.concat([[1, [2], 3], [4], [5, 6]])
[1, [2], 3, 4, 5, 6]</pre>    <h3 class="detail-header function" id="concat/2">  <h1 class="signature">concat(left, right)</h1>     </h3>
<pre data-language="elixir">concat(t(), t()) :: t()</pre>  <p>Concatenates the enumerable on the <code class="inline">right</code> with the enumerable on the <code class="inline">left</code>.</p> <p>This function produces the same result as the <a href="../kernel/#++/2"><code class="inline">Kernel.++/2</code></a> operator for lists.</p> <h4 id="concat/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.concat(1..3, 4..6)
[1, 2, 3, 4, 5, 6]

iex&gt; Enum.concat([1, 2, 3], [4, 5, 6])
[1, 2, 3, 4, 5, 6]</pre>    <h3 class="detail-header function" id="count/1">  <h1 class="signature">count(enumerable)</h1>     </h3>
<pre data-language="elixir">count(t()) :: non_neg_integer()</pre>  <p>Returns the size of the <code class="inline">enumerable</code>.</p> <h4 id="count/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.count([1, 2, 3])
3</pre>    <h3 class="detail-header function" id="count/2">  <h1 class="signature">count(enumerable, fun)</h1>     </h3>
<pre data-language="elixir">count(t(), (element() -&gt; as_boolean(term()))) :: non_neg_integer()</pre>  <p>Returns the count of elements in the <code class="inline">enumerable</code> for which <code class="inline">fun</code> returns a truthy value.</p> <h4 id="count/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.count([1, 2, 3, 4, 5], fn x -&gt; rem(x, 2) == 0 end)
2</pre>    <h3 class="detail-header function" id="dedup/1">  <h1 class="signature">dedup(enumerable)</h1>     </h3>
<pre data-language="elixir">dedup(t()) :: list()</pre>  <p>Enumerates the <code class="inline">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element.</p> <p>Elements are compared using <a href="../kernel/#===/2"><code class="inline">===/2</code></a>.</p> <p>If you want to remove all duplicated elements, regardless of order, see <a href="#uniq/1"><code class="inline">uniq/1</code></a>.</p> <h4 id="dedup/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.dedup([1, 2, 3, 3, 2, 1])
[1, 2, 3, 2, 1]

iex&gt; Enum.dedup([1, 1, 2, 2.0, :three, :three])
[1, 2, 2.0, :three]</pre>    <h3 class="detail-header function" id="dedup_by/2">  <h1 class="signature">dedup_by(enumerable, fun)</h1>     </h3>
<pre data-language="elixir">dedup_by(t(), (element() -&gt; term())) :: list()</pre>  <p>Enumerates the <code class="inline">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element.</p> <p>The function <code class="inline">fun</code> maps every element to a term which is used to determine if two elements are duplicates.</p> <h4 id="dedup_by/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.dedup_by([{1, :a}, {2, :b}, {2, :c}, {1, :a}], fn {x, _} -&gt; x end)
[{1, :a}, {2, :b}, {1, :a}]

iex&gt; Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -&gt; x &gt; 2 end)
[5, 1, 3, 2]</pre>    <h3 class="detail-header function" id="drop/2">  <h1 class="signature">drop(enumerable, amount)</h1>     </h3>
<pre data-language="elixir">drop(t(), integer()) :: list()</pre>  <p>Drops the <code class="inline">amount</code> of elements from the <code class="inline">enumerable</code>.</p> <p>If a negative <code class="inline">amount</code> is given, the <code class="inline">amount</code> of last values will be dropped. The <code class="inline">enumerable</code> will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</p> <h4 id="drop/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.drop([1, 2, 3], 2)
[3]

iex&gt; Enum.drop([1, 2, 3], 10)
[]

iex&gt; Enum.drop([1, 2, 3], 0)
[1, 2, 3]

iex&gt; Enum.drop([1, 2, 3], -1)
[1, 2]</pre>    <h3 class="detail-header function" id="drop_every/2">  <h1 class="signature">drop_every(enumerable, nth)</h1>     </h3>
<pre data-language="elixir">drop_every(t(), non_neg_integer()) :: list()</pre>  <p>Returns a list of every <code class="inline">nth</code> element in the <code class="inline">enumerable</code> dropped, starting with the first element.</p> <p>The first element is always dropped, unless <code class="inline">nth</code> is 0.</p> <p>The second argument specifying every <code class="inline">nth</code> element must be a non-negative integer.</p> <h4 id="drop_every/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.drop_every(1..10, 2)
[2, 4, 6, 8, 10]

iex&gt; Enum.drop_every(1..10, 0)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

iex&gt; Enum.drop_every([1, 2, 3], 1)
[]</pre>    <h3 class="detail-header function" id="drop_while/2">  <h1 class="signature">drop_while(enumerable, fun)</h1>     </h3>
<pre data-language="elixir">drop_while(t(), (element() -&gt; as_boolean(term()))) :: list()</pre>  <p>Drops elements at the beginning of the <code class="inline">enumerable</code> while <code class="inline">fun</code> returns a truthy value.</p> <h4 id="drop_while/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.drop_while([1, 2, 3, 2, 1], fn x -&gt; x &lt; 3 end)
[3, 2, 1]</pre>    <h3 class="detail-header function" id="each/2">  <h1 class="signature">each(enumerable, fun)</h1>     </h3>
<pre data-language="elixir">each(t(), (element() -&gt; any())) :: :ok</pre>  <p>Invokes the given <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code>.</p> <p>Returns <code class="inline">:ok</code>.</p> <h4 id="each/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Enum.each(["some", "example"], fn x -&gt; IO.puts(x) end)
"some"
"example"
#=&gt; :ok</pre>    <h3 class="detail-header function" id="empty?/1">  <h1 class="signature">empty?(enumerable)</h1>     </h3>
<pre data-language="elixir">empty?(t()) :: boolean()</pre>  <p>Determines if the <code class="inline">enumerable</code> is empty.</p> <p>Returns <code class="inline">true</code> if <code class="inline">enumerable</code> is empty, otherwise <code class="inline">false</code>.</p> <h4 id="empty?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.empty?([])
true

iex&gt; Enum.empty?([1, 2, 3])
false</pre>    <h3 class="detail-header function" id="fetch/2">  <h1 class="signature">fetch(enumerable, index)</h1>     </h3>
<pre data-language="elixir">fetch(t(), index()) :: {:ok, element()} | :error</pre>  <p>Finds the element at the given <code class="inline">index</code> (zero-based).</p> <p>Returns <code class="inline">{:ok, element}</code> if found, otherwise <code class="inline">:error</code>.</p> <p>A negative <code class="inline">index</code> can be passed, which means the <code class="inline">enumerable</code> is enumerated once and the <code class="inline">index</code> is counted from the end (for example, <code class="inline">-1</code> fetches the last element).</p> <h4 id="fetch/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.fetch([2, 4, 6], 0)
{:ok, 2}

iex&gt; Enum.fetch([2, 4, 6], -3)
{:ok, 2}

iex&gt; Enum.fetch([2, 4, 6], 2)
{:ok, 6}

iex&gt; Enum.fetch([2, 4, 6], 4)
:error</pre>    <h3 class="detail-header function" id="fetch!/2">  <h1 class="signature">fetch!(enumerable, index)</h1>     </h3>
<pre data-language="elixir">fetch!(t(), index()) :: element()</pre>  <p>Finds the element at the given <code class="inline">index</code> (zero-based).</p> <p>Raises <code class="inline">OutOfBoundsError</code> if the given <code class="inline">index</code> is outside the range of the <code class="inline">enumerable</code>.</p> <h4 id="fetch!/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.fetch!([2, 4, 6], 0)
2

iex&gt; Enum.fetch!([2, 4, 6], 2)
6

iex&gt; Enum.fetch!([2, 4, 6], 4)
** (Enum.OutOfBoundsError) out of bounds error</pre>    <h3 class="detail-header function" id="filter/2">  <h1 class="signature">filter(enumerable, fun)</h1>     </h3>
<pre data-language="elixir">filter(t(), (element() -&gt; as_boolean(term()))) :: list()</pre>  <p>Filters the <code class="inline">enumerable</code>, i.e. returns only those elements for which <code class="inline">fun</code> returns a truthy value.</p> <p>See also <a href="#reject/2"><code class="inline">reject/2</code></a> which discards all elements where the function returns a truthy value.</p> <h4 id="filter/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.filter([1, 2, 3], fn x -&gt; rem(x, 2) == 0 end)
[2]</pre> <p>Keep in mind that <code class="inline">filter</code> is not capable of filtering and transforming an element at the same time. If you would like to do so, consider using <a href="#flat_map/2"><code class="inline">flat_map/2</code></a>. For example, if you want to convert all strings that represent an integer and discard the invalid one in one pass:</p> <pre data-language="elixir">strings = ["1234", "abc", "12ab"]

Enum.flat_map(strings, fn string -&gt;
  case Integer.parse(string) do
    # transform to integer
    {int, _rest} -&gt; [int]
    # skip the value
    :error -&gt; []
  end
end)</pre>     <h3 class="detail-header function" id="find/3">  <h1 class="signature">find(enumerable, default \\ nil, fun)</h1>     </h3>
<pre data-language="elixir">find(t(), default(), (element() -&gt; any())) :: element() | default()</pre>  <p>Returns the first element for which <code class="inline">fun</code> returns a truthy value. If no such element is found, returns <code class="inline">default</code>.</p> <h4 id="find/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.find([2, 4, 6], fn x -&gt; rem(x, 2) == 1 end)
nil

iex&gt; Enum.find([2, 4, 6], 0, fn x -&gt; rem(x, 2) == 1 end)
0

iex&gt; Enum.find([2, 3, 4], fn x -&gt; rem(x, 2) == 1 end)
3</pre>    <h3 class="detail-header function" id="find_index/2">  <h1 class="signature">find_index(enumerable, fun)</h1>     </h3>
<pre data-language="elixir">find_index(t(), (element() -&gt; any())) :: non_neg_integer() | nil</pre>  <p>Similar to <a href="#find/3"><code class="inline">find/3</code></a>, but returns the index (zero-based) of the element instead of the element itself.</p> <h4 id="find_index/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.find_index([2, 4, 6], fn x -&gt; rem(x, 2) == 1 end)
nil

iex&gt; Enum.find_index([2, 3, 4], fn x -&gt; rem(x, 2) == 1 end)
1</pre>     <h3 class="detail-header function" id="find_value/3">  <h1 class="signature">find_value(enumerable, default \\ nil, fun)</h1>     </h3>
<pre data-language="elixir">find_value(t(), any(), (element() -&gt; any())) :: any() | nil</pre>  <p>Similar to <a href="#find/3"><code class="inline">find/3</code></a>, but returns the value of the function invocation instead of the element itself.</p> <h4 id="find_value/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.find_value([2, 4, 6], fn x -&gt; rem(x, 2) == 1 end)
nil

iex&gt; Enum.find_value([2, 3, 4], fn x -&gt; rem(x, 2) == 1 end)
true

iex&gt; Enum.find_value([1, 2, 3], "no bools!", &amp;is_boolean/1)
"no bools!"</pre>    <h3 class="detail-header function" id="flat_map/2">  <h1 class="signature">flat_map(enumerable, fun)</h1>     </h3>
<pre data-language="elixir">flat_map(t(), (element() -&gt; t())) :: list()</pre>  <p>Maps the given <code class="inline">fun</code> over <code class="inline">enumerable</code> and flattens the result.</p> <p>This function returns a new enumerable built by appending the result of invoking <code class="inline">fun</code> on each element of <code class="inline">enumerable</code> together; conceptually, this is similar to a combination of <a href="#map/2"><code class="inline">map/2</code></a> and <a href="#concat/1"><code class="inline">concat/1</code></a>.</p> <h4 id="flat_map/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.flat_map([:a, :b, :c], fn x -&gt; [x, x] end)
[:a, :a, :b, :b, :c, :c]

iex&gt; Enum.flat_map([{1, 3}, {4, 6}], fn {x, y} -&gt; x..y end)
[1, 2, 3, 4, 5, 6]

iex&gt; Enum.flat_map([:a, :b, :c], fn x -&gt; [[x]] end)
[[:a], [:b], [:c]]</pre>    <h3 class="detail-header function" id="flat_map_reduce/3">  <h1 class="signature">flat_map_reduce(enumerable, acc, fun)</h1>     </h3>
<pre data-language="elixir">flat_map_reduce(t(), acc(), fun) :: {[any()], acc()}
when fun: (element(), acc() -&gt; {t(), acc()} | {:halt, acc()})</pre>  <p>Maps and reduces an <code class="inline">enumerable</code>, flattening the given results (only one level deep).</p> <p>It expects an accumulator and a function that receives each enumerable element, and must return a tuple containing a new enumerable (often a list) with the new accumulator or a tuple with <code class="inline">:halt</code> as first element and the accumulator as second.</p> <h4 id="flat_map_reduce/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; enumerable = 1..100
iex&gt; n = 3
iex&gt; Enum.flat_map_reduce(enumerable, 0, fn x, acc -&gt;
...&gt;   if acc &lt; n, do: {[x], acc + 1}, else: {:halt, acc}
...&gt; end)
{[1, 2, 3], 3}

iex&gt; Enum.flat_map_reduce(1..5, 0, fn x, acc -&gt; {[[x]], acc + x} end)
{[[1], [2], [3], [4], [5]], 15}</pre>     <h3 class="detail-header function" id="group_by/3">  <h1 class="signature">group_by(enumerable, key_fun, value_fun \\ fn x -&gt; x end)</h1>     </h3>
<pre data-language="elixir">group_by(t(), (element() -&gt; any()), (element() -&gt; any())) :: map()</pre>  <p>Splits the <code class="inline">enumerable</code> into groups based on <code class="inline">key_fun</code>.</p> <p>The result is a map where each key is given by <code class="inline">key_fun</code> and each value is a list of elements given by <code class="inline">value_fun</code>. The order of elements within each list is preserved from the <code class="inline">enumerable</code>. However, like all maps, the resulting map is unordered.</p> <h4 id="group_by/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.group_by(~w{ant buffalo cat dingo}, &amp;String.length/1)
%{3 =&gt; ["ant", "cat"], 5 =&gt; ["dingo"], 7 =&gt; ["buffalo"]}

iex&gt; Enum.group_by(~w{ant buffalo cat dingo}, &amp;String.length/1, &amp;String.first/1)
%{3 =&gt; ["a", "c"], 5 =&gt; ["d"], 7 =&gt; ["b"]}</pre>    <h3 class="detail-header function" id="intersperse/2">  <h1 class="signature">intersperse(enumerable, element)</h1>     </h3>
<pre data-language="elixir">intersperse(t(), element()) :: list()</pre>  <p>Intersperses <code class="inline">element</code> between each element of the enumeration.</p> <h4 id="intersperse/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.intersperse([1, 2, 3], 0)
[1, 0, 2, 0, 3]

iex&gt; Enum.intersperse([1], 0)
[1]

iex&gt; Enum.intersperse([], 0)
[]</pre>    <h3 class="detail-header function" id="into/2">  <h1 class="signature">into(enumerable, collectable)</h1>     </h3>
<pre data-language="elixir">into(Enumerable.t(), Collectable.t()) :: Collectable.t()</pre>  <p>Inserts the given <code class="inline">enumerable</code> into a <code class="inline">collectable</code>.</p> <p>Note that passing a non-empty list as the <code class="inline">collectable</code> is deprecated. If you're collecting into a non-empty keyword list, consider using <a href="../keyword/#merge/2"><code class="inline">Keyword.merge/2</code></a>. If you're collecting into a non-empty list, consider something like <code class="inline">to_list(enumerable) ++ collectable</code>.</p> <h4 id="into/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.into([1, 2], [])
[1, 2]

iex&gt; Enum.into([a: 1, b: 2], %{})
%{a: 1, b: 2}

iex&gt; Enum.into(%{a: 1}, %{b: 2})
%{a: 1, b: 2}

iex&gt; Enum.into([a: 1, a: 2], %{})
%{a: 2}</pre>    <h3 class="detail-header function" id="into/3">  <h1 class="signature">into(enumerable, collectable, transform)</h1>     </h3>
<pre data-language="elixir">into(Enumerable.t(), Collectable.t(), (term() -&gt; term())) :: Collectable.t()</pre>  <p>Inserts the given <code class="inline">enumerable</code> into a <code class="inline">collectable</code> according to the transformation function.</p> <h4 id="into/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.into([2, 3], [3], fn x -&gt; x * 3 end)
[3, 6, 9]

iex&gt; Enum.into(%{a: 1, b: 2}, %{c: 3}, fn {k, v} -&gt; {k, v * 2} end)
%{a: 2, b: 4, c: 3}</pre>     <h3 class="detail-header function" id="join/2">  <h1 class="signature">join(enumerable, joiner \\ "")</h1>     </h3>
<pre data-language="elixir">join(t(), String.t()) :: String.t()</pre>  <p>Joins the given <code class="inline">enumerable</code> into a binary using <code class="inline">joiner</code> as a separator.</p> <p>If <code class="inline">joiner</code> is not passed at all, it defaults to the empty binary.</p> <p>All elements in the <code class="inline">enumerable</code> must be convertible to a binary, otherwise an error is raised.</p> <h4 id="join/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.join([1, 2, 3])
"123"

iex&gt; Enum.join([1, 2, 3], " = ")
"1 = 2 = 3"</pre>    <h3 class="detail-header function" id="map/2">  <h1 class="signature">map(enumerable, fun)</h1>     </h3>
<pre data-language="elixir">map(t(), (element() -&gt; any())) :: list()</pre>  <p>Returns a list where each element is the result of invoking <code class="inline">fun</code> on each corresponding element of <code class="inline">enumerable</code>.</p> <p>For maps, the function expects a key-value tuple.</p> <h4 id="map/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.map([1, 2, 3], fn x -&gt; x * 2 end)
[2, 4, 6]

iex&gt; Enum.map([a: 1, b: 2], fn {k, v} -&gt; {k, -v} end)
[a: -1, b: -2]</pre>    <h3 class="detail-header function" id="map_every/3">  <h1 class="signature">map_every(enumerable, nth, fun)</h1>  <span class="note">(since 1.4.0)</span>    </h3>
<pre data-language="elixir">map_every(t(), non_neg_integer(), (element() -&gt; any())) :: list()</pre>  <p>Returns a list of results of invoking <code class="inline">fun</code> on every <code class="inline">nth</code> element of <code class="inline">enumerable</code>, starting with the first element.</p> <p>The first element is always passed to the given function, unless <code class="inline">nth</code> is <code class="inline">0</code>.</p> <p>The second argument specifying every <code class="inline">nth</code> element must be a non-negative integer.</p> <p>If <code class="inline">nth</code> is <code class="inline">0</code>, then <code class="inline">enumerable</code> is directly converted to a list, without <code class="inline">fun</code> being ever applied.</p> <h4 id="map_every/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.map_every(1..10, 2, fn x -&gt; x + 1000 end)
[1001, 2, 1003, 4, 1005, 6, 1007, 8, 1009, 10]

iex&gt; Enum.map_every(1..10, 3, fn x -&gt; x + 1000 end)
[1001, 2, 3, 1004, 5, 6, 1007, 8, 9, 1010]

iex&gt; Enum.map_every(1..5, 0, fn x -&gt; x + 1000 end)
[1, 2, 3, 4, 5]

iex&gt; Enum.map_every([1, 2, 3], 1, fn x -&gt; x + 1000 end)
[1001, 1002, 1003]</pre>     <h3 class="detail-header function" id="map_join/3">  <h1 class="signature">map_join(enumerable, joiner \\ "", mapper)</h1>     </h3>
<pre data-language="elixir">map_join(t(), String.t(), (element() -&gt; String.Chars.t())) :: String.t()</pre>  <p>Maps and joins the given <code class="inline">enumerable</code> in one pass.</p> <p><code class="inline">joiner</code> can be either a binary or a list and the result will be of the same type as <code class="inline">joiner</code>. If <code class="inline">joiner</code> is not passed at all, it defaults to an empty binary.</p> <p>All elements returned from invoking the <code class="inline">mapper</code> must be convertible to a binary, otherwise an error is raised.</p> <h4 id="map_join/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.map_join([1, 2, 3], &amp;(&amp;1 * 2))
"246"

iex&gt; Enum.map_join([1, 2, 3], " = ", &amp;(&amp;1 * 2))
"2 = 4 = 6"</pre>    <h3 class="detail-header function" id="map_reduce/3">  <h1 class="signature">map_reduce(enumerable, acc, fun)</h1>     </h3>
<pre data-language="elixir">map_reduce(t(), acc(), (element(), acc() -&gt; {element(), acc()})) ::
  {list(), acc()}</pre>  <p>Invokes the given function to each element in the <code class="inline">enumerable</code> to reduce it to a single element, while keeping an accumulator.</p> <p>Returns a tuple where the first element is the mapped enumerable and the second one is the final accumulator.</p> <p>The function, <code class="inline">fun</code>, receives two arguments: the first one is the element, and the second one is the accumulator. <code class="inline">fun</code> must return a tuple with two elements in the form of <code class="inline">{result, accumulator}</code>.</p> <p>For maps, the first tuple element must be a <code class="inline">{key, value}</code> tuple.</p> <h4 id="map_reduce/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.map_reduce([1, 2, 3], 0, fn x, acc -&gt; {x * 2, x + acc} end)
{[2, 4, 6], 6}</pre>     <h3 class="detail-header function" id="max/2">  <h1 class="signature">max(enumerable, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</h1>     </h3>
<pre data-language="elixir">max(t(), (() -&gt; empty_result)) :: element() | empty_result
when empty_result: any()</pre>  <p>Returns the maximal element in the <code class="inline">enumerable</code> according to Erlang's term ordering.</p> <p>If multiple elements are considered maximal, the first one that was found is returned.</p> <p>Calls the provided <code class="inline">empty_fallback</code> function and returns its value if <code class="inline">enumerable</code> is empty. The default <code class="inline">empty_fallback</code> raises <a href="../enum.emptyerror/"><code class="inline">Enum.EmptyError</code></a>.</p> <h4 id="max/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.max([1, 2, 3])
3

iex&gt; Enum.max([], fn -&gt; 0 end)
0</pre> <p>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. For example:</p> <pre data-language="elixir">iex&gt; Enum.max([~D[2017-03-31], ~D[2017-04-01]])
~D[2017-03-31]</pre> <p>In the example above, <a href="#max/1"><code class="inline">max/1</code></a> returned March 31st instead of April 1st because the structural comparison compares the day before the year. This can be addressed by using <a href="#max_by/3"><code class="inline">max_by/3</code></a> and by relying on structures where the most significant digits come first. In this particular case, we can use <a href="../date/#to_erl/1"><code class="inline">Date.to_erl/1</code></a> to get a tuple representation with year, month and day fields:</p> <pre data-language="elixir">iex&gt; Enum.max_by([~D[2017-03-31], ~D[2017-04-01]], &amp;Date.to_erl/1)
~D[2017-04-01]</pre> <p>For selecting a maximum value out of two consider using <a href="../kernel/#max/2"><code class="inline">Kernel.max/2</code></a>.</p>     <h3 class="detail-header function" id="max_by/3">  <h1 class="signature">max_by(enumerable, fun, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</h1>     </h3>
<pre data-language="elixir">max_by(t(), (element() -&gt; any()), (() -&gt; empty_result)) ::
  element() | empty_result
when empty_result: any()</pre>  <p>Returns the maximal element in the <code class="inline">enumerable</code> as calculated by the given function.</p> <p>If multiple elements are considered maximal, the first one that was found is returned.</p> <p>Calls the provided <code class="inline">empty_fallback</code> function and returns its value if <code class="inline">enumerable</code> is empty. The default <code class="inline">empty_fallback</code> raises <a href="../enum.emptyerror/"><code class="inline">Enum.EmptyError</code></a>.</p> <h4 id="max_by/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.max_by(["a", "aa", "aaa"], fn x -&gt; String.length(x) end)
"aaa"

iex&gt; Enum.max_by(["a", "aa", "aaa", "b", "bbb"], &amp;String.length/1)
"aaa"

iex&gt; Enum.max_by([], &amp;String.length/1, fn -&gt; nil end)
nil</pre>    <h3 class="detail-header function" id="member?/2">  <h1 class="signature">member?(enumerable, element)</h1>     </h3>
<pre data-language="elixir">member?(t(), element()) :: boolean()</pre>  <p>Checks if <code class="inline">element</code> exists within the <code class="inline">enumerable</code>.</p> <p>Membership is tested with the match (<a href="../kernel/#===/2"><code class="inline">===/2</code></a>) operator.</p> <h4 id="member?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.member?(1..10, 5)
true
iex&gt; Enum.member?(1..10, 5.0)
false

iex&gt; Enum.member?([1.0, 2.0, 3.0], 2)
false
iex&gt; Enum.member?([1.0, 2.0, 3.0], 2.000)
true

iex&gt; Enum.member?([:a, :b, :c], :d)
false</pre>     <h3 class="detail-header function" id="min/2">  <h1 class="signature">min(enumerable, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</h1>     </h3>
<pre data-language="elixir">min(t(), (() -&gt; empty_result)) :: element() | empty_result
when empty_result: any()</pre>  <p>Returns the minimal element in the <code class="inline">enumerable</code> according to Erlang's term ordering.</p> <p>If multiple elements are considered minimal, the first one that was found is returned.</p> <p>Calls the provided <code class="inline">empty_fallback</code> function and returns its value if <code class="inline">enumerable</code> is empty. The default <code class="inline">empty_fallback</code> raises <a href="../enum.emptyerror/"><code class="inline">Enum.EmptyError</code></a>.</p> <h4 id="min/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.min([1, 2, 3])
1

iex&gt; Enum.min([], fn -&gt; 0 end)
0</pre> <p>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. For example:</p> <pre data-language="elixir">iex&gt; Enum.min([~D[2017-03-31], ~D[2017-04-01]])
~D[2017-04-01]</pre> <p>In the example above, <a href="#min/1"><code class="inline">min/1</code></a> returned April 1st instead of March 31st because the structural comparison compares the day before the year. This can be addressed by using <a href="#min_by/3"><code class="inline">min_by/3</code></a> and by relying on structures where the most significant digits come first. In this particular case, we can use <a href="../date/#to_erl/1"><code class="inline">Date.to_erl/1</code></a> to get a tuple representation with year, month and day fields:</p> <pre data-language="elixir">iex&gt; Enum.min_by([~D[2017-03-31], ~D[2017-04-01]], &amp;Date.to_erl/1)
~D[2017-03-31]</pre> <p>For selecting a minimal value out of two consider using <a href="../kernel/#min/2"><code class="inline">Kernel.min/2</code></a>.</p>     <h3 class="detail-header function" id="min_by/3">  <h1 class="signature">min_by(enumerable, fun, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</h1>     </h3>
<pre data-language="elixir">min_by(t(), (element() -&gt; any()), (() -&gt; empty_result)) ::
  element() | empty_result
when empty_result: any()</pre>  <p>Returns the minimal element in the <code class="inline">enumerable</code> as calculated by the given function.</p> <p>If multiple elements are considered minimal, the first one that was found is returned.</p> <p>Calls the provided <code class="inline">empty_fallback</code> function and returns its value if <code class="inline">enumerable</code> is empty. The default <code class="inline">empty_fallback</code> raises <a href="../enum.emptyerror/"><code class="inline">Enum.EmptyError</code></a>.</p> <h4 id="min_by/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.min_by(["a", "aa", "aaa"], fn x -&gt; String.length(x) end)
"a"

iex&gt; Enum.min_by(["a", "aa", "aaa", "b", "bbb"], &amp;String.length/1)
"a"

iex&gt; Enum.min_by([], &amp;String.length/1, fn -&gt; nil end)
nil</pre>     <h3 class="detail-header function" id="min_max/2">  <h1 class="signature">min_max(enumerable, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</h1>     </h3>
<pre data-language="elixir">min_max(t(), (() -&gt; empty_result)) :: {element(), element()} | empty_result
when empty_result: any()</pre>  <p>Returns a tuple with the minimal and the maximal elements in the enumerable according to Erlang's term ordering.</p> <p>If multiple elements are considered maximal or minimal, the first one that was found is returned.</p> <p>Calls the provided <code class="inline">empty_fallback</code> function and returns its value if <code class="inline">enumerable</code> is empty. The default <code class="inline">empty_fallback</code> raises <a href="../enum.emptyerror/"><code class="inline">Enum.EmptyError</code></a>.</p> <h4 id="min_max/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.min_max([2, 3, 1])
{1, 3}

iex&gt; Enum.min_max([], fn -&gt; {nil, nil} end)
{nil, nil}</pre>     <h3 class="detail-header function" id="min_max_by/3">  <h1 class="signature">min_max_by(enumerable, fun, empty_fallback \\ fn -&gt; raise(Enum.EmptyError) end)</h1>     </h3>
<pre data-language="elixir">min_max_by(t(), (element() -&gt; any()), (() -&gt; empty_result)) ::
  {element(), element()} | empty_result
when empty_result: any()</pre>  <p>Returns a tuple with the minimal and the maximal elements in the enumerable as calculated by the given function.</p> <p>If multiple elements are considered maximal or minimal, the first one that was found is returned.</p> <p>Calls the provided <code class="inline">empty_fallback</code> function and returns its value if <code class="inline">enumerable</code> is empty. The default <code class="inline">empty_fallback</code> raises <a href="../enum.emptyerror/"><code class="inline">Enum.EmptyError</code></a>.</p> <h4 id="min_max_by/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.min_max_by(["aaa", "bb", "c"], fn x -&gt; String.length(x) end)
{"c", "aaa"}

iex&gt; Enum.min_max_by(["aaa", "a", "bb", "c", "ccc"], &amp;String.length/1)
{"a", "aaa"}

iex&gt; Enum.min_max_by([], &amp;String.length/1, fn -&gt; {nil, nil} end)
{nil, nil}</pre>    <h3 class="detail-header function" id="random/1">  <h1 class="signature">random(enumerable)</h1>     </h3>
<pre data-language="elixir">random(t()) :: element()</pre>  <p>Returns a random element of an <code class="inline">enumerable</code>.</p> <p>Raises <a href="../enum.emptyerror/"><code class="inline">Enum.EmptyError</code></a> if <code class="inline">enumerable</code> is empty.</p> <p>This function uses Erlang's <a href="http://www.erlang.org/doc/man/rand.html" target="_blank"><code class="inline">:rand</code> module</a> to calculate the random value. Check its documentation for setting a different random algorithm or a different seed.</p> <p>The implementation is based on the <a href="https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle" target="_blank">reservoir sampling</a> algorithm. It assumes that the sample being returned can fit into memory; the input <code class="inline">enumerable</code> doesn't have to, as it is traversed just once.</p> <p>If a range is passed into the function, this function will pick a random value between the range limits, without traversing the whole range (thus executing in constant time and constant memory).</p> <h4 id="random/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Although not necessary, let's seed the random algorithm
iex&gt; :rand.seed(:exsplus, {101, 102, 103})
iex&gt; Enum.random([1, 2, 3])
2
iex&gt; Enum.random([1, 2, 3])
1
iex&gt; Enum.random(1..1_000)
776</pre>    <h3 class="detail-header function" id="reduce/2">  <h1 class="signature">reduce(enumerable, fun)</h1>     </h3>
<pre data-language="elixir">reduce(t(), (element(), acc() -&gt; acc())) :: acc()</pre>  <p>Invokes <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code> with the accumulator.</p> <p>Raises <a href="../enum.emptyerror/"><code class="inline">Enum.EmptyError</code></a> if <code class="inline">enumerable</code> is empty.</p> <p>The first element of the <code class="inline">enumerable</code> is used as the initial value of the accumulator. Then the function is invoked with the next element and the accumulator. The result returned by the function is used as the accumulator for the next iteration, recursively. When the <code class="inline">enumerable</code> is done, the last accumulator is returned.</p> <p>Since the first element of the enumerable is used as the initial value of the accumulator, <code class="inline">fun</code> will only be executed <code class="inline">n - 1</code> times where <code class="inline">n</code> is the length of the enumerable. This function won't call the specified function for enumerables that are one-element long.</p> <p>If you wish to use another value for the accumulator, use <a href="../enum/#reduce/3"><code class="inline">Enum.reduce/3</code></a>.</p> <h4 id="reduce/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.reduce([1, 2, 3, 4], fn x, acc -&gt; x * acc end)
24</pre>    <h3 class="detail-header function" id="reduce/3">  <h1 class="signature">reduce(enumerable, acc, fun)</h1>     </h3>
<pre data-language="elixir">reduce(t(), any(), (element(), any() -&gt; any())) :: any()</pre>  <p>Invokes <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code> with the accumulator.</p> <p>The initial value of the accumulator is <code class="inline">acc</code>. The function is invoked for each element in the enumerable with the accumulator. The result returned by the function is used as the accumulator for the next iteration. The function returns the last accumulator.</p> <h4 id="reduce/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.reduce([1, 2, 3], 0, fn x, acc -&gt; x + acc end)
6</pre> <h4 id="reduce/3-reduce-as-a-building-block" class="section-heading">  Reduce as a building block </h4> <p>Reduce (sometimes called <code class="inline">fold</code>) is a basic building block in functional programming. Almost all of the functions in the <a href="#content"><code class="inline">Enum</code></a> module can be implemented on top of reduce. Those functions often rely on other operations, such as <a href="../enum/#reverse/1"><code class="inline">Enum.reverse/1</code></a>, which are optimized by the runtime.</p> <p>For example, we could implement <a href="#map/2"><code class="inline">map/2</code></a> in terms of <a href="#reduce/3"><code class="inline">reduce/3</code></a> as follows:</p> <pre data-language="elixir">def my_map(enumerable, fun) do
  enumerable
  |&gt; Enum.reduce([], fn x, acc -&gt; [fun.(x) | acc] end)
  |&gt; Enum.reverse()
end</pre> <p>In the example above, <a href="../enum/#reduce/3"><code class="inline">Enum.reduce/3</code></a> accumulates the result of each call to <code class="inline">fun</code> into a list in reverse order, which is correctly ordered at the end by calling <a href="../enum/#reverse/1"><code class="inline">Enum.reverse/1</code></a>.</p> <p>Implementing functions like <a href="#map/2"><code class="inline">map/2</code></a>, <a href="#filter/2"><code class="inline">filter/2</code></a> and others are a good exercise for understanding the power behind <a href="../enum/#reduce/3"><code class="inline">Enum.reduce/3</code></a>. When an operation cannot be expressed by any of the functions in the <a href="#content"><code class="inline">Enum</code></a> module, developers will most likely resort to <a href="#reduce/3"><code class="inline">reduce/3</code></a>.</p>    <h3 class="detail-header function" id="reduce_while/3">  <h1 class="signature">reduce_while(enumerable, acc, fun)</h1>     </h3>
<pre data-language="elixir">reduce_while(
  t(),
  any(),
  (element(), any() -&gt; {:cont, any()} | {:halt, any()})
) :: any()</pre>  <p>Reduces <code class="inline">enumerable</code> until <code class="inline">fun</code> returns <code class="inline">{:halt, term}</code>.</p> <p>The return value for <code class="inline">fun</code> is expected to be</p> <ul> <li>
<code class="inline">{:cont, acc}</code> to continue the reduction with <code class="inline">acc</code> as the new accumulator or </li> <li>
<code class="inline">{:halt, acc}</code> to halt the reduction </li> </ul> <p>If <code class="inline">fun</code> returns <code class="inline">{:halt, acc}</code> the reduction is halted and the function returns <code class="inline">acc</code>. Otherwise, if the enumerable is exhausted, the function returns the accumulator of the last <code class="inline">{:cont, acc}</code>.</p> <h4 id="reduce_while/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.reduce_while(1..100, 0, fn x, acc -&gt;
...&gt;   if x &lt; 5, do: {:cont, acc + x}, else: {:halt, acc}
...&gt; end)
10
iex&gt; Enum.reduce_while(1..100, 0, fn x, acc -&gt;
...&gt;   if x &gt; 0, do: {:cont, acc + x}, else: {:halt, acc}
...&gt; end)
5050</pre>    <h3 class="detail-header function" id="reject/2">  <h1 class="signature">reject(enumerable, fun)</h1>     </h3>
<pre data-language="elixir">reject(t(), (element() -&gt; as_boolean(term()))) :: list()</pre>  <p>Returns a list of elements in <code class="inline">enumerable</code> excluding those for which the function <code class="inline">fun</code> returns a truthy value.</p> <p>See also <a href="#filter/2"><code class="inline">filter/2</code></a>.</p> <h4 id="reject/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.reject([1, 2, 3], fn x -&gt; rem(x, 2) == 0 end)
[1, 3]</pre>    <h3 class="detail-header function" id="reverse/1">  <h1 class="signature">reverse(enumerable)</h1>     </h3>
<pre data-language="elixir">reverse(t()) :: list()</pre>  <p>Returns a list of elements in <code class="inline">enumerable</code> in reverse order.</p> <h4 id="reverse/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.reverse([1, 2, 3])
[3, 2, 1]</pre>    <h3 class="detail-header function" id="reverse/2">  <h1 class="signature">reverse(enumerable, tail)</h1>     </h3>
<pre data-language="elixir">reverse(t(), t()) :: list()</pre>  <p>Reverses the elements in <code class="inline">enumerable</code>, appends the <code class="inline">tail</code>, and returns it as a list.</p> <p>This is an optimization for <code class="inline">enumerable |&gt; Enum.reverse() |&gt; Enum.concat(tail)</code>.</p> <h4 id="reverse/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.reverse([1, 2, 3], [4, 5, 6])
[3, 2, 1, 4, 5, 6]</pre>    <h3 class="detail-header function" id="reverse_slice/3">  <h1 class="signature">reverse_slice(enumerable, start_index, count)</h1>     </h3>
<pre data-language="elixir">reverse_slice(t(), non_neg_integer(), non_neg_integer()) :: list()</pre>  <p>Reverses the <code class="inline">enumerable</code> in the range from initial <code class="inline">start_index</code> through <code class="inline">count</code> elements.</p> <p>If <code class="inline">count</code> is greater than the size of the rest of the <code class="inline">enumerable</code>, then this function will reverse the rest of the enumerable.</p> <h4 id="reverse_slice/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)
[1, 2, 6, 5, 4, 3]</pre>    <h3 class="detail-header function" id="scan/2">  <h1 class="signature">scan(enumerable, fun)</h1>     </h3>
<pre data-language="elixir">scan(t(), (element(), any() -&gt; any())) :: list()</pre>  <p>Applies the given function to each element in the <code class="inline">enumerable</code>, storing the result in a list and passing it as the accumulator for the next computation. Uses the first element in the <code class="inline">enumerable</code> as the starting value.</p> <h4 id="scan/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.scan(1..5, &amp;(&amp;1 + &amp;2))
[1, 3, 6, 10, 15]</pre>    <h3 class="detail-header function" id="scan/3">  <h1 class="signature">scan(enumerable, acc, fun)</h1>     </h3>
<pre data-language="elixir">scan(t(), any(), (element(), any() -&gt; any())) :: list()</pre>  <p>Applies the given function to each element in the <code class="inline">enumerable</code>, storing the result in a list and passing it as the accumulator for the next computation. Uses the given <code class="inline">acc</code> as the starting value.</p> <h4 id="scan/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.scan(1..5, 0, &amp;(&amp;1 + &amp;2))
[1, 3, 6, 10, 15]</pre>    <h3 class="detail-header function" id="shuffle/1">  <h1 class="signature">shuffle(enumerable)</h1>     </h3>
<pre data-language="elixir">shuffle(t()) :: list()</pre>  <p>Returns a list with the elements of <code class="inline">enumerable</code> shuffled.</p> <p>This function uses Erlang's <a href="http://www.erlang.org/doc/man/rand.html" target="_blank"><code class="inline">:rand</code> module</a> to calculate the random value. Check its documentation for setting a different random algorithm or a different seed.</p> <h4 id="shuffle/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Although not necessary, let's seed the random algorithm
iex&gt; :rand.seed(:exsplus, {1, 2, 3})
iex&gt; Enum.shuffle([1, 2, 3])
[2, 1, 3]
iex&gt; Enum.shuffle([1, 2, 3])
[2, 3, 1]</pre>    <h3 class="detail-header function" id="slice/2">  <h1 class="signature">slice(enumerable, index_range)</h1>  <span class="note">(since 1.6.0)</span>    </h3>
<pre data-language="elixir">slice(t(), Range.t()) :: list()</pre>  <p>Returns a subset list of the given <code class="inline">enumerable</code> by <code class="inline">index_range</code>.</p> <p><code class="inline">index_range</code> must be a <a href="../range/"><code class="inline">Range</code></a>. Given an <code class="inline">enumerable</code>, it drops elements before <code class="inline">index_range.first</code> (zero-base), then takes elements until element <code class="inline">index_range.last</code> (inclusively).</p> <p>Indexes are normalized, meaning that negative indexes will be counted from the end (for example, <code class="inline">-1</code> means the last element of the <code class="inline">enumerable</code>).</p> <p>If <code class="inline">index_range.last</code> is out of bounds, then it is assigned as the index of the last element.</p> <p>If the normalized <code class="inline">index_range.first</code> is out of bounds of the given <code class="inline">enumerable</code>, or this one is greater than the normalized <code class="inline">index_range.last</code>, then <code class="inline">[]</code> is returned.</p> <h4 id="slice/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.slice(1..100, 5..10)
[6, 7, 8, 9, 10, 11]

iex&gt; Enum.slice(1..10, 5..20)
[6, 7, 8, 9, 10]

# last five elements (negative indexes)
iex&gt; Enum.slice(1..30, -5..-1)
[26, 27, 28, 29, 30]

# last five elements (mixed positive and negative indexes)
iex&gt; Enum.slice(1..30, 25..-1)
[26, 27, 28, 29, 30]

# out of bounds
iex&gt; Enum.slice(1..10, 11..20)
[]

# index_range.first is greater than index_range.last
iex&gt; Enum.slice(1..10, 6..5)
[]</pre>    <h3 class="detail-header function" id="slice/3">  <h1 class="signature">slice(enumerable, start_index, amount)</h1>     </h3>
<pre data-language="elixir">slice(t(), index(), non_neg_integer()) :: list()</pre>  <p>Returns a subset list of the given <code class="inline">enumerable</code>, from <code class="inline">start_index</code> (zero-based) with <code class="inline">amount</code> number of elements if available.</p> <p>Given an <code class="inline">enumerable</code>, it drops elements right before element <code class="inline">start_index</code>, then takes <code class="inline">amount</code> of elements, returning as many elements as possible if there are not enough elements.</p> <p>A negative <code class="inline">start_index</code> can be passed, which means the <code class="inline">enumerable</code> is enumerated once and the index is counted from the end (for example, <code class="inline">-1</code> starts slicing from the last element).</p> <p>It returns <code class="inline">[]</code> if <code class="inline">amount</code> is <code class="inline">0</code> or if <code class="inline">start_index</code> is out of bounds.</p> <h4 id="slice/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.slice(1..100, 5, 10)
[6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

# amount to take is greater than the number of elements
iex&gt; Enum.slice(1..10, 5, 100)
[6, 7, 8, 9, 10]

iex&gt; Enum.slice(1..10, 5, 0)
[]

# using a negative start index
iex&gt; Enum.slice(1..10, -6, 3)
[5, 6, 7]

# out of bound start index (positive)
iex&gt; Enum.slice(1..10, 10, 5)
[]

# out of bound start index (negative)
iex&gt; Enum.slice(1..10, -11, 5)
[]</pre>    <h3 class="detail-header function" id="sort/1">  <h1 class="signature">sort(enumerable)</h1>     </h3>
<pre data-language="elixir">sort(t()) :: list()</pre>  <p>Sorts the <code class="inline">enumerable</code> according to Erlang's term ordering.</p> <p>Uses the merge sort algorithm.</p> <h4 id="sort/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.sort([3, 2, 1])
[1, 2, 3]</pre>    <h3 class="detail-header function" id="sort/2">  <h1 class="signature">sort(enumerable, fun)</h1>     </h3>
<pre data-language="elixir">sort(t(), (element(), element() -&gt; boolean())) :: list()</pre>  <p>Sorts the <code class="inline">enumerable</code> by the given function.</p> <p>This function uses the merge sort algorithm. The given function should compare two arguments, and return <code class="inline">true</code> if the first argument precedes the second one.</p> <h4 id="sort/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.sort([1, 2, 3], &amp;(&amp;1 &gt;= &amp;2))
[3, 2, 1]</pre> <p>The sorting algorithm will be stable as long as the given function returns <code class="inline">true</code> for values considered equal:</p> <pre data-language="elixir">iex&gt; Enum.sort(["some", "kind", "of", "monster"], &amp;(byte_size(&amp;1) &lt;= byte_size(&amp;2)))
["of", "some", "kind", "monster"]</pre> <p>If the function does not return <code class="inline">true</code> for equal values, the sorting is not stable and the order of equal terms may be shuffled. For example:</p> <pre data-language="elixir">iex&gt; Enum.sort(["some", "kind", "of", "monster"], &amp;(byte_size(&amp;1) &lt; byte_size(&amp;2)))
["of", "kind", "some", "monster"]</pre>     <h3 class="detail-header function" id="sort_by/3">  <h1 class="signature">sort_by(enumerable, mapper, sorter \\ &amp;&lt;=/2)</h1>     </h3>
<pre data-language="elixir">sort_by(
  t(),
  (element() -&gt; mapped_element),
  (mapped_element, mapped_element -&gt; boolean())
) :: list()
when mapped_element: element()</pre>  <p>Sorts the mapped results of the <code class="inline">enumerable</code> according to the provided <code class="inline">sorter</code> function.</p> <p>This function maps each element of the <code class="inline">enumerable</code> using the provided <code class="inline">mapper</code> function. The enumerable is then sorted by the mapped elements using the <code class="inline">sorter</code> function, which defaults to <a href="../kernel/#%253C=/2"><code class="inline">Kernel.&lt;=/2</code></a>.</p> <p><a href="#sort_by/3"><code class="inline">sort_by/3</code></a> differs from <a href="#sort/2"><code class="inline">sort/2</code></a> in that it only calculates the comparison value for each element in the enumerable once instead of once for each element in each comparison. If the same function is being called on both elements, it's also more compact to use <a href="#sort_by/3"><code class="inline">sort_by/3</code></a>.</p> <h4 id="sort_by/3-examples" class="section-heading">  Examples </h4> <p>Using the default <code class="inline">sorter</code> of <a href="../kernel/#%253C=/2"><code class="inline">&lt;=/2</code></a>:</p> <pre data-language="elixir">iex&gt; Enum.sort_by(["some", "kind", "of", "monster"], &amp;byte_size/1)
["of", "some", "kind", "monster"]</pre> <p>Using a custom <code class="inline">sorter</code> to override the order:</p> <pre data-language="elixir">iex&gt; Enum.sort_by(["some", "kind", "of", "monster"], &amp;byte_size/1, &amp;&gt;=/2)
["monster", "some", "kind", "of"]</pre> <p>Sorting by multiple properties - first by size, then by first letter (this takes advantage of the fact that tuples are compared element-by-element):</p> <pre data-language="elixir">iex&gt; Enum.sort_by(["some", "kind", "of", "monster"], &amp;{byte_size(&amp;1), String.first(&amp;1)})
["of", "kind", "some", "monster"]</pre>    <h3 class="detail-header function" id="split/2">  <h1 class="signature">split(enumerable, count)</h1>     </h3>
<pre data-language="elixir">split(t(), integer()) :: {list(), list()}</pre>  <p>Splits the <code class="inline">enumerable</code> into two enumerables, leaving <code class="inline">count</code> elements in the first one.</p> <p>If <code class="inline">count</code> is a negative number, it starts counting from the back to the beginning of the <code class="inline">enumerable</code>.</p> <p>Be aware that a negative <code class="inline">count</code> implies the <code class="inline">enumerable</code> will be enumerated twice: once to calculate the position, and a second time to do the actual splitting.</p> <h4 id="split/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.split([1, 2, 3], 2)
{[1, 2], [3]}

iex&gt; Enum.split([1, 2, 3], 10)
{[1, 2, 3], []}

iex&gt; Enum.split([1, 2, 3], 0)
{[], [1, 2, 3]}

iex&gt; Enum.split([1, 2, 3], -1)
{[1, 2], [3]}

iex&gt; Enum.split([1, 2, 3], -5)
{[], [1, 2, 3]}</pre>    <h3 class="detail-header function" id="split_while/2">  <h1 class="signature">split_while(enumerable, fun)</h1>     </h3>
<pre data-language="elixir">split_while(t(), (element() -&gt; as_boolean(term()))) :: {list(), list()}</pre>  <p>Splits enumerable in two at the position of the element for which <code class="inline">fun</code> returns a falsy value (<code class="inline">false</code> or <code class="inline">nil</code>) for the first time.</p> <p>It returns a two-element tuple with two lists of elements. The element that triggered the split is part of the second list.</p> <h4 id="split_while/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.split_while([1, 2, 3, 4], fn x -&gt; x &lt; 3 end)
{[1, 2], [3, 4]}

iex&gt; Enum.split_while([1, 2, 3, 4], fn x -&gt; x &lt; 0 end)
{[], [1, 2, 3, 4]}

iex&gt; Enum.split_while([1, 2, 3, 4], fn x -&gt; x &gt; 0 end)
{[1, 2, 3, 4], []}</pre>    <h3 class="detail-header function" id="split_with/2">  <h1 class="signature">split_with(enumerable, fun)</h1>  <span class="note">(since 1.4.0)</span>    </h3>
<pre data-language="elixir">split_with(t(), (element() -&gt; as_boolean(term()))) :: {list(), list()}</pre>  <p>Splits the <code class="inline">enumerable</code> in two lists according to the given function <code class="inline">fun</code>.</p> <p>Splits the given <code class="inline">enumerable</code> in two lists by calling <code class="inline">fun</code> with each element in the <code class="inline">enumerable</code> as its only argument. Returns a tuple with the first list containing all the elements in <code class="inline">enumerable</code> for which applying <code class="inline">fun</code> returned a truthy value, and a second list with all the elements for which applying <code class="inline">fun</code> returned a falsy value (<code class="inline">false</code> or <code class="inline">nil</code>).</p> <p>The elements in both the returned lists are in the same relative order as they were in the original enumerable (if such enumerable was ordered, like a list). See the examples below.</p> <h4 id="split_with/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.split_with([5, 4, 3, 2, 1, 0], fn x -&gt; rem(x, 2) == 0 end)
{[4, 2, 0], [5, 3, 1]}

iex&gt; Enum.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn {_k, v} -&gt; v &lt; 0 end)
{[b: -2, d: -3], [a: 1, c: 1]}

iex&gt; Enum.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn {_k, v} -&gt; v &gt; 50 end)
{[], [a: 1, b: -2, c: 1, d: -3]}

iex&gt; Enum.split_with(%{}, fn {_k, v} -&gt; v &gt; 50 end)
{[], []}</pre>    <h3 class="detail-header function" id="sum/1">  <h1 class="signature">sum(enumerable)</h1>     </h3>
<pre data-language="elixir">sum(t()) :: number()</pre>  <p>Returns the sum of all elements.</p> <p>Raises <a href="../arithmeticerror/"><code class="inline">ArithmeticError</code></a> if <code class="inline">enumerable</code> contains a non-numeric value.</p> <h4 id="sum/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.sum([1, 2, 3])
6</pre>    <h3 class="detail-header function" id="take/2">  <h1 class="signature">take(enumerable, amount)</h1>     </h3>
<pre data-language="elixir">take(t(), integer()) :: list()</pre>  <p>Takes an <code class="inline">amount</code> of elements from the beginning or the end of the <code class="inline">enumerable</code>.</p> <p>If a positive <code class="inline">amount</code> is given, it takes the <code class="inline">amount</code> elements from the beginning of the <code class="inline">enumerable</code>.</p> <p>If a negative <code class="inline">amount</code> is given, the <code class="inline">amount</code> of elements will be taken from the end. The <code class="inline">enumerable</code> will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</p> <p>If amount is <code class="inline">0</code>, it returns <code class="inline">[]</code>.</p> <h4 id="take/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.take([1, 2, 3], 2)
[1, 2]

iex&gt; Enum.take([1, 2, 3], 10)
[1, 2, 3]

iex&gt; Enum.take([1, 2, 3], 0)
[]

iex&gt; Enum.take([1, 2, 3], -1)
[3]</pre>    <h3 class="detail-header function" id="take_every/2">  <h1 class="signature">take_every(enumerable, nth)</h1>     </h3>
<pre data-language="elixir">take_every(t(), non_neg_integer()) :: list()</pre>  <p>Returns a list of every <code class="inline">nth</code> element in the <code class="inline">enumerable</code>, starting with the first element.</p> <p>The first element is always included, unless <code class="inline">nth</code> is 0.</p> <p>The second argument specifying every <code class="inline">nth</code> element must be a non-negative integer.</p> <h4 id="take_every/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.take_every(1..10, 2)
[1, 3, 5, 7, 9]

iex&gt; Enum.take_every(1..10, 0)
[]

iex&gt; Enum.take_every([1, 2, 3], 1)
[1, 2, 3]</pre>    <h3 class="detail-header function" id="take_random/2">  <h1 class="signature">take_random(enumerable, count)</h1>     </h3>
<pre data-language="elixir">take_random(t(), non_neg_integer()) :: list()</pre>  <p>Takes <code class="inline">count</code> random elements from <code class="inline">enumerable</code>.</p> <p>Notice this function will traverse the whole <code class="inline">enumerable</code> to get the random sublist.</p> <p>See <a href="#random/1"><code class="inline">random/1</code></a> for notes on implementation and random seed.</p> <h4 id="take_random/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Although not necessary, let's seed the random algorithm
iex&gt; :rand.seed(:exsplus, {1, 2, 3})
iex&gt; Enum.take_random(1..10, 2)
[5, 4]
iex&gt; Enum.take_random(?a..?z, 5)
'ipybz'</pre>    <h3 class="detail-header function" id="take_while/2">  <h1 class="signature">take_while(enumerable, fun)</h1>     </h3>
<pre data-language="elixir">take_while(t(), (element() -&gt; as_boolean(term()))) :: list()</pre>  <p>Takes the elements from the beginning of the <code class="inline">enumerable</code> while <code class="inline">fun</code> returns a truthy value.</p> <h4 id="take_while/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.take_while([1, 2, 3], fn x -&gt; x &lt; 3 end)
[1, 2]</pre>    <h3 class="detail-header function" id="to_list/1">  <h1 class="signature">to_list(enumerable)</h1>     </h3>
<pre data-language="elixir">to_list(t()) :: [element()]</pre>  <p>Converts <code class="inline">enumerable</code> to a list.</p> <h4 id="to_list/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.to_list(1..3)
[1, 2, 3]</pre>    <h3 class="detail-header function" id="uniq/1">  <h1 class="signature">uniq(enumerable)</h1>     </h3>
<pre data-language="elixir">uniq(t()) :: list()</pre>  <p>Enumerates the <code class="inline">enumerable</code>, removing all duplicated elements.</p> <h4 id="uniq/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.uniq([1, 2, 3, 3, 2, 1])
[1, 2, 3]</pre>    <h3 class="detail-header function" id="uniq_by/2">  <h1 class="signature">uniq_by(enumerable, fun)</h1>     </h3>
<pre data-language="elixir">uniq_by(t(), (element() -&gt; term())) :: list()</pre>  <p>Enumerates the <code class="inline">enumerable</code>, by removing the elements for which function <code class="inline">fun</code> returned duplicate elements.</p> <p>The function <code class="inline">fun</code> maps every element to a term. Two elements are considered duplicates if the return value of <code class="inline">fun</code> is equal for both of them.</p> <p>The first occurrence of each element is kept.</p> <h4 id="uniq_by/2-example" class="section-heading">  Example </h4> <pre data-language="elixir">iex&gt; Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -&gt; x end)
[{1, :x}, {2, :y}]

iex&gt; Enum.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -&gt; y end)
[a: {:tea, 2}, c: {:coffee, 1}]</pre>    <h3 class="detail-header function" id="unzip/1">  <h1 class="signature">unzip(enumerable)</h1>     </h3>
<pre data-language="elixir">unzip(t()) :: {[element()], [element()]}</pre>  <p>Opposite of <a href="#zip/2"><code class="inline">zip/2</code></a>. Extracts two-element tuples from the given <code class="inline">enumerable</code> and groups them together.</p> <p>It takes an <code class="inline">enumerable</code> with elements being two-element tuples and returns a tuple with two lists, each of which is formed by the first and second element of each tuple, respectively.</p> <p>This function fails unless <code class="inline">enumerable</code> is or can be converted into a list of tuples with <em>exactly</em> two elements in each tuple.</p> <h4 id="unzip/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])
{[:a, :b, :c], [1, 2, 3]}

iex&gt; Enum.unzip(%{a: 1, b: 2})
{[:a, :b], [1, 2]}</pre>     <h3 class="detail-header function" id="with_index/2">  <h1 class="signature">with_index(enumerable, offset \\ 0)</h1>     </h3>
<pre data-language="elixir">with_index(t(), integer()) :: [{element(), index()}]</pre>  <p>Returns the <code class="inline">enumerable</code> with each element wrapped in a tuple alongside its index.</p> <p>If an <code class="inline">offset</code> is given, we will index from the given offset instead of from zero.</p> <h4 id="with_index/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.with_index([:a, :b, :c])
[a: 0, b: 1, c: 2]

iex&gt; Enum.with_index([:a, :b, :c], 3)
[a: 3, b: 4, c: 5]</pre>    <h3 class="detail-header function" id="zip/1">  <h1 class="signature">zip(enumerables)</h1>  <span class="note">(since 1.4.0)</span>    </h3>
<pre data-language="elixir">zip(enumerables) :: [tuple()] when enumerables: [t()] | t()</pre>  <p>Zips corresponding elements from a finite collection of enumerables into one list of tuples.</p> <p>The zipping finishes as soon as any enumerable in the given collection completes.</p> <h4 id="zip/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.zip([[1, 2, 3], [:a, :b, :c], ["foo", "bar", "baz"]])
[{1, :a, "foo"}, {2, :b, "bar"}, {3, :c, "baz"}]

iex&gt; Enum.zip([[1, 2, 3, 4, 5], [:a, :b, :c]])
[{1, :a}, {2, :b}, {3, :c}]</pre>    <h3 class="detail-header function" id="zip/2">  <h1 class="signature">zip(enumerable1, enumerable2)</h1>     </h3>
<pre data-language="elixir">zip(t(), t()) :: [{any(), any()}]</pre>  <p>Zips corresponding elements from two enumerables into one list of tuples.</p> <p>The zipping finishes as soon as any enumerable completes.</p> <h4 id="zip/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.zip([1, 2, 3], [:a, :b, :c])
[{1, :a}, {2, :b}, {3, :c}]

iex&gt; Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])
[{1, :a}, {2, :b}, {3, :c}]</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.9.1/Enum.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.9.1/Enum.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
