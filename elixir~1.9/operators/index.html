
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Operators - Elixir 1.9 - W3cubDocs</title>
  
  <meta name="description" content=" This document covers operators in Elixir, how they are parsed, how they can be defined, and how they can be overridden. ">
  <meta name="keywords" content="operators, -, elixir, elixir~1.9">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.9/operators/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/elixir~1.9.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.9/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.9</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1>Operators</h1> <p>This document covers operators in Elixir, how they are parsed, how they can be defined, and how they can be overridden.</p> <h2 id="operator-precedence-and-associativity" class="section-heading">  Operator precedence and associativity </h2> <p>The following is a list of all operators that Elixir is capable of parsing, ordered from higher to lower precedence, alongside their associativity:</p> <table> <colgroup> <col> <col> </colgroup> <thead> <tr> <th style="text-align: left">Operator</th>
<th style="text-align: left">Associativity</th> </tr> </thead> <tr> <td style="text-align: left"><code class="inline">@</code></td>
<td style="text-align: left">Unary</td> </tr> <tr> <td style="text-align: left"><code class="inline">.</code></td>
<td style="text-align: left">Left to right</td> </tr> <tr> <td style="text-align: left">
<code class="inline">+</code> <code class="inline">-</code> <code class="inline">!</code> <code class="inline">^</code> <code class="inline">not</code> <code class="inline">~~~</code>
</td>
<td style="text-align: left">Unary</td> </tr> <tr> <td style="text-align: left">
<code class="inline">*</code> <code class="inline">/</code>
</td>
<td style="text-align: left">Left to right</td> </tr> <tr> <td style="text-align: left">
<code class="inline">+</code> <code class="inline">-</code>
</td>
<td style="text-align: left">Left to right</td> </tr> <tr> <td style="text-align: left">
<code class="inline">++</code> <code class="inline">--</code> <code class="inline">..</code> <code class="inline">&lt;&gt;</code>
</td>
<td style="text-align: left">Right to left</td> </tr> <tr> <td style="text-align: left"><code class="inline">^^^</code></td>
<td style="text-align: left">Left to right</td> </tr> <tr> <td style="text-align: left">
<code class="inline">in</code> <code class="inline">not in</code>
</td>
<td style="text-align: left">Left to right</td> </tr> <tr> <td style="text-align: left">
<code class="inline">|&gt;</code> <code class="inline">&lt;&lt;&lt;</code> <code class="inline">&gt;&gt;&gt;</code> <code class="inline">&lt;&lt;~</code> <code class="inline">~&gt;&gt;</code> <code class="inline">&lt;~</code> <code class="inline">~&gt;</code> <code class="inline">&lt;~&gt;</code> <code class="inline">&lt;|&gt;</code>
</td>
<td style="text-align: left">Left to right</td> </tr> <tr> <td style="text-align: left">
<code class="inline">&lt;</code> <code class="inline">&gt;</code> <code class="inline">&lt;=</code> <code class="inline">&gt;=</code>
</td>
<td style="text-align: left">Left to right</td> </tr> <tr> <td style="text-align: left">
<code class="inline">==</code> <code class="inline">!=</code> <code class="inline">=~</code> <code class="inline">===</code> <code class="inline">!==</code>
</td>
<td style="text-align: left">Left to right</td> </tr> <tr> <td style="text-align: left">
<code class="inline">&amp;&amp;</code> <code class="inline">&amp;&amp;&amp;</code> <code class="inline">and</code>
</td>
<td style="text-align: left">Left to right</td> </tr> <tr> <td style="text-align: left">
<code class="inline">||</code> <code class="inline">|||</code> <code class="inline">or</code>
</td>
<td style="text-align: left">Left to right</td> </tr> <tr> <td style="text-align: left"><code class="inline">=</code></td>
<td style="text-align: left">Right to left</td> </tr> <tr> <td style="text-align: left"><code class="inline">&amp;</code></td>
<td style="text-align: left">Unary</td> </tr> <tr> <td style="text-align: left">
<code class="inline">=&gt;</code> (valid syntax only inside <code class="inline">%{}</code>)</td>
<td style="text-align: left">Right to left</td> </tr> <tr> <td style="text-align: left"><code class="inline">|</code></td>
<td style="text-align: left">Right to left</td> </tr> <tr> <td style="text-align: left"><code class="inline">::</code></td>
<td style="text-align: left">Right to left</td> </tr> <tr> <td style="text-align: left"><code class="inline">when</code></td>
<td style="text-align: left">Right to left</td> </tr> <tr> <td style="text-align: left">
<code class="inline">&lt;-</code> <code class="inline">\\</code>
</td>
<td style="text-align: left">Left to right</td> </tr> </table> <h2 id="comparison-operators" class="section-heading">  Comparison operators </h2> <p>Elixir provides the following built-in comparison operators:</p> <ul> <li>
<a href="../kernel/#==/2"><code class="inline">==</code></a> - equality </li> <li>
<a href="../kernel/#===/2"><code class="inline">===</code></a> - strict equality </li> <li>
<a href="../kernel/#!=/2"><code class="inline">!=</code></a> - inequality </li> <li>
<a href="../kernel/#!==/2"><code class="inline">!==</code></a> - strict inequality </li> <li>
<a href="../kernel/#%253C/2"><code class="inline">&lt;</code></a> - less than </li> <li>
<a href="../kernel/#%253E/2"><code class="inline">&gt;</code></a> - greater than </li> <li>
<a href="../kernel/#%253C=/2"><code class="inline">&lt;=</code></a> - less than or equal </li> <li>
<a href="../kernel/#%253E=/2"><code class="inline">&gt;=</code></a> - greater than or equal </li> </ul> <p>The only difference between <a href="../kernel/#==/2"><code class="inline">==</code></a> and <a href="../kernel/#===/2"><code class="inline">===</code></a> is that <a href="../kernel/#===/2"><code class="inline">===</code></a> is strict when it comes to comparing integers and floats:</p> <pre data-language="elixir">iex&gt; 1 == 1.0
true
iex&gt; 1 === 1.0
false</pre> <p><a href="../kernel/#!=/2"><code class="inline">!=</code></a> and <a href="../kernel/#!==/2"><code class="inline">!==</code></a> act as the negation of <a href="../kernel/#==/2"><code class="inline">==</code></a> and <a href="../kernel/#===/2"><code class="inline">===</code></a>, respectively.</p> <h3 id="term-ordering" class="section-heading">  Term ordering </h3> <p>In Elixir, different data types can be compared using comparison operators:</p> <pre data-language="elixir">iex&gt; 1 &lt; :an_atom
true</pre> <p>The reason we can compare different data types is pragmatism. Sorting algorithms don't need to worry about different data types in order to sort. For reference, the overall sorting order is defined below:</p> <pre data-language="elixir">number &lt; atom &lt; reference &lt; function &lt; port &lt; pid &lt; tuple &lt; map &lt; list &lt; bitstring</pre> <p>When comparing two numbers of different types (a number being either an integer or a float), a conversion to the type with greater precision will always occur, unless the comparison operator used is either <a href="../kernel/#===/2"><code class="inline">===</code></a> or <a href="../kernel/#!==/2"><code class="inline">!==</code></a>. A float will be considered more precise than an integer, unless the float is greater/less than +/-9007199254740992.0 respectively, at which point all the significant figures of the float are to the left of the decimal point. This behavior exists so that the comparison of large numbers remains transitive.</p> <p>The collection types are compared using the following rules:</p> <ul> <li>Tuples are compared by size, then element by element. </li> <li>Maps are compared by size, then by keys in ascending term order, then by values in key order. In the specific case of maps' key ordering, integers are always considered to be less than floats. </li> <li>Lists are compared element by element. </li> <li>Bitstrings are compared byte by byte, incomplete bytes are compared bit by bit. </li> </ul> <h2 id="custom-and-overridden-operators" class="section-heading">  Custom and overridden operators </h2> <h3 id="defining-custom-operators" class="section-heading">  Defining custom operators </h3> <p>Elixir is capable of parsing a predefined set of operators; this means that it's not possible to define new operators (like one could do in Haskell, for example). However, not all operators that Elixir can parse are <em>used</em> by Elixir: for example, <code class="inline">+</code> and <code class="inline">||</code> are used by Elixir for addition and boolean <em>or</em>, but <code class="inline">&lt;~&gt;</code> is not used (but valid).</p> <p>To define an operator, you can use the usual <code class="inline">def*</code> constructs (<code class="inline">def</code>, <code class="inline">defp</code>, <code class="inline">defmacro</code>, and so on) but with a syntax similar to how the operator is used:</p> <pre data-language="elixir">defmodule MyOperators do
  # We define ~&gt; to return the maximum of the given two numbers,
  # and &lt;~ to return the minimum.

  def a ~&gt; b, do: max(a, b)
  def a &lt;~ b, do: min(a, b)
end</pre> <p>To use the newly defined operators, we <strong>have to</strong> import the module that defines them:</p> <pre data-language="elixir">iex&gt; import MyOperators
iex&gt; 1 ~&gt; 2
2
iex&gt; 1 &lt;~ 2
1</pre> <p>The following is a table of all the operators that Elixir is capable of parsing, but that are not used by default:</p> <ul> <li>
<code class="inline">|</code> </li> <li>
<code class="inline">|||</code> </li> <li>
<code class="inline">&amp;&amp;&amp;</code> </li> <li>
<code class="inline">&lt;&lt;&lt;</code> </li> <li>
<code class="inline">&gt;&gt;&gt;</code> </li> <li>
<code class="inline">&lt;&lt;~</code> </li> <li>
<code class="inline">~&gt;&gt;</code> </li> <li>
<code class="inline">&lt;~</code> </li> <li>
<code class="inline">~&gt;</code> </li> <li>
<code class="inline">&lt;~&gt;</code> </li> <li>
<code class="inline">&lt;|&gt;</code> </li> <li>
<code class="inline">^^^</code> </li> <li>
<code class="inline">~~~</code> </li> </ul> <p>The following operators are used by the <a href="../bitwise/"><code class="inline">Bitwise</code></a> module when imported: <a href="../bitwise/#&amp;&amp;&amp;/2"><code class="inline">&amp;&amp;&amp;</code></a>, <a href="../bitwise/#%255E%255E%255E/2"><code class="inline">^^^</code></a>, <a href="../bitwise/#%253C%253C%253C/2"><code class="inline">&lt;&lt;&lt;</code></a>, <a href="../bitwise/#%253E%253E%253E/2"><code class="inline">&gt;&gt;&gt;</code></a>, <a href="../bitwise/#%257C%257C%257C/2"><code class="inline">|||</code></a>, <a href="../bitwise/#~~~/1"><code class="inline">~~~</code></a>. See the documentation for <a href="../bitwise/"><code class="inline">Bitwise</code></a> for more information.</p> <h3 id="redefining-existing-operators" class="section-heading">  Redefining existing operators </h3> <p>The operators that Elixir uses (for example, <code class="inline">+</code>) can be defined by any module and used in place of the ones defined by Elixir, provided they're specifically not imported from <a href="../kernel/"><code class="inline">Kernel</code></a> (which is imported everywhere by default). For example:</p> <pre data-language="elixir">defmodule WrongMath do
  # Let's make math wrong by changing the meaning of +:
  def a + b, do: a - b
end</pre> <p>Now, we will get an error if we try to use this operator "out of the box":</p> <pre data-language="elixir">iex&gt; import WrongMath
iex&gt; 1 + 2
** (CompileError) iex:11: function +/2 imported from both WrongMath and Kernel, call is ambiguous</pre> <p>So, as mentioned above, we need to explicitly <em>not</em> import <a href="../kernel/#+/2"><code class="inline">+/2</code></a> from <a href="../kernel/"><code class="inline">Kernel</code></a>:</p> <pre data-language="elixir">iex&gt; import WrongMath
iex&gt; import Kernel, except: [+: 2]
iex&gt; 1 + 2
-1</pre> <h3 id="final-note" class="section-heading">  Final note </h3> <p>While it's possible to define unused operators (such as <code class="inline">&lt;~&gt;</code>) and to "override" predefined operators (such as <code class="inline">+</code>), the Elixir community generally discourages this. Custom-defined operators can be really hard to read and even more to understand, as they don't have a descriptive name like functions do. That said, some specific cases or custom domain specific languages (DSLs) may justify these practices.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.9.1/operators.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.9.1/operators.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
