
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Stream - Elixir 1.9 - W3cubDocs</title>
  
  <meta name="description" content=" Functions for creating and composing streams. ">
  <meta name="keywords" content="stream, summary, types, acc, default, element, index, functions, chunk, enum, fun, every, count, step, leftover, while, after, concat, enumerables, first, second, cycle, enumerable, dedup, drop, n, nth, each, filter, flat, map, mapper, intersperse, interval, into, collectable, transform, fn, x, -, end, iterate, start, value, next, reject, repeatedly, generator, resource, run, scan, take, timer, reducer, unfold, uniq, with, offset, zip, left, right, elixir, elixir~1.9">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.9/stream/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/elixir~1.9.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.9/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.9</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1>  Stream  </h1>  <p>Functions for creating and composing streams.</p> <p>Streams are composable, lazy enumerables (for an introduction on enumerables, see the <a href="../enum/"><code class="inline">Enum</code></a> module). Any enumerable that generates elements one by one during enumeration is called a stream. For example, Elixir's <a href="../range/"><code class="inline">Range</code></a> is a stream:</p> <pre data-language="elixir">iex&gt; range = 1..5
1..5
iex&gt; Enum.map(range, &amp;(&amp;1 * 2))
[2, 4, 6, 8, 10]</pre> <p>In the example above, as we mapped over the range, the elements being enumerated were created one by one, during enumeration. The <a href="#content"><code class="inline">Stream</code></a> module allows us to map the range, without triggering its enumeration:</p> <pre data-language="elixir">iex&gt; range = 1..3
iex&gt; stream = Stream.map(range, &amp;(&amp;1 * 2))
iex&gt; Enum.map(stream, &amp;(&amp;1 + 1))
[3, 5, 7]</pre> <p>Notice we started with a range and then we created a stream that is meant to multiply each element in the range by 2. At this point, no computation was done. Only when <a href="../enum/#map/2"><code class="inline">Enum.map/2</code></a> is called we actually enumerate over each element in the range, multiplying it by 2 and adding 1. We say the functions in <a href="#content"><code class="inline">Stream</code></a> are <em>lazy</em> and the functions in <a href="../enum/"><code class="inline">Enum</code></a> are <em>eager</em>.</p> <p>Due to their laziness, streams are useful when working with large (or even infinite) collections. When chaining many operations with <a href="../enum/"><code class="inline">Enum</code></a>, intermediate lists are created, while <a href="#content"><code class="inline">Stream</code></a> creates a recipe of computations that are executed at a later moment. Let's see another example:</p> <pre data-language="elixir">1..3
|&gt; Enum.map(&amp;IO.inspect(&amp;1))
|&gt; Enum.map(&amp;(&amp;1 * 2))
|&gt; Enum.map(&amp;IO.inspect(&amp;1))
1
2
3
2
4
6
#=&gt; [2, 4, 6]</pre> <p>Notice that we first printed each element in the list, then multiplied each element by 2 and finally printed each new value. In this example, the list was enumerated three times. Let's see an example with streams:</p> <pre data-language="elixir">stream = 1..3
|&gt; Stream.map(&amp;IO.inspect(&amp;1))
|&gt; Stream.map(&amp;(&amp;1 * 2))
|&gt; Stream.map(&amp;IO.inspect(&amp;1))
Enum.to_list(stream)
1
2
2
4
3
6
#=&gt; [2, 4, 6]</pre> <p>Although the end result is the same, the order in which the elements were printed changed! With streams, we print the first element and then print its double. In this example, the list was enumerated just once!</p> <p>That's what we meant when we said earlier that streams are composable, lazy enumerables. Notice we could call <a href="../stream/#map/2"><code class="inline">Stream.map/2</code></a> multiple times, effectively composing the streams and keeping them lazy. The computations are only performed when you call a function from the <a href="../enum/"><code class="inline">Enum</code></a> module.</p> <p>Like with <a href="../enum/"><code class="inline">Enum</code></a>, the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list. This is expected on operations such as <a href="../stream/#map/2"><code class="inline">Stream.map/2</code></a>. After all, if we want to traverse every element on a stream, the longer the stream, the more elements we need to traverse, and the longer it will take.</p> <h2 id="module-creating-streams" class="section-heading">  Creating Streams </h2> <p>There are many functions in Elixir's standard library that return streams, some examples are:</p> <ul> <li>
<a href="../io/#stream/2"><code class="inline">IO.stream/2</code></a> - streams input lines, one by one </li> <li>
<a href="../uri/#query_decoder/1"><code class="inline">URI.query_decoder/1</code></a> - decodes a query string, pair by pair </li> </ul> <p>This module also provides many convenience functions for creating streams, like <a href="../stream/#cycle/1"><code class="inline">Stream.cycle/1</code></a>, <a href="../stream/#unfold/2"><code class="inline">Stream.unfold/2</code></a>, <a href="../stream/#resource/3"><code class="inline">Stream.resource/3</code></a> and more.</p> <p>Note the functions in this module are guaranteed to return enumerables. Since enumerables can have different shapes (structs, anonymous functions, and so on), the functions in this module may return any of those shapes and this may change at any time. For example, a function that today returns an anonymous function may return a struct in future releases.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:acc/0">acc()</a> </dt>   <dt class="summary-signature"> <a href="#t:default/0">default()</a> </dt>   <dt class="summary-signature"> <a href="#t:element/0">element()</a> </dt>   <dt class="summary-signature"> <a href="#t:index/0">index()</a> </dt> <dd class="summary-synopsis"><p>Zero-based index.</p></dd>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#chunk_by/2">chunk_by(enum, fun)</a> </dt> <dd class="summary-synopsis"><p>Chunks the <code class="inline">enum</code> by buffering elements for which <code class="inline">fun</code> returns the same value.</p></dd>   <dt class="summary-signature"> <a href="#chunk_every/2">chunk_every(enum, count)</a> </dt> <dd class="summary-synopsis"><p>Shortcut to <code class="inline">chunk_every(enum, count, count)</code>.</p></dd>   <dt class="summary-signature"> <a href="#chunk_every/4">chunk_every(enum, count, step, leftover \\ [])</a> </dt> <dd class="summary-synopsis"><p>Streams the enumerable in chunks, containing <code class="inline">count</code> elements each, where each new chunk starts <code class="inline">step</code> elements into the enumerable.</p></dd>   <dt class="summary-signature"> <a href="#chunk_while/4">chunk_while(enum, acc, chunk_fun, after_fun)</a> </dt> <dd class="summary-synopsis"><p>Chunks the <code class="inline">enum</code> with fine grained control when every chunk is emitted.</p></dd>   <dt class="summary-signature"> <a href="#concat/1">concat(enumerables)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream that enumerates each enumerable in an enumerable.</p></dd>   <dt class="summary-signature"> <a href="#concat/2">concat(first, second)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream that enumerates the first argument, followed by the second.</p></dd>   <dt class="summary-signature"> <a href="#cycle/1">cycle(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream that cycles through the given enumerable, infinitely.</p></dd>   <dt class="summary-signature"> <a href="#dedup/1">dedup(enum)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream that only emits elements if they are different from the last emitted element.</p></dd>   <dt class="summary-signature"> <a href="#dedup_by/2">dedup_by(enum, fun)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream that only emits elements if the result of calling <code class="inline">fun</code> on the element is different from the (stored) result of calling <code class="inline">fun</code> on the last emitted element.</p></dd>   <dt class="summary-signature"> <a href="#drop/2">drop(enum, n)</a> </dt> <dd class="summary-synopsis"><p>Lazily drops the next <code class="inline">n</code> elements from the enumerable.</p></dd>   <dt class="summary-signature"> <a href="#drop_every/2">drop_every(enum, nth)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream that drops every <code class="inline">nth</code> element from the enumerable.</p></dd>   <dt class="summary-signature"> <a href="#drop_while/2">drop_while(enum, fun)</a> </dt> <dd class="summary-synopsis"><p>Lazily drops elements of the enumerable while the given function returns a truthy value.</p></dd>   <dt class="summary-signature"> <a href="#each/2">each(enum, fun)</a> </dt> <dd class="summary-synopsis"><p>Executes the given function for each element.</p></dd>   <dt class="summary-signature"> <a href="#filter/2">filter(enum, fun)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream that filters elements according to the given function on enumeration.</p></dd>   <dt class="summary-signature"> <a href="#flat_map/2">flat_map(enum, mapper)</a> </dt> <dd class="summary-synopsis"><p>Maps the given <code class="inline">fun</code> over <code class="inline">enumerable</code> and flattens the result.</p></dd>   <dt class="summary-signature"> <a href="#intersperse/2">intersperse(enumerable, intersperse_element)</a> </dt> <dd class="summary-synopsis"><p>Lazily intersperses <code class="inline">intersperse_element</code> between each element of the enumeration.</p></dd>   <dt class="summary-signature"> <a href="#interval/1">interval(n)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream that emits a value after the given period <code class="inline">n</code> in milliseconds.</p></dd>   <dt class="summary-signature"> <a href="#into/3">into(enum, collectable, transform \\ fn x -&gt; x end)</a> </dt> <dd class="summary-synopsis"><p>Injects the stream values into the given collectable as a side-effect.</p></dd>   <dt class="summary-signature"> <a href="#iterate/2">iterate(start_value, next_fun)</a> </dt> <dd class="summary-synopsis"><p>Emits a sequence of values, starting with <code class="inline">start_value</code>. Successive values are generated by calling <code class="inline">next_fun</code> on the previous value.</p></dd>   <dt class="summary-signature"> <a href="#map/2">map(enum, fun)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream that will apply the given function on enumeration.</p></dd>   <dt class="summary-signature"> <a href="#map_every/3">map_every(enum, nth, fun)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream that will apply the given function on every <code class="inline">nth</code> element from the enumerable.</p></dd>   <dt class="summary-signature"> <a href="#reject/2">reject(enum, fun)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream that will reject elements according to the given function on enumeration.</p></dd>   <dt class="summary-signature"> <a href="#repeatedly/1">repeatedly(generator_fun)</a> </dt> <dd class="summary-synopsis"><p>Returns a stream generated by calling <code class="inline">generator_fun</code> repeatedly.</p></dd>   <dt class="summary-signature"> <a href="#resource/3">resource(start_fun, next_fun, after_fun)</a> </dt> <dd class="summary-synopsis"><p>Emits a sequence of values for the given resource.</p></dd>   <dt class="summary-signature"> <a href="#run/1">run(stream)</a> </dt> <dd class="summary-synopsis"><p>Runs the given stream.</p></dd>   <dt class="summary-signature"> <a href="#scan/2">scan(enum, fun)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream that applies the given function to each element, emits the result and uses the same result as the accumulator for the next computation. Uses the first element in the enumerable as the starting value.</p></dd>   <dt class="summary-signature"> <a href="#scan/3">scan(enum, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream that applies the given function to each element, emits the result and uses the same result as the accumulator for the next computation. Uses the given <code class="inline">acc</code> as the starting value.</p></dd>   <dt class="summary-signature"> <a href="#take/2">take(enum, count)</a> </dt> <dd class="summary-synopsis"><p>Lazily takes the next <code class="inline">count</code> elements from the enumerable and stops enumeration.</p></dd>   <dt class="summary-signature"> <a href="#take_every/2">take_every(enum, nth)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream that takes every <code class="inline">nth</code> element from the enumerable.</p></dd>   <dt class="summary-signature"> <a href="#take_while/2">take_while(enum, fun)</a> </dt> <dd class="summary-synopsis"><p>Lazily takes elements of the enumerable while the given function returns a truthy value.</p></dd>   <dt class="summary-signature"> <a href="#timer/1">timer(n)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream that emits a single value after <code class="inline">n</code> milliseconds.</p></dd>   <dt class="summary-signature"> <a href="#transform/3">transform(enum, acc, reducer)</a> </dt> <dd class="summary-synopsis"><p>Transforms an existing stream.</p></dd>   <dt class="summary-signature"> <a href="#transform/4">transform(enum, start_fun, reducer, after_fun)</a> </dt> <dd class="summary-synopsis"><p>Transforms an existing stream with function-based start and finish.</p></dd>   <dt class="summary-signature"> <a href="#unfold/2">unfold(next_acc, next_fun)</a> </dt> <dd class="summary-synopsis"><p>Emits a sequence of values for the given accumulator.</p></dd>   <dt class="summary-signature"> <a href="#uniq/1">uniq(enum)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream that only emits elements if they are unique.</p></dd>   <dt class="summary-signature"> <a href="#uniq_by/2">uniq_by(enum, fun)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream that only emits elements if they are unique, by removing the elements for which function <code class="inline">fun</code> returned duplicate elements.</p></dd>   <dt class="summary-signature"> <a href="#with_index/2">with_index(enum, offset \\ 0)</a> </dt> <dd class="summary-synopsis"><p>Creates a stream where each element in the enumerable will be wrapped in a tuple alongside its index.</p></dd>   <dt class="summary-signature"> <a href="#zip/1">zip(enumerables)</a> </dt> <dd class="summary-synopsis"><p>Zips corresponding elements from a finite collection of enumerables into one stream of tuples.</p></dd>   <dt class="summary-signature"> <a href="#zip/2">zip(left, right)</a> </dt> <dd class="summary-synopsis"><p>Zips two collections together, lazily.</p></dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:acc/0">  <h1 class="signature">acc()</h1>     </h3>
<pre data-language="elixir">acc() :: any()</pre>     <h3 class="detail-header type" id="t:default/0">  <h1 class="signature">default()</h1>     </h3>
<pre data-language="elixir">default() :: any()</pre>     <h3 class="detail-header type" id="t:element/0">  <h1 class="signature">element()</h1>     </h3>
<pre data-language="elixir">element() :: any()</pre>     <h3 class="detail-header type" id="t:index/0">  <h1 class="signature">index()</h1>     </h3>
<pre data-language="elixir">index() :: non_neg_integer()</pre>  <p>Zero-based index.</p>      <h1 class="section-heading" id="functions">  Functions </h1>   <h3 class="detail-header function" id="chunk_by/2">  <h1 class="signature">chunk_by(enum, fun)</h1>     </h3>
<pre data-language="elixir">chunk_by(Enumerable.t(), (element() -&gt; any())) :: Enumerable.t()</pre>  <p>Chunks the <code class="inline">enum</code> by buffering elements for which <code class="inline">fun</code> returns the same value.</p> <p>Elements are only emitted when <code class="inline">fun</code> returns a new value or the <code class="inline">enum</code> finishes.</p> <h4 id="chunk_by/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &amp;(rem(&amp;1, 2) == 1))
iex&gt; Enum.to_list(stream)
[[1], [2, 2], [3], [4, 4, 6], [7, 7]]</pre>    <h3 class="detail-header function" id="chunk_every/2">  <h1 class="signature">chunk_every(enum, count)</h1>  <span class="note">(since 1.5.0)</span>    </h3>
<pre data-language="elixir">chunk_every(Enumerable.t(), pos_integer()) :: Enumerable.t()</pre>  <p>Shortcut to <code class="inline">chunk_every(enum, count, count)</code>.</p>     <h3 class="detail-header function" id="chunk_every/4">  <h1 class="signature">chunk_every(enum, count, step, leftover \\ [])</h1>  <span class="note">(since 1.5.0)</span>    </h3>
<pre data-language="elixir">chunk_every(
  Enumerable.t(),
  pos_integer(),
  pos_integer(),
  Enumerable.t() | :discard
) :: Enumerable.t()</pre>  <p>Streams the enumerable in chunks, containing <code class="inline">count</code> elements each, where each new chunk starts <code class="inline">step</code> elements into the enumerable.</p> <p><code class="inline">step</code> is optional and, if not passed, defaults to <code class="inline">count</code>, i.e. chunks do not overlap.</p> <p>If the last chunk does not have <code class="inline">count</code> elements to fill the chunk, elements are taken from <code class="inline">leftover</code> to fill in the chunk. If <code class="inline">leftover</code> does not have enough elements to fill the chunk, then a partial chunk is returned with less than <code class="inline">count</code> elements.</p> <p>If <code class="inline">:discard</code> is given in <code class="inline">leftover</code>, the last chunk is discarded unless it has exactly <code class="inline">count</code> elements.</p> <h4 id="chunk_every/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Stream.chunk_every([1, 2, 3, 4, 5, 6], 2) |&gt; Enum.to_list()
[[1, 2], [3, 4], [5, 6]]

iex&gt; Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, :discard) |&gt; Enum.to_list()
[[1, 2, 3], [3, 4, 5]]

iex&gt; Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, [7]) |&gt; Enum.to_list()
[[1, 2, 3], [3, 4, 5], [5, 6, 7]]

iex&gt; Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 3, []) |&gt; Enum.to_list()
[[1, 2, 3], [4, 5, 6]]</pre>    <h3 class="detail-header function" id="chunk_while/4">  <h1 class="signature">chunk_while(enum, acc, chunk_fun, after_fun)</h1>  <span class="note">(since 1.5.0)</span>    </h3>
<pre data-language="elixir">chunk_while(
  Enumerable.t(),
  acc(),
  (element(), acc() -&gt;
     {:cont, chunk, acc()} | {:cont, acc()} | {:halt, acc()}),
  (acc() -&gt; {:cont, chunk, acc()} | {:cont, acc()})
) :: Enumerable.t()
when chunk: any()</pre>  <p>Chunks the <code class="inline">enum</code> with fine grained control when every chunk is emitted.</p> <p><code class="inline">chunk_fun</code> receives the current element and the accumulator and must return <code class="inline">{:cont, element, acc}</code> to emit the given chunk and continue with accumulator or <code class="inline">{:cont, acc}</code> to not emit any chunk and continue with the return accumulator.</p> <p><code class="inline">after_fun</code> is invoked when iteration is done and must also return <code class="inline">{:cont, element, acc}</code> or <code class="inline">{:cont, acc}</code>.</p> <h4 id="chunk_while/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; chunk_fun = fn element, acc -&gt;
...&gt;   if rem(element, 2) == 0 do
...&gt;     {:cont, Enum.reverse([element | acc]), []}
...&gt;   else
...&gt;     {:cont, [element | acc]}
...&gt;   end
...&gt; end
iex&gt; after_fun = fn
...&gt;   [] -&gt; {:cont, []}
...&gt;   acc -&gt; {:cont, Enum.reverse(acc), []}
...&gt; end
iex&gt; stream = Stream.chunk_while(1..10, [], chunk_fun, after_fun)
iex&gt; Enum.to_list(stream)
[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]</pre>    <h3 class="detail-header function" id="concat/1">  <h1 class="signature">concat(enumerables)</h1>     </h3>
<pre data-language="elixir">concat(Enumerable.t()) :: Enumerable.t()</pre>  <p>Creates a stream that enumerates each enumerable in an enumerable.</p> <h4 id="concat/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.concat([1..3, 4..6, 7..9])
iex&gt; Enum.to_list(stream)
[1, 2, 3, 4, 5, 6, 7, 8, 9]</pre>    <h3 class="detail-header function" id="concat/2">  <h1 class="signature">concat(first, second)</h1>     </h3>
<pre data-language="elixir">concat(Enumerable.t(), Enumerable.t()) :: Enumerable.t()</pre>  <p>Creates a stream that enumerates the first argument, followed by the second.</p> <h4 id="concat/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.concat(1..3, 4..6)
iex&gt; Enum.to_list(stream)
[1, 2, 3, 4, 5, 6]

iex&gt; stream1 = Stream.cycle([1, 2, 3])
iex&gt; stream2 = Stream.cycle([4, 5, 6])
iex&gt; stream = Stream.concat(stream1, stream2)
iex&gt; Enum.take(stream, 6)
[1, 2, 3, 1, 2, 3]</pre>    <h3 class="detail-header function" id="cycle/1">  <h1 class="signature">cycle(enumerable)</h1>     </h3>
<pre data-language="elixir">cycle(Enumerable.t()) :: Enumerable.t()</pre>  <p>Creates a stream that cycles through the given enumerable, infinitely.</p> <h4 id="cycle/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.cycle([1, 2, 3])
iex&gt; Enum.take(stream, 5)
[1, 2, 3, 1, 2]</pre>    <h3 class="detail-header function" id="dedup/1">  <h1 class="signature">dedup(enum)</h1>     </h3>
<pre data-language="elixir">dedup(Enumerable.t()) :: Enumerable.t()</pre>  <p>Creates a stream that only emits elements if they are different from the last emitted element.</p> <p>This function only ever needs to store the last emitted element.</p> <p>Elements are compared using <a href="../kernel/#===/2"><code class="inline">===/2</code></a>.</p> <h4 id="dedup/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Stream.dedup([1, 2, 3, 3, 2, 1]) |&gt; Enum.to_list()
[1, 2, 3, 2, 1]</pre>    <h3 class="detail-header function" id="dedup_by/2">  <h1 class="signature">dedup_by(enum, fun)</h1>     </h3>
<pre data-language="elixir">dedup_by(Enumerable.t(), (element() -&gt; term())) :: Enumerable.t()</pre>  <p>Creates a stream that only emits elements if the result of calling <code class="inline">fun</code> on the element is different from the (stored) result of calling <code class="inline">fun</code> on the last emitted element.</p> <h4 id="dedup_by/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Stream.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -&gt; x end) |&gt; Enum.to_list()
[{1, :x}, {2, :y}, {1, :x}]</pre>    <h3 class="detail-header function" id="drop/2">  <h1 class="signature">drop(enum, n)</h1>     </h3>
<pre data-language="elixir">drop(Enumerable.t(), integer()) :: Enumerable.t()</pre>  <p>Lazily drops the next <code class="inline">n</code> elements from the enumerable.</p> <p>If a negative <code class="inline">n</code> is given, it will drop the last <code class="inline">n</code> elements from the collection. Note that the mechanism by which this is implemented will delay the emission of any element until <code class="inline">n</code> additional elements have been emitted by the enum.</p> <h4 id="drop/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.drop(1..10, 5)
iex&gt; Enum.to_list(stream)
[6, 7, 8, 9, 10]

iex&gt; stream = Stream.drop(1..10, -5)
iex&gt; Enum.to_list(stream)
[1, 2, 3, 4, 5]</pre>    <h3 class="detail-header function" id="drop_every/2">  <h1 class="signature">drop_every(enum, nth)</h1>     </h3>
<pre data-language="elixir">drop_every(Enumerable.t(), non_neg_integer()) :: Enumerable.t()</pre>  <p>Creates a stream that drops every <code class="inline">nth</code> element from the enumerable.</p> <p>The first element is always dropped, unless <code class="inline">nth</code> is 0.</p> <p><code class="inline">nth</code> must be a non-negative integer.</p> <h4 id="drop_every/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.drop_every(1..10, 2)
iex&gt; Enum.to_list(stream)
[2, 4, 6, 8, 10]

iex&gt; stream = Stream.drop_every(1..1000, 1)
iex&gt; Enum.to_list(stream)
[]

iex&gt; stream = Stream.drop_every([1, 2, 3, 4, 5], 0)
iex&gt; Enum.to_list(stream)
[1, 2, 3, 4, 5]</pre>    <h3 class="detail-header function" id="drop_while/2">  <h1 class="signature">drop_while(enum, fun)</h1>     </h3>
<pre data-language="elixir">drop_while(Enumerable.t(), (element() -&gt; as_boolean(term()))) :: Enumerable.t()</pre>  <p>Lazily drops elements of the enumerable while the given function returns a truthy value.</p> <h4 id="drop_while/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.drop_while(1..10, &amp;(&amp;1 &lt;= 5))
iex&gt; Enum.to_list(stream)
[6, 7, 8, 9, 10]</pre>    <h3 class="detail-header function" id="each/2">  <h1 class="signature">each(enum, fun)</h1>     </h3>
<pre data-language="elixir">each(Enumerable.t(), (element() -&gt; term())) :: Enumerable.t()</pre>  <p>Executes the given function for each element.</p> <p>Useful for adding side effects (like printing) to a stream.</p> <h4 id="each/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.each([1, 2, 3], fn x -&gt; send(self(), x) end)
iex&gt; Enum.to_list(stream)
iex&gt; receive do: (x when is_integer(x) -&gt; x)
1
iex&gt; receive do: (x when is_integer(x) -&gt; x)
2
iex&gt; receive do: (x when is_integer(x) -&gt; x)
3</pre>    <h3 class="detail-header function" id="filter/2">  <h1 class="signature">filter(enum, fun)</h1>     </h3>
<pre data-language="elixir">filter(Enumerable.t(), (element() -&gt; as_boolean(term()))) :: Enumerable.t()</pre>  <p>Creates a stream that filters elements according to the given function on enumeration.</p> <h4 id="filter/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.filter([1, 2, 3], fn x -&gt; rem(x, 2) == 0 end)
iex&gt; Enum.to_list(stream)
[2]</pre>    <h3 class="detail-header function" id="flat_map/2">  <h1 class="signature">flat_map(enum, mapper)</h1>     </h3>
<pre data-language="elixir">flat_map(Enumerable.t(), (element() -&gt; Enumerable.t())) :: Enumerable.t()</pre>  <p>Maps the given <code class="inline">fun</code> over <code class="inline">enumerable</code> and flattens the result.</p> <p>This function returns a new stream built by appending the result of invoking <code class="inline">fun</code> on each element of <code class="inline">enumerable</code> together.</p> <h4 id="flat_map/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.flat_map([1, 2, 3], fn x -&gt; [x, x * 2] end)
iex&gt; Enum.to_list(stream)
[1, 2, 2, 4, 3, 6]

iex&gt; stream = Stream.flat_map([1, 2, 3], fn x -&gt; [[x]] end)
iex&gt; Enum.to_list(stream)
[[1], [2], [3]]</pre>    <h3 class="detail-header function" id="intersperse/2">  <h1 class="signature">intersperse(enumerable, intersperse_element)</h1>  <span class="note">(since 1.6.0)</span>    </h3>
<pre data-language="elixir">intersperse(Enumerable.t(), any()) :: Enumerable.t()</pre>  <p>Lazily intersperses <code class="inline">intersperse_element</code> between each element of the enumeration.</p> <h4 id="intersperse/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Stream.intersperse([1, 2, 3], 0) |&gt; Enum.to_list()
[1, 0, 2, 0, 3]

iex&gt; Stream.intersperse([1], 0) |&gt; Enum.to_list()
[1]

iex&gt; Stream.intersperse([], 0) |&gt; Enum.to_list()
[]</pre>    <h3 class="detail-header function" id="interval/1">  <h1 class="signature">interval(n)</h1>     </h3>
<pre data-language="elixir">interval(non_neg_integer()) :: Enumerable.t()</pre>  <p>Creates a stream that emits a value after the given period <code class="inline">n</code> in milliseconds.</p> <p>The values emitted are an increasing counter starting at <code class="inline">0</code>. This operation will block the caller by the given interval every time a new element is streamed.</p> <p>Do not use this function to generate a sequence of numbers. If blocking the caller process is not necessary, use <code class="inline">Stream.iterate(0, &amp; &amp;1 + 1)</code> instead.</p> <h4 id="interval/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Stream.interval(10) |&gt; Enum.take(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</pre>     <h3 class="detail-header function" id="into/3">  <h1 class="signature">into(enum, collectable, transform \\ fn x -&gt; x end)</h1>     </h3>
<pre data-language="elixir">into(Enumerable.t(), Collectable.t(), (term() -&gt; term())) :: Enumerable.t()</pre>  <p>Injects the stream values into the given collectable as a side-effect.</p> <p>This function is often used with <a href="#run/1"><code class="inline">run/1</code></a> since any evaluation is delayed until the stream is executed. See <a href="#run/1"><code class="inline">run/1</code></a> for an example.</p>    <h3 class="detail-header function" id="iterate/2">  <h1 class="signature">iterate(start_value, next_fun)</h1>     </h3>
<pre data-language="elixir">iterate(element(), (element() -&gt; element())) :: Enumerable.t()</pre>  <p>Emits a sequence of values, starting with <code class="inline">start_value</code>. Successive values are generated by calling <code class="inline">next_fun</code> on the previous value.</p> <h4 id="iterate/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Stream.iterate(0, &amp;(&amp;1 + 1)) |&gt; Enum.take(5)
[0, 1, 2, 3, 4]</pre>    <h3 class="detail-header function" id="map/2">  <h1 class="signature">map(enum, fun)</h1>     </h3>
<pre data-language="elixir">map(Enumerable.t(), (element() -&gt; any())) :: Enumerable.t()</pre>  <p>Creates a stream that will apply the given function on enumeration.</p> <h4 id="map/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.map([1, 2, 3], fn x -&gt; x * 2 end)
iex&gt; Enum.to_list(stream)
[2, 4, 6]</pre>    <h3 class="detail-header function" id="map_every/3">  <h1 class="signature">map_every(enum, nth, fun)</h1>  <span class="note">(since 1.4.0)</span>    </h3>
<pre data-language="elixir">map_every(Enumerable.t(), non_neg_integer(), (element() -&gt; any())) ::
  Enumerable.t()</pre>  <p>Creates a stream that will apply the given function on every <code class="inline">nth</code> element from the enumerable.</p> <p>The first element is always passed to the given function.</p> <p><code class="inline">nth</code> must be a non-negative integer.</p> <h4 id="map_every/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.map_every(1..10, 2, fn x -&gt; x * 2 end)
iex&gt; Enum.to_list(stream)
[2, 2, 6, 4, 10, 6, 14, 8, 18, 10]

iex&gt; stream = Stream.map_every([1, 2, 3, 4, 5], 1, fn x -&gt; x * 2 end)
iex&gt; Enum.to_list(stream)
[2, 4, 6, 8, 10]

iex&gt; stream = Stream.map_every(1..5, 0, fn x -&gt; x * 2 end)
iex&gt; Enum.to_list(stream)
[1, 2, 3, 4, 5]</pre>    <h3 class="detail-header function" id="reject/2">  <h1 class="signature">reject(enum, fun)</h1>     </h3>
<pre data-language="elixir">reject(Enumerable.t(), (element() -&gt; as_boolean(term()))) :: Enumerable.t()</pre>  <p>Creates a stream that will reject elements according to the given function on enumeration.</p> <h4 id="reject/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.reject([1, 2, 3], fn x -&gt; rem(x, 2) == 0 end)
iex&gt; Enum.to_list(stream)
[1, 3]</pre>    <h3 class="detail-header function" id="repeatedly/1">  <h1 class="signature">repeatedly(generator_fun)</h1>     </h3>
<pre data-language="elixir">repeatedly((() -&gt; element())) :: Enumerable.t()</pre>  <p>Returns a stream generated by calling <code class="inline">generator_fun</code> repeatedly.</p> <h4 id="repeatedly/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Although not necessary, let's seed the random algorithm
iex&gt; :rand.seed(:exsplus, {1, 2, 3})
iex&gt; Stream.repeatedly(&amp;:rand.uniform/0) |&gt; Enum.take(3)
[0.40502929729990744, 0.45336720247823126, 0.04094511692041057]</pre>    <h3 class="detail-header function" id="resource/3">  <h1 class="signature">resource(start_fun, next_fun, after_fun)</h1>     </h3>
<pre data-language="elixir">resource(
  (() -&gt; acc()),
  (acc() -&gt; {[element()], acc()} | {:halt, acc()}),
  (acc() -&gt; term())
) :: Enumerable.t()</pre>  <p>Emits a sequence of values for the given resource.</p> <p>Similar to <a href="#transform/3"><code class="inline">transform/3</code></a> but the initial accumulated value is computed lazily via <code class="inline">start_fun</code> and executes an <code class="inline">after_fun</code> at the end of enumeration (both in cases of success and failure).</p> <p>Successive values are generated by calling <code class="inline">next_fun</code> with the previous accumulator (the initial value being the result returned by <code class="inline">start_fun</code>) and it must return a tuple containing a list of elements to be emitted and the next accumulator. The enumeration finishes if it returns <code class="inline">{:halt, acc}</code>.</p> <p>As the name says, this function is useful to stream values from resources.</p> <h4 id="resource/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Stream.resource(
  fn -&gt; File.open!("sample") end,
  fn file -&gt;
    case IO.read(file, :line) do
      data when is_binary(data) -&gt; {[data], file}
      _ -&gt; {:halt, file}
    end
  end,
  fn file -&gt; File.close(file) end
)</pre>    <h3 class="detail-header function" id="run/1">  <h1 class="signature">run(stream)</h1>     </h3>
<pre data-language="elixir">run(Enumerable.t()) :: :ok</pre>  <p>Runs the given stream.</p> <p>This is useful when a stream needs to be run, for side effects, and there is no interest in its return result.</p> <h4 id="run/1-examples" class="section-heading">  Examples </h4> <p>Open up a file, replace all <code class="inline">#</code> by <code class="inline">%</code> and stream to another file without loading the whole file in memory:</p> <pre data-language="elixir">File.stream!("/path/to/file")
|&gt; Stream.map(&amp;String.replace(&amp;1, "#", "%"))
|&gt; Stream.into(File.stream!("/path/to/other/file"))
|&gt; Stream.run()</pre> <p>No computation will be done until we call one of the <a href="../enum/"><code class="inline">Enum</code></a> functions or <a href="#run/1"><code class="inline">run/1</code></a>.</p>    <h3 class="detail-header function" id="scan/2">  <h1 class="signature">scan(enum, fun)</h1>     </h3>
<pre data-language="elixir">scan(Enumerable.t(), (element(), acc() -&gt; any())) :: Enumerable.t()</pre>  <p>Creates a stream that applies the given function to each element, emits the result and uses the same result as the accumulator for the next computation. Uses the first element in the enumerable as the starting value.</p> <h4 id="scan/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.scan(1..5, &amp;(&amp;1 + &amp;2))
iex&gt; Enum.to_list(stream)
[1, 3, 6, 10, 15]</pre>    <h3 class="detail-header function" id="scan/3">  <h1 class="signature">scan(enum, acc, fun)</h1>     </h3>
<pre data-language="elixir">scan(Enumerable.t(), acc(), (element(), acc() -&gt; any())) :: Enumerable.t()</pre>  <p>Creates a stream that applies the given function to each element, emits the result and uses the same result as the accumulator for the next computation. Uses the given <code class="inline">acc</code> as the starting value.</p> <h4 id="scan/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.scan(1..5, 0, &amp;(&amp;1 + &amp;2))
iex&gt; Enum.to_list(stream)
[1, 3, 6, 10, 15]</pre>    <h3 class="detail-header function" id="take/2">  <h1 class="signature">take(enum, count)</h1>     </h3>
<pre data-language="elixir">take(Enumerable.t(), integer()) :: Enumerable.t()</pre>  <p>Lazily takes the next <code class="inline">count</code> elements from the enumerable and stops enumeration.</p> <p>If a negative <code class="inline">count</code> is given, the last <code class="inline">count</code> values will be taken. For such, the collection is fully enumerated keeping up to <code class="inline">2 * count</code> elements in memory. Once the end of the collection is reached, the last <code class="inline">count</code> elements will be executed. Therefore, using a negative <code class="inline">count</code> on an infinite collection will never return.</p> <h4 id="take/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.take(1..100, 5)
iex&gt; Enum.to_list(stream)
[1, 2, 3, 4, 5]

iex&gt; stream = Stream.take(1..100, -5)
iex&gt; Enum.to_list(stream)
[96, 97, 98, 99, 100]

iex&gt; stream = Stream.cycle([1, 2, 3]) |&gt; Stream.take(5)
iex&gt; Enum.to_list(stream)
[1, 2, 3, 1, 2]</pre>    <h3 class="detail-header function" id="take_every/2">  <h1 class="signature">take_every(enum, nth)</h1>     </h3>
<pre data-language="elixir">take_every(Enumerable.t(), non_neg_integer()) :: Enumerable.t()</pre>  <p>Creates a stream that takes every <code class="inline">nth</code> element from the enumerable.</p> <p>The first element is always included, unless <code class="inline">nth</code> is 0.</p> <p><code class="inline">nth</code> must be a non-negative integer.</p> <h4 id="take_every/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.take_every(1..10, 2)
iex&gt; Enum.to_list(stream)
[1, 3, 5, 7, 9]

iex&gt; stream = Stream.take_every([1, 2, 3, 4, 5], 1)
iex&gt; Enum.to_list(stream)
[1, 2, 3, 4, 5]

iex&gt; stream = Stream.take_every(1..1000, 0)
iex&gt; Enum.to_list(stream)
[]</pre>    <h3 class="detail-header function" id="take_while/2">  <h1 class="signature">take_while(enum, fun)</h1>     </h3>
<pre data-language="elixir">take_while(Enumerable.t(), (element() -&gt; as_boolean(term()))) :: Enumerable.t()</pre>  <p>Lazily takes elements of the enumerable while the given function returns a truthy value.</p> <h4 id="take_while/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.take_while(1..100, &amp;(&amp;1 &lt;= 5))
iex&gt; Enum.to_list(stream)
[1, 2, 3, 4, 5]</pre>    <h3 class="detail-header function" id="timer/1">  <h1 class="signature">timer(n)</h1>     </h3>
<pre data-language="elixir">timer(non_neg_integer()) :: Enumerable.t()</pre>  <p>Creates a stream that emits a single value after <code class="inline">n</code> milliseconds.</p> <p>The value emitted is <code class="inline">0</code>. This operation will block the caller by the given time until the element is streamed.</p> <h4 id="timer/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Stream.timer(10) |&gt; Enum.to_list()
[0]</pre>    <h3 class="detail-header function" id="transform/3">  <h1 class="signature">transform(enum, acc, reducer)</h1>     </h3>
<pre data-language="elixir">transform(Enumerable.t(), acc, fun) :: Enumerable.t()
when fun: (element(), acc -&gt; {Enumerable.t(), acc} | {:halt, acc}), acc: any()</pre>  <p>Transforms an existing stream.</p> <p>It expects an accumulator and a function that receives each stream element and an accumulator, and must return a tuple containing a new stream (often a list) with the new accumulator or a tuple with <code class="inline">:halt</code> as first element and the accumulator as second.</p> <p>Note: this function is similar to <a href="../enum/#flat_map_reduce/3"><code class="inline">Enum.flat_map_reduce/3</code></a> except the latter returns both the flat list and accumulator, while this one returns only the stream.</p> <h4 id="transform/3-examples" class="section-heading">  Examples </h4> <p><a href="../stream/#transform/3"><code class="inline">Stream.transform/3</code></a> is useful as it can be used as the basis to implement many of the functions defined in this module. For example, we can implement <code class="inline">Stream.take(enum, n)</code> as follows:</p> <pre data-language="elixir">iex&gt; enum = 1..100
iex&gt; n = 3
iex&gt; stream = Stream.transform(enum, 0, fn i, acc -&gt;
...&gt;   if acc &lt; n, do: {[i], acc + 1}, else: {:halt, acc}
...&gt; end)
iex&gt; Enum.to_list(stream)
[1, 2, 3]</pre>    <h3 class="detail-header function" id="transform/4">  <h1 class="signature">transform(enum, start_fun, reducer, after_fun)</h1>     </h3>
<pre data-language="elixir">transform(Enumerable.t(), (() -&gt; acc), fun, (acc -&gt; term())) :: Enumerable.t()
when fun: (element(), acc -&gt; {Enumerable.t(), acc} | {:halt, acc}), acc: any()</pre>  <p>Transforms an existing stream with function-based start and finish.</p> <p>The accumulator is only calculated when transformation starts. It also allows an after function to be given which is invoked when the stream halts or completes.</p> <p>This function can be seen as a combination of <a href="../stream/#resource/3"><code class="inline">Stream.resource/3</code></a> with <a href="../stream/#transform/3"><code class="inline">Stream.transform/3</code></a>.</p>    <h3 class="detail-header function" id="unfold/2">  <h1 class="signature">unfold(next_acc, next_fun)</h1>     </h3>
<pre data-language="elixir">unfold(acc(), (acc() -&gt; {element(), acc()} | nil)) :: Enumerable.t()</pre>  <p>Emits a sequence of values for the given accumulator.</p> <p>Successive values are generated by calling <code class="inline">next_fun</code> with the previous accumulator and it must return a tuple with the current value and next accumulator. The enumeration finishes if it returns <code class="inline">nil</code>.</p> <h4 id="unfold/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Stream.unfold(5, fn
...&gt;   0 -&gt; nil
...&gt;   n -&gt; {n, n - 1}
...&gt; end) |&gt; Enum.to_list()
[5, 4, 3, 2, 1]</pre>    <h3 class="detail-header function" id="uniq/1">  <h1 class="signature">uniq(enum)</h1>     </h3>
<pre data-language="elixir">uniq(Enumerable.t()) :: Enumerable.t()</pre>  <p>Creates a stream that only emits elements if they are unique.</p> <p>Keep in mind that, in order to know if an element is unique or not, this function needs to store all unique values emitted by the stream. Therefore, if the stream is infinite, the number of elements stored will grow infinitely, never being garbage-collected.</p> <h4 id="uniq/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Stream.uniq([1, 2, 3, 3, 2, 1]) |&gt; Enum.to_list()
[1, 2, 3]</pre>    <h3 class="detail-header function" id="uniq_by/2">  <h1 class="signature">uniq_by(enum, fun)</h1>     </h3>
<pre data-language="elixir">uniq_by(Enumerable.t(), (element() -&gt; term())) :: Enumerable.t()</pre>  <p>Creates a stream that only emits elements if they are unique, by removing the elements for which function <code class="inline">fun</code> returned duplicate elements.</p> <p>The function <code class="inline">fun</code> maps every element to a term which is used to determine if two elements are duplicates.</p> <p>Keep in mind that, in order to know if an element is unique or not, this function needs to store all unique values emitted by the stream. Therefore, if the stream is infinite, the number of elements stored will grow infinitely, never being garbage-collected.</p> <h4 id="uniq_by/2-example" class="section-heading">  Example </h4> <pre data-language="elixir">iex&gt; Stream.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -&gt; x end) |&gt; Enum.to_list()
[{1, :x}, {2, :y}]

iex&gt; Stream.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -&gt; y end) |&gt; Enum.to_list()
[a: {:tea, 2}, c: {:coffee, 1}]</pre>     <h3 class="detail-header function" id="with_index/2">  <h1 class="signature">with_index(enum, offset \\ 0)</h1>     </h3>
<pre data-language="elixir">with_index(Enumerable.t(), integer()) :: Enumerable.t()</pre>  <p>Creates a stream where each element in the enumerable will be wrapped in a tuple alongside its index.</p> <p>If an <code class="inline">offset</code> is given, we will index from the given offset instead of from zero.</p> <h4 id="with_index/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; stream = Stream.with_index([1, 2, 3])
iex&gt; Enum.to_list(stream)
[{1, 0}, {2, 1}, {3, 2}]

iex&gt; stream = Stream.with_index([1, 2, 3], 3)
iex&gt; Enum.to_list(stream)
[{1, 3}, {2, 4}, {3, 5}]</pre>    <h3 class="detail-header function" id="zip/1">  <h1 class="signature">zip(enumerables)</h1>  <span class="note">(since 1.4.0)</span>    </h3>
<pre data-language="elixir">zip(enumerables) :: Enumerable.t()
when enumerables: [Enumerable.t()] | Enumerable.t()</pre>  <p>Zips corresponding elements from a finite collection of enumerables into one stream of tuples.</p> <p>The zipping finishes as soon as any enumerable in the given collection completes.</p> <h4 id="zip/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; concat = Stream.concat(1..3, 4..6)
iex&gt; cycle = Stream.cycle(["foo", "bar", "baz"])
iex&gt; Stream.zip([concat, [:a, :b, :c], cycle]) |&gt; Enum.to_list()
[{1, :a, "foo"}, {2, :b, "bar"}, {3, :c, "baz"}]</pre>    <h3 class="detail-header function" id="zip/2">  <h1 class="signature">zip(left, right)</h1>     </h3>
<pre data-language="elixir">zip(Enumerable.t(), Enumerable.t()) :: Enumerable.t()</pre>  <p>Zips two collections together, lazily.</p> <p>The zipping finishes as soon as any enumerable completes.</p> <h4 id="zip/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; concat = Stream.concat(1..3, 4..6)
iex&gt; cycle = Stream.cycle([:a, :b, :c])
iex&gt; Stream.zip(concat, cycle) |&gt; Enum.to_list()
[{1, :a}, {2, :b}, {3, :c}, {4, :a}, {5, :b}, {6, :c}]</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.9.1/Stream.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.9.1/Stream.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
