
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Phoenix.HTML.Form - Phoenix - W3cubDocs</title>
  
  <meta name="description" content=" Helpers related to producing HTML forms. ">
  <meta name="keywords" content="phoenix, html, form, summary, types, functions, -">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/phoenix/phoenix_html/phoenix.html.form/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/phoenix.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/phoenix/" class="_nav-link" title="" style="margin-left:0;">Phoenix</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1>  Phoenix.HTML.Form  </h1>  <p>Helpers related to producing HTML forms.</p> <p>The functions in this module can be used in three distinct scenarios:</p> <ul> <li>
<p>with changeset data - when information to populate the form comes from a changeset</p> </li> <li>
<p>with connection data - when a form is created based on the information in the connection (aka <a href="../../plug/1.5.0/plug.conn/"><code class="inline">Plug.Conn</code></a>)</p> </li> <li>
<p>without form data - when the functions are used directly, outside of a form</p> </li> </ul> <p>We will explore all three scenarios below.</p> <h2 id="module-with-changeset-data" class="section-heading">  With changeset data </h2> <p>The entry point for defining forms in Phoenix is with the <a href="#form_for/4"><code class="inline">form_for/4</code></a> function. For this example, we will use <code class="inline">Ecto.Changeset</code>, which integrates nicely with Phoenix forms via the <code class="inline">phoenix_ecto</code> package.</p> <p>Imagine you have the following action in your controller:</p> <pre data-language="elixir">def new(conn, _params) do
  changeset = User.changeset(%User{})
  render conn, "new.html", changeset: changeset
end</pre> <p>where <code class="inline">User.changeset/2</code> is defined as follows:</p> <pre data-language="elixir">def changeset(user, params \\ %{}) do
  cast(user, params, [:name, :age])
end</pre> <p>Now a <code class="inline">@changeset</code> assign is available in views which we can pass to the form:</p> <pre data-language="elixir">&lt;%= form_for @changeset, user_path(@conn, :create), fn f -&gt; %&gt;
  &lt;label&gt;
    Name: &lt;%= text_input f, :name %&gt;
  &lt;/label&gt;

  &lt;label&gt;
    Age: &lt;%= select f, :age, 18..100 %&gt;
  &lt;/label&gt;

  &lt;%= submit "Submit" %&gt;
&lt;% end %&gt;</pre> <p><a href="#form_for/4"><code class="inline">form_for/4</code></a> receives the <code class="inline">Ecto.Changeset</code> and converts it to a form, which is passed to the function as the argument <code class="inline">f</code>. All the remaining functions in this module receive the form and automatically generate the input fields, often by extracting information from the given changeset. For example, if the user had a default value for age set, it will automatically show up as selected in the form.</p> <h4>A note on <code class="inline">:errors</code>
</h4> <p>If no action has been applied to the changeset or action was set to <code class="inline">:ignore</code>, no errors are shown on the form object even if the changeset has a non-empty <code class="inline">:errors</code> value.</p> <p>This is useful for things like validation hints on form fields, e.g. an empty changeset for a new form. That changeset isn’t valid, but we don’t want to show errors until an actual user action has been performed.</p> <p>Ecto automatically applies the action for you when you call Repo.insert/update/delete, but if you want to show errors manually you can also set the action yourself, either directly on the <code class="inline">Ecto.Changeset</code> struct field or by using <code class="inline">Ecto.Changeset.apply_action/2</code>.</p> <h2 id="module-with-connection-data" class="section-heading">  With connection data </h2> <p><a href="#form_for/4"><code class="inline">form_for/4</code></a> expects as first argument any data structure that implements the <a href="../phoenix.html.formdata/"><code class="inline">Phoenix.HTML.FormData</code></a> protocol. By default, Phoenix implements this protocol for <a href="../../plug/1.5.0/plug.conn/"><code class="inline">Plug.Conn</code></a>, allowing us to create forms based only on connection information.</p> <p>This is useful when you are creating forms that are not backed by any kind of data from the data layer, like a search form.</p> <pre data-language="elixir">&lt;%= form_for @conn, search_path(@conn, :new), [as: :search], fn f -&gt; %&gt;
  &lt;%= text_input f, :for %&gt;
  &lt;%= submit "Search" %&gt;
&lt;% end %&gt;</pre> <p><a href="#form_for/4"><code class="inline">form_for/4</code></a> uses the <a href="../../plug/1.5.0/plug.conn/"><code class="inline">Plug.Conn</code></a> to set input values from the request parameters. In this case, the input’s value would be set to <code class="inline">@conn.params["search"]["for"]</code>.</p> <h2 id="module-without-form-data" class="section-heading">  Without form data </h2> <p>Sometimes we may want to generate a <a href="#text_input/3"><code class="inline">text_input/3</code></a> or any other tag outside of a form. The functions in this module also support such usage by simply passing an atom as first argument instead of the form.</p> <pre data-language="elixir">&lt;%= text_input :user, :name, value: "This is a prepopulated value" %&gt;</pre> <h2 id="module-nested-inputs" class="section-heading">  Nested inputs </h2> <p>If your data layer supports embedding or nested associations, you can use <code class="inline">inputs_for</code> to attach nested data to the form.</p> <p>Imagine the following Ecto schemas:</p> <pre data-language="elixir">defmodule User do
  use Ecto.Schema

  schema "users" do
    field :name
    embeds_one :permalink, Permalink
  end
end

defmodule Permalink do
  use Ecto.Schema

  embedded_schema do
    field :url
  end
end</pre> <p>In the form, you now can:</p> <pre data-language="elixir">&lt;%= form_for @changeset, user_path(@conn, :create), fn f -&gt; %&gt;
  &lt;%= text_input f, :name %&gt;

  &lt;%= inputs_for f, :permalink, fn fp -&gt; %&gt;
    &lt;%= text_input fp, :url %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;</pre> <p>The default option can be given to populate the fields if none is given:</p> <pre data-language="elixir">&lt;%= inputs_for f, :permalink, [default: %Permalink{title: "default"}], fn fp -&gt; %&gt;
  &lt;%= text_input fp, :url %&gt;
&lt;% end %&gt;</pre> <p><a href="#inputs_for/4"><code class="inline">inputs_for/4</code></a> can be used to work with single entities or collections. When working with collections, <code class="inline">:prepend</code> and <code class="inline">:append</code> can be used to add entries to the collection stored in the changeset.</p> <h2 id="module-csrf-protection" class="section-heading">  CSRF protection </h2> <p>The form generates a CSRF token by default. Your application should check this token on the server to avoid attackers from making requests on your server in behalf of other users. Phoenix by default checks this token.</p> <p>When posting a form with a host in its address, such as “//host.com/path” instead of only “/path”, Phoenix will include the host signature in the token and validate the token only if the accessed host is the same as the host in the token. This is to avoid tokens from leaking to third party applications. If this behaviour is problematic, you can generate a non-host specific token with <a href="../../plug/1.5.0/plug.csrfprotection/#get_csrf_token/0"><code class="inline">Plug.CSRFProtection.get_csrf_token/0</code></a> and pass it to the form generator via the <code class="inline">:csrf_token</code> option.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:field/0">field()</a> </dt>   <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#__struct__/0">%Phoenix.HTML.Form{}</a> </dt> <dd class="summary-synopsis">
<p>Defines the Phoenix.HTML.Form struct</p> </dd>   <dt class="summary-signature"> <a href="#checkbox/3">checkbox(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a checkbox</p> </dd>   <dt class="summary-signature"> <a href="#color_input/3">color_input(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a color input</p> </dd>   <dt class="summary-signature"> <a href="#date_input/3">date_input(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a date input</p> </dd>   <dt class="summary-signature"> <a href="#date_select/3">date_select(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates select tags for date</p> </dd>   <dt class="summary-signature"> <a href="#datetime_local_input/3">datetime_local_input(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a datetime-local input</p> </dd>   <dt class="summary-signature"> <a href="#datetime_select/3">datetime_select(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates select tags for datetime</p> </dd>   <dt class="summary-signature"> <a href="#email_input/3">email_input(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates an email input</p> </dd>   <dt class="summary-signature"> <a href="#file_input/3">file_input(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a file input</p> </dd>   <dt class="summary-signature"> <a href="#form_for/4">form_for(form_data, action, options \\ [], fun)</a> </dt> <dd class="summary-synopsis">
<p>Generates a form tag with a form builder</p> </dd>   <dt class="summary-signature"> <a href="#hidden_input/3">hidden_input(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a hidden input</p> </dd>   <dt class="summary-signature"> <a href="#humanize/1">humanize(atom)</a> </dt> <dd class="summary-synopsis">
<p>Converts an attribute/form field into its humanize version</p> </dd>   <dt class="summary-signature"> <a href="#input_id/2">input_id(name, field)</a> </dt> <dd class="summary-synopsis">
<p>Returns an id of a corresponding form field</p> </dd>   <dt class="summary-signature"> <a href="#input_id/3">input_id(name, field, value)</a> </dt> <dd class="summary-synopsis">
<p>Returns an id of a corresponding form field and value attached to it</p> </dd>   <dt class="summary-signature"> <a href="#input_name/2">input_name(name, field)</a> </dt> <dd class="summary-synopsis">
<p>Returns a name of a corresponding form field</p> </dd>   <dt class="summary-signature"> <a href="#input_type/3">input_type(form, field, mapping \\ %{"email" =&gt; :email_input, "password" =&gt; :password_input, "search" =&gt; :search_input, "url" =&gt; :url_input})</a> </dt> <dd class="summary-synopsis">
<p>Gets the input type for a given field</p> </dd>   <dt class="summary-signature"> <a href="#input_validations/2">input_validations(form, field)</a> </dt> <dd class="summary-synopsis">
<p>Returns the HTML5 validations that would apply to the given field</p> </dd>   <dt class="summary-signature"> <a href="#input_value/2">input_value(form, field)</a> </dt> <dd class="summary-synopsis">
<p>Returns a value of a corresponding form field</p> </dd>   <dt class="summary-signature"> <a href="#inputs_for/4">inputs_for(form, field, options \\ [], fun)</a> </dt> <dd class="summary-synopsis">
<p>Generate a new form builder for the given parameter in form</p> </dd>   <dt class="summary-signature"> <a href="#label/1">label(do_block)</a> </dt> <dd class="summary-synopsis">
<p>Generates a label tag</p> </dd>   <dt class="summary-signature"> <a href="#label/2">label(opts, field)</a> </dt> <dd class="summary-synopsis">
<p>Generates a label tag for the given field</p> </dd>   <dt class="summary-signature"> <a href="#label/3">label(form, field, text_or_do_block_or_attributes)</a> </dt> <dd class="summary-synopsis">
<p>See <a href="#label/2"><code class="inline">label/2</code></a></p> </dd>   <dt class="summary-signature"> <a href="#label/4">label(form, field, text, do_block_or_attributes)</a> </dt> <dd class="summary-synopsis">
<p>See <a href="#label/2"><code class="inline">label/2</code></a></p> </dd>   <dt class="summary-signature"> <a href="#multiple_select/4">multiple_select(form, field, options, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a select tag with the given <code class="inline">options</code></p> </dd>   <dt class="summary-signature"> <a href="#number_input/3">number_input(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a number input</p> </dd>   <dt class="summary-signature"> <a href="#password_input/3">password_input(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a password input</p> </dd>   <dt class="summary-signature"> <a href="#radio_button/4">radio_button(form, field, value, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a radio button</p> </dd>   <dt class="summary-signature"> <a href="#range_input/3">range_input(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a range input</p> </dd>   <dt class="summary-signature"> <a href="#reset/2">reset(value, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a reset input to reset all the form fields to their original state</p> </dd>   <dt class="summary-signature"> <a href="#search_input/3">search_input(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a search input</p> </dd>   <dt class="summary-signature"> <a href="#select/4">select(form, field, options, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a select tag with the given <code class="inline">options</code></p> </dd>   <dt class="summary-signature"> <a href="#submit/1">submit(block_option)</a> </dt> <dd class="summary-synopsis">
<p>Generates a submit button to send the form</p> </dd>   <dt class="summary-signature"> <a href="#submit/2">submit(opts, opts \\ [])</a> </dt>   <dt class="summary-signature"> <a href="#telephone_input/3">telephone_input(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a telephone input</p> </dd>   <dt class="summary-signature"> <a href="#text_input/3">text_input(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a text input</p> </dd>   <dt class="summary-signature"> <a href="#textarea/3">textarea(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a textarea input</p> </dd>   <dt class="summary-signature"> <a href="#time_input/3">time_input(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates a time input</p> </dd>   <dt class="summary-signature"> <a href="#time_select/3">time_select(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates select tags for time</p> </dd>   <dt class="summary-signature"> <a href="#url_input/3">url_input(form, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Generates an url input</p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:field/0">  <span class="signature">field()</span>     </h3>
<pre data-language="elixir">field() :: atom() | String.t()</pre>     <h3 class="detail-header type" id="t:t/0">  <span class="signature">t()</span>     </h3>
<pre data-language="elixir">t() :: %Phoenix.HTML.Form{
  data: %{optional(field()) =&gt; term()},
  errors: Keyword.t(),
  hidden: Keyword.t(),
  id: String.t(),
  impl: module(),
  index: nil | non_neg_integer(),
  name: String.t(),
  options: Keyword.t(),
  params: %{optional(binary()) =&gt; term()},
  source: Phoenix.HTML.FormData.t()
}</pre>       <h1 class="section-heading" id="functions">  Functions </h1>  <h3 class="detail-header function" id="__struct__/0">  <span class="signature">%Phoenix.HTML.Form{}</span>  <span class="note">(struct)</span> </h3>  <p>Defines the Phoenix.HTML.Form struct.</p> <p>Its fields are:</p> <ul> <li>
<p><code class="inline">:source</code> - the data structure given to <a href="#form_for/4"><code class="inline">form_for/4</code></a> that implements the form data protocol</p> </li> <li>
<p><code class="inline">:impl</code> - the module with the form data protocol implementation. This is used to avoid multiple protocol dispatches.</p> </li> <li>
<p><code class="inline">:id</code> - the id to be used when generating input fields</p> </li> <li>
<p><code class="inline">:name</code> - the name to be used when generating input fields</p> </li> <li>
<p><code class="inline">:data</code> - the field used to store lookup data</p> </li> <li>
<p><code class="inline">:params</code> - the parameters associated to this form in case they were sent as part of a previous request</p> </li> <li>
<p><code class="inline">:hidden</code> - a keyword list of fields that are required for submitting the form behind the scenes as hidden inputs</p> </li> <li>
<p><code class="inline">:options</code> - a copy of the options given when creating the form via <a href="#form_for/4"><code class="inline">form_for/4</code></a> without any form data specific key</p> </li> <li>
<p><code class="inline">:errors</code> - a keyword list of errors that associated with the form</p> </li> </ul>     <h3 class="detail-header function" id="checkbox/3">  <span class="signature">checkbox(form, field, opts \\ [])</span>  </h3>  <p>Generates a checkbox.</p> <p>This function is useful for sending boolean values to the server.</p> <h4 id="checkbox/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Assuming form contains a User schema
checkbox(form, :famous)
#=&gt; &lt;input name="user[famous]" type="hidden" value="false"&gt;
    &lt;input checked="checked" id="user_famous" name="user[famous]" type="checkbox" value="true"&gt;</pre> <h4 id="checkbox/3-options" class="section-heading">  Options </h4> <ul> <li>
<p><code class="inline">:checked_value</code> - the value to be sent when the checkbox is checked. Defaults to “true”</p> </li> <li>
<p><code class="inline">:unchecked_value</code> - the value to be sent when the checkbox is unchecked, Defaults to “false”</p> </li> <li>
<p><code class="inline">:value</code> - the value used to check if a checkbox is checked or unchecked. The default value is extracted from the form data if available</p> </li> </ul> <p>All other options are forwarded to the underlying HTML tag.</p> <h4 id="checkbox/3-hidden-fields" class="section-heading">  Hidden fields </h4> <p>Because an unchecked checkbox is not sent to the server, Phoenix automatically generates a hidden field with the unchecked_value <em>before</em> the checkbox field to ensure the <code class="inline">unchecked_value</code> is sent when the checkbox is not marked.</p>     <h3 class="detail-header function" id="color_input/3">  <span class="signature">color_input(form, field, opts \\ [])</span>  </h3>  <p>Generates a color input.</p> <p>Warning: this feature isn’t available in all browsers. Check <code class="inline">http://caniuse.com/#feat=input-color</code> for further informations.</p> <p>See <a href="#text_input/3"><code class="inline">text_input/3</code></a> for example and docs.</p>     <h3 class="detail-header function" id="date_input/3">  <span class="signature">date_input(form, field, opts \\ [])</span>  </h3>  <p>Generates a date input.</p> <p>Warning: this feature isn’t available in all browsers. Check <code class="inline">http://caniuse.com/#feat=input-datetime</code> for further informations.</p> <p>See <a href="#text_input/3"><code class="inline">text_input/3</code></a> for example and docs.</p>     <h3 class="detail-header function" id="date_select/3">  <span class="signature">date_select(form, field, opts \\ [])</span>  </h3>  <p>Generates select tags for date.</p> <p>Check <a href="#datetime_select/3"><code class="inline">datetime_select/3</code></a> for more information on options and supported values.</p>     <h3 class="detail-header function" id="datetime_local_input/3">  <span class="signature">datetime_local_input(form, field, opts \\ [])</span>  </h3>  <p>Generates a datetime-local input.</p> <p>Warning: this feature isn’t available in all browsers. Check <code class="inline">http://caniuse.com/#feat=input-datetime</code> for further informations.</p> <p>See <a href="#text_input/3"><code class="inline">text_input/3</code></a> for example and docs.</p>     <h3 class="detail-header function" id="datetime_select/3">  <span class="signature">datetime_select(form, field, opts \\ [])</span>  </h3>  <p>Generates select tags for datetime.</p> <h4 id="datetime_select/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Assuming form contains a User schema
datetime_select form, :born_at
#=&gt; &lt;select id="user_born_at_year" name="user[born_at][year]"&gt;...&lt;/select&gt; /
    &lt;select id="user_born_at_month" name="user[born_at][month]"&gt;...&lt;/select&gt; /
    &lt;select id="user_born_at_day" name="user[born_at][day]"&gt;...&lt;/select&gt; —
    &lt;select id="user_born_at_hour" name="user[born_at][hour]"&gt;...&lt;/select&gt; :
    &lt;select id="user_born_at_min" name="user[born_at][minute]"&gt;...&lt;/select&gt;</pre> <p>If you want to include the seconds field (hidden by default), pass <code class="inline">second: []</code>:</p> <pre data-language="elixir"># Assuming form contains a User schema
datetime_select form, :born_at, second: []</pre> <p>If you want to configure the years range:</p> <pre data-language="elixir"># Assuming form contains a User schema
datetime_select form, :born_at, year: [options: 1900..2100]</pre> <p>You are also able to configure <code class="inline">:month</code>, <code class="inline">:day</code>, <code class="inline">:hour</code>, <code class="inline">:minute</code> and <code class="inline">:second</code>. All options given to those keys will be forwarded to the underlying select. See <a href="#select/4"><code class="inline">select/4</code></a> for more information.</p> <p>For example, if you are using Phoenix with Gettext and you want to localize the list of months, you can pass <code class="inline">:options</code> to the <code class="inline">:month</code> key:</p> <pre data-language="elixir"># Assuming form contains a User schema
datetime_select form, :born_at, month: [
  options: [
    {gettext("January"), "1"},
    {gettext("February"), "2"},
    {gettext("March"), "3"},
    {gettext("April"), "4"},
    {gettext("May"), "5"},
    {gettext("June"), "6"},
    {gettext("July"), "7"},
    {gettext("August"), "8"},
    {gettext("September"), "9"},
    {gettext("October"), "10"},
    {gettext("November"), "11"},
    {gettext("December"), "12"},
  ]
]</pre> <p>You may even provide your own <code class="inline">localized_datetime_select/3</code> built on top of <a href="#datetime_select/3"><code class="inline">datetime_select/3</code></a>:</p> <pre data-language="elixir">defp localized_datetime_select(form, field, opts \\ []) do
  opts =
    Keyword.put(opts, :month, options: [
      {gettext("January"), "1"},
      {gettext("February"), "2"},
      {gettext("March"), "3"},
      {gettext("April"), "4"},
      {gettext("May"), "5"},
      {gettext("June"), "6"},
      {gettext("July"), "7"},
      {gettext("August"), "8"},
      {gettext("September"), "9"},
      {gettext("October"), "10"},
      {gettext("November"), "11"},
      {gettext("December"), "12"},
    ])

  datetime_select(form, field, opts)
end</pre> <h4 id="datetime_select/3-options" class="section-heading">  Options </h4> <ul> <li>
<p><code class="inline">:value</code> - the value used to select a given option. The default value is extracted from the form data if available</p> </li> <li>
<p><code class="inline">:default</code> - the default value to use when none was given in <code class="inline">:value</code> and none is available in the form data</p> </li> <li>
<p><code class="inline">:year</code>, <code class="inline">:month</code>, <code class="inline">:day</code>, <code class="inline">:hour</code>, <code class="inline">:minute</code>, <code class="inline">:second</code> - options passed to the underlying select. See <a href="#select/4"><code class="inline">select/4</code></a> for more information. The available values can be given in <code class="inline">:options</code>.</p> </li> <li>
<p><code class="inline">:builder</code> - specify how the select can be build. It must be a function that receives a builder that should be invoked with the select name and a set of options. See builder below for more information.</p> </li> </ul> <h4 id="datetime_select/3-builder" class="section-heading">  Builder </h4> <p>The generated datetime_select can be customized at will by providing a builder option. Here is an example from EEx:</p> <pre data-language="elixir">&lt;%= datetime_select form, :born_at, builder: fn b -&gt; %&gt;
  Date: &lt;%= b.(:day, []) %&gt; / &lt;%= b.(:month, []) %&gt; / &lt;%= b.(:year, []) %&gt;
  Time: &lt;%= b.(:hour, []) %&gt; : &lt;%= b.(:minute, []) %&gt;
&lt;% end %&gt;</pre> <p>Although we have passed empty lists as options (they are required), you could pass any option there and it would be given to the underlying select input.</p> <p>In practice, we recommend you to create your own helper with your default builder:</p> <pre data-language="elixir">def my_datetime_select(form, field, opts \\ []) do
  builder = fn b -&gt;
    ~e"""
    Date: &lt;%= b.(:day, []) %&gt; / &lt;%= b.(:month, []) %&gt; / &lt;%= b.(:year, []) %&gt;
    Time: &lt;%= b.(:hour, []) %&gt; : &lt;%= b.(:minute, []) %&gt;
    """
  end

  datetime_select(form, field, [builder: builder] ++ opts)
end</pre> <p>Then you are able to use your own datetime_select throughout your whole application.</p> <h4 id="datetime_select/3-supported-date-values" class="section-heading">  Supported date values </h4> <p>The following values are supported as date:</p> <ul> <li>a map containing the <code class="inline">year</code>, <code class="inline">month</code> and <code class="inline">day</code> keys (either as strings or atoms) </li> <li>a tuple with three elements: <code class="inline">{year, month, day}</code> </li> <li>a string in ISO 8601 format </li> <li>
<code class="inline">nil</code> </li> </ul> <h4 id="datetime_select/3-supported-time-values" class="section-heading">  Supported time values </h4> <p>The following values are supported as time:</p> <ul> <li>a map containing the <code class="inline">hour</code> and <code class="inline">min</code> keys and an optional <code class="inline">sec</code> key (either as strings or atoms) </li> <li>a tuple with three elements: <code class="inline">{hour, min, sec}</code> </li> <li>a tuple with four elements: <code class="inline">{hour, min, sec, usec}</code> </li> <li>
<code class="inline">nil</code> </li> </ul>     <h3 class="detail-header function" id="email_input/3">  <span class="signature">email_input(form, field, opts \\ [])</span>  </h3>  <p>Generates an email input.</p> <p>See <a href="#text_input/3"><code class="inline">text_input/3</code></a> for example and docs.</p>     <h3 class="detail-header function" id="file_input/3">  <span class="signature">file_input(form, field, opts \\ [])</span>  </h3>  <p>Generates a file input.</p> <p>It requires the given form to be configured with <code class="inline">multipart: true</code> when invoking <a href="#form_for/4"><code class="inline">form_for/4</code></a>, otherwise it fails with <a href="https://hexdocs.pm/elixir/ArgumentError.html" target="_blank"><code class="inline">ArgumentError</code></a>.</p> <p>See <a href="#text_input/3"><code class="inline">text_input/3</code></a> for example and docs.</p>     <h3 class="detail-header function" id="form_for/4">  <span class="signature">form_for(form_data, action, options \\ [], fun)</span>     </h3>
<pre data-language="elixir">form_for(
  Phoenix.HTML.FormData.t(),
  String.t(),
  Keyword.t(),
  (t() -&gt; Phoenix.HTML.unsafe())
) :: Phoenix.HTML.safe()</pre>  <p>Generates a form tag with a form builder.</p> <p>See the module documentation for examples of using this function.</p> <h4 id="form_for/4-options" class="section-heading">  Options </h4> <ul> <li>
<p><code class="inline">:as</code> - the server side parameter in which all params for this form will be collected (i.e. <code class="inline">as: :user_params</code> would mean all fields for this form will be accessed as <code class="inline">conn.params.user_params</code> server side). Automatically inflected when a changeset is given.</p> </li> <li>
<p><code class="inline">:method</code> - the HTTP method. If the method is not “get” nor “post”, an input tag with name <code class="inline">_method</code> is generated along-side the form tag. Defaults to “post”.</p> </li> <li>
<p><code class="inline">:multipart</code> - when true, sets enctype to “multipart/form-data”. Required when uploading files</p> </li> <li>
<p><code class="inline">:csrf_token</code> - for “post” requests, the form tag will automatically include an input tag with name <code class="inline">_csrf_token</code>. When set to false, this is disabled</p> </li> <li>
<p><code class="inline">:enforce_utf8</code> - the form will have an <code class="inline">accept-charset</code> attribute set to “UTF-8” and a hidden input named <code class="inline">_utf8</code> containing a unicode character to force the browser to use UTF-8 as the charset. When set to false, this is disabled.</p> </li> <li>
<p>Other options will be passed as html attributes. ie, <code class="inline">class: "foo", id: "bar"</code></p> </li> </ul> <p>See <a href="../phoenix.html.tag/#form_tag/2"><code class="inline">Phoenix.HTML.Tag.form_tag/2</code></a> for more information on the options above.</p>     <h3 class="detail-header function" id="hidden_input/3">  <span class="signature">hidden_input(form, field, opts \\ [])</span>  </h3>  <p>Generates a hidden input.</p> <p>See <a href="#text_input/3"><code class="inline">text_input/3</code></a> for example and docs.</p>    <h3 class="detail-header function" id="humanize/1">  <span class="signature">humanize(atom)</span>  </h3>  <p>Converts an attribute/form field into its humanize version.</p> <pre data-language="elixir">iex&gt; humanize(:username)
"Username"
iex&gt; humanize(:created_at)
"Created at"
iex&gt; humanize("user_id")
"User"</pre>    <h3 class="detail-header function" id="input_id/2">  <span class="signature">input_id(name, field)</span>     </h3>
<pre data-language="elixir">input_id(t() | atom(), field()) :: String.t()</pre>  <p>Returns an id of a corresponding form field.</p> <p>The form should either be a <a href="../phoenix.html.form/#content"><code class="inline">Phoenix.HTML.Form</code></a> emitted by <code class="inline">form_for</code> or an atom.</p>    <h3 class="detail-header function" id="input_id/3">  <span class="signature">input_id(name, field, value)</span>     </h3>
<pre data-language="elixir">input_id(t() | atom(), field(), Phoenix.HTML.Safe.t()) :: String.t()</pre>  <p>Returns an id of a corresponding form field and value attached to it.</p> <p>Useful for radio buttons and inputs like multiselect checkboxes.</p>    <h3 class="detail-header function" id="input_name/2">  <span class="signature">input_name(name, field)</span>     </h3>
<pre data-language="elixir">input_name(t() | atom(), field()) :: String.t()</pre>  <p>Returns a name of a corresponding form field.</p> <p>The form should either be a <a href="../phoenix.html.form/#content"><code class="inline">Phoenix.HTML.Form</code></a> emitted by <code class="inline">form_for</code> or an atom.</p>     <h3 class="detail-header function" id="input_type/3">  <span class="signature">input_type(form, field, mapping \\ %{"email" =&gt; :email_input, "password" =&gt; :password_input, "search" =&gt; :search_input, "url" =&gt; :url_input})</span>  </h3>  <p>Gets the input type for a given field.</p> <p>If the underlying input type is a <code class="inline">:text_field</code>, a mapping could be given to further inflect the input type based solely on the field name. The default mapping is:</p> <pre data-language="elixir">%{"url"      =&gt; :url_input,
  "email"    =&gt; :email_input,
  "search"   =&gt; :search_input,
  "password" =&gt; :password_input}</pre>    <h3 class="detail-header function" id="input_validations/2">  <span class="signature">input_validations(form, field)</span>     </h3>
<pre data-language="elixir">input_validations(t(), field()) :: Keyword.t()</pre>  <p>Returns the HTML5 validations that would apply to the given field.</p>    <h3 class="detail-header function" id="input_value/2">  <span class="signature">input_value(form, field)</span>     </h3>
<pre data-language="elixir">input_value(t() | atom(), field()) :: term()</pre>  <p>Returns a value of a corresponding form field.</p> <p>The <code class="inline">form</code> should either be a <a href="../phoenix.html.form/#content"><code class="inline">Phoenix.HTML.Form</code></a> emitted by <code class="inline">form_for</code> or an atom.</p> <p>When a form is given, it will lookup for changes and then fallback to parameters and finally fallback to the default struct/map value.</p>     <h3 class="detail-header function" id="inputs_for/4">  <span class="signature">inputs_for(form, field, options \\ [], fun)</span>     </h3>
<pre data-language="elixir">inputs_for(t(), field(), Keyword.t(), (t() -&gt; Phoenix.HTML.unsafe())) ::
  Phoenix.HTML.safe()</pre>  <p>Generate a new form builder for the given parameter in form.</p> <p>See the module documentation for examples of using this function.</p> <h4 id="inputs_for/4-options" class="section-heading">  Options </h4> <ul> <li>
<p><code class="inline">:id</code> - the id to be used in the form, defaults to the concatenation of the given <code class="inline">field</code> to the parent form id</p> </li> <li>
<p><code class="inline">:as</code> - the name to be used in the form, defaults to the concatenation of the given <code class="inline">field</code> to the parent form name</p> </li> <li>
<p><code class="inline">:default</code> - the value to use if none is available</p> </li> <li>
<p><code class="inline">:prepend</code> - the values to prepend when rendering. This only applies if the field value is a list and no parameters were sent through the form.</p> </li> <li>
<p><code class="inline">:append</code> - the values to append when rendering. This only applies if the field value is a list and no parameters were sent through the form.</p> </li> </ul>    <h3 class="detail-header function" id="label/1">  <span class="signature">label(do_block)</span>  </h3>  <p>Generates a label tag.</p> <p>Useful when wrapping another input inside a label.</p> <h4 id="label/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">label do
  radio_button :user, :choice, "Choice"
end
#=&gt; &lt;label class="control-label"&gt;...&lt;/label&gt;

label class: "control-label" do
  radio_button :user, :choice, "Choice"
end
#=&gt; &lt;label class="control-label"&gt;...&lt;/label&gt;</pre>    <h3 class="detail-header function" id="label/2">  <span class="signature">label(opts, field)</span>  </h3>  <p>Generates a label tag for the given field.</p> <p>The form should either be a <a href="../phoenix.html.form/#content"><code class="inline">Phoenix.HTML.Form</code></a> emitted by <code class="inline">form_for</code> or an atom.</p> <p>All given options are forwarded to the underlying tag. A default value is provided for <code class="inline">for</code> attribute but can be overriden if you pass a value to the <code class="inline">for</code> option. Text content would be inferred from <code class="inline">field</code> if not specified.</p> <p>To wrap a label around an input, see <a href="#label/1"><code class="inline">label/1</code></a>.</p> <h4 id="label/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Assuming form contains a User schema
label(form, :name, "Name")
#=&gt; &lt;label for="user_name"&gt;Name&lt;/label&gt;

label(:user, :email, "Email")
#=&gt; &lt;label for="user_email"&gt;Email&lt;/label&gt;

label(:user, :email)
#=&gt; &lt;label for="user_email"&gt;Email&lt;/label&gt;

label(:user, :email, class: "control-label")
#=&gt; &lt;label for="user_email" class="control-label"&gt;Email&lt;/label&gt;

label :user, :email do
  "E-mail Address"
end
#=&gt; &lt;label for="user_email"&gt;E-mail Address&lt;/label&gt;

label :user, :email, class: "control-label" do
  "E-mail Address"
end
#=&gt; &lt;label class="control-label" for="user_email"&gt;E-mail Address&lt;/label&gt;</pre>    <h3 class="detail-header function" id="label/3">  <span class="signature">label(form, field, text_or_do_block_or_attributes)</span>  </h3>  <p>See <a href="#label/2"><code class="inline">label/2</code></a>.</p>    <h3 class="detail-header function" id="label/4">  <span class="signature">label(form, field, text, do_block_or_attributes)</span>  </h3>  <p>See <a href="#label/2"><code class="inline">label/2</code></a>.</p>     <h3 class="detail-header function" id="multiple_select/4">  <span class="signature">multiple_select(form, field, options, opts \\ [])</span>  </h3>  <p>Generates a select tag with the given <code class="inline">options</code>.</p> <p>Values are expected to be an Enumerable containing two-item tuples (like maps and keyword lists) or any Enumerable where the element will be used both as key and value for the generated select.</p> <h4 id="multiple_select/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Assuming form contains a User schema
multiple_select(form, :roles, ["Admin": 1, "Power User": 2])
#=&gt; &lt;select id="user_roles" name="user[roles][]"&gt;
    &lt;option value="1"&gt;Admin&lt;/option&gt;
    &lt;option value="2"&gt;Power User&lt;/option&gt;
    &lt;/select&gt;

multiple_select(form, :roles, ["Admin": 1, "Power User": 2], selected: [1])
#=&gt; &lt;select id="user_roles" name="user[roles][]"&gt;
    &lt;option value="1" selected="selected"&gt;Admin&lt;/option&gt;
    &lt;option value="2"&gt;Power User&lt;/option&gt;
    &lt;/select&gt;</pre> <p>When working with structs, associations and embeds, you will need to tell Phoenix how to extract the value out of the collection. For example, imagine <code class="inline">user.roles</code> is a list of <code class="inline">%Role{}</code> structs. You must call it as:</p> <pre data-language="elixir">multiple_select(form, :roles, ["Admin": 1, "Power User": 2],
                selected: Enum.map(@user.roles, &amp;(&amp;1.id))</pre> <p>The <code class="inline">:selected</code> option will mark the given IDs as selected unless the form is being resubmitted. When resubmitted, it uses the form params as values.</p> <h4 id="multiple_select/4-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:selected</code> - the default options to be marked as selected. The values on this list are ignored in case ids have been set as parameters. </li> </ul> <p>All other options are forwarded to the underlying HTML tag.</p>     <h3 class="detail-header function" id="number_input/3">  <span class="signature">number_input(form, field, opts \\ [])</span>  </h3>  <p>Generates a number input.</p> <p>See <a href="#text_input/3"><code class="inline">text_input/3</code></a> for example and docs.</p>     <h3 class="detail-header function" id="password_input/3">  <span class="signature">password_input(form, field, opts \\ [])</span>  </h3>  <p>Generates a password input.</p> <p>For security reasons, the form data and parameter values are never re-used in <a href="#password_input/3"><code class="inline">password_input/3</code></a>. Pass the value explicitly if you would like to set one.</p> <p>See <a href="#text_input/3"><code class="inline">text_input/3</code></a> for example and docs.</p>     <h3 class="detail-header function" id="radio_button/4">  <span class="signature">radio_button(form, field, value, opts \\ [])</span>  </h3>  <p>Generates a radio button.</p> <p>Invoke this function for each possible value you want to be sent to the server.</p> <h4 id="radio_button/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Assuming form contains a User schema
radio_button(form, :role, "admin")
#=&gt; &lt;input id="user_role_admin" name="user[role]" type="radio" value="admin"&gt;</pre> <h4 id="radio_button/4-options" class="section-heading">  Options </h4> <p>All options are simply forwarded to the underlying HTML tag.</p>     <h3 class="detail-header function" id="range_input/3">  <span class="signature">range_input(form, field, opts \\ [])</span>  </h3>  <p>Generates a range input.</p> <p>See <a href="#text_input/3"><code class="inline">text_input/3</code></a> for example and docs.</p>     <h3 class="detail-header function" id="reset/2">  <span class="signature">reset(value, opts \\ [])</span>  </h3>  <p>Generates a reset input to reset all the form fields to their original state.</p> <p>All options are forwarded to the underlying input tag.</p> <h4 id="reset/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">reset "Reset"
#=&gt; &lt;input type="reset" value="Reset"&gt;

reset "Reset", class: "btn"
#=&gt; &lt;input type="reset" value="Reset" class="btn"&gt;</pre>     <h3 class="detail-header function" id="search_input/3">  <span class="signature">search_input(form, field, opts \\ [])</span>  </h3>  <p>Generates a search input.</p> <p>See <a href="#text_input/3"><code class="inline">text_input/3</code></a> for example and docs.</p>     <h3 class="detail-header function" id="select/4">  <span class="signature">select(form, field, options, opts \\ [])</span>  </h3>  <p>Generates a select tag with the given <code class="inline">options</code>.</p> <p><code class="inline">options</code> are expected to be an enumerable which will be used to generate each respective <code class="inline">option</code>. The enumerable may have:</p> <ul> <li>
<p>keyword lists - each keyword list is expected to have the keys <code class="inline">:key</code> and <code class="inline">:value</code>. Additional keys such as <code class="inline">:disabled</code> may be given to customize the option</p> </li> <li>
<p>two-item tuples - where the first element is an atom, string or integer to be used as the option label and the second element is an atom, string or integer to be used as the option value</p> </li> <li>
<p>atom, string or integer - which will be used as both label and value for the generated select</p> </li> </ul> <h4 id="select/4-optgroups" class="section-heading">  Optgroups </h4> <p>If <code class="inline">options</code> is map or keyword list where the first element is a string, atom or integer and the second element is a list or a map, it is assumed the key will be wrapped in an <code class="inline">&lt;optgroup&gt;</code> and the value will be used to generate <code class="inline">&lt;options&gt;</code> nested under the group.</p> <h4 id="select/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Assuming form contains a User schema
select(form, :age, 0..120)
#=&gt; &lt;select id="user_age" name="user[age]"&gt;
    &lt;option value="0"&gt;0&lt;/option&gt;
    ...
    &lt;option value="120"&gt;120&lt;/option&gt;
    &lt;/select&gt;

select(form, :role, ["Admin": "admin", "User": "user"])
#=&gt; &lt;select id="user_role" name="user[role]"&gt;
    &lt;option value="admin"&gt;Admin&lt;/option&gt;
    &lt;option value="user"&gt;User&lt;/option&gt;
    &lt;/select&gt;

select(form, :role, [[key: "Admin", value: "admin", disabled: true],
                     [key: "User", value: "user"]])
#=&gt; &lt;select id="user_role" name="user[role]"&gt;
    &lt;option value="admin" disabled="disabled"&gt;Admin&lt;/option&gt;
    &lt;option value="user"&gt;User&lt;/option&gt;
    &lt;/select&gt;

select(form, :role, ["Admin": "admin", "User": "user"], prompt: "Choose your role")
#=&gt; &lt;select id="user_role" name="user[role]"&gt;
    &lt;option value=""&gt;Choose your role&lt;/option&gt;
    &lt;option value="admin"&gt;Admin&lt;/option&gt;
    &lt;option value="user"&gt;User&lt;/option&gt;
    &lt;/select&gt;</pre> <p>If you want to select an option that comes from the database, such as a manager for a given project, you may write:</p> <pre data-language="elixir">select(form, :manager_id, Enum.map(@managers, &amp;{&amp;1.name, &amp;1.id}))
#=&gt; &lt;select id="manager_id" name="project[manager_id]"&gt;
    &lt;option value="1"&gt;Mary Jane&lt;/option&gt;
    &lt;option value="2"&gt;John Doe&lt;/option&gt;
    &lt;/select&gt;</pre> <p>Finally, if the values are a list or a map, we use the keys for grouping:</p> <pre data-language="elixir">select(form, :country, ["Europe": ["UK", "Sweden", "France"]], ...})
#=&gt; &lt;select id="user_country" name="user[country]"&gt;
    &lt;optgroup label="Europe"&gt;
      &lt;option&gt;UK&lt;/option&gt;
      &lt;option&gt;Sweden&lt;/option&gt;
      &lt;option&gt;France&lt;/option&gt;
    &lt;/optgroup&gt;
    ...
    &lt;/select&gt;</pre> <h4 id="select/4-options" class="section-heading">  Options </h4> <ul> <li>
<p><code class="inline">:prompt</code> - an option to include at the top of the options with the given prompt text</p> </li> <li>
<p><code class="inline">:selected</code> - the default value to use when none was sent as parameter</p> </li> </ul> <p>Be aware that a <code class="inline">:multiple</code> option will not generate a correctly functioning multiple select element. Use <a href="#multiple_select/4"><code class="inline">multiple_select/4</code></a> instead.</p> <p>All other options are forwarded to the underlying HTML tag.</p>    <h3 class="detail-header function" id="submit/1">  <span class="signature">submit(block_option)</span>  </h3>  <p>Generates a submit button to send the form.</p> <p>All options are forwarded to the underlying button tag.</p> <h4 id="submit/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">submit "Submit"
#=&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt;</pre>     <h3 class="detail-header function" id="submit/2">  <span class="signature">submit(opts, opts \\ [])</span>  </h3>      <h3 class="detail-header function" id="telephone_input/3">  <span class="signature">telephone_input(form, field, opts \\ [])</span>  </h3>  <p>Generates a telephone input.</p> <p>See <a href="#text_input/3"><code class="inline">text_input/3</code></a> for example and docs.</p>     <h3 class="detail-header function" id="text_input/3">  <span class="signature">text_input(form, field, opts \\ [])</span>  </h3>  <p>Generates a text input.</p> <p>The form should either be a <a href="../phoenix.html.form/#content"><code class="inline">Phoenix.HTML.Form</code></a> emitted by <code class="inline">form_for</code> or an atom.</p> <p>All given options are forwarded to the underlying input, default values are provided for id, name and value if possible.</p> <h4 id="text_input/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Assuming form contains a User schema
text_input(form, :name)
#=&gt; &lt;input id="user_name" name="user[name]" type="text" value=""&gt;

text_input(:user, :name)
#=&gt; &lt;input id="user_name" name="user[name]" type="text" value=""&gt;</pre>     <h3 class="detail-header function" id="textarea/3">  <span class="signature">textarea(form, field, opts \\ [])</span>  </h3>  <p>Generates a textarea input.</p> <p>All given options are forwarded to the underlying input, default values are provided for id, name and textarea content if possible.</p> <h4 id="textarea/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Assuming form contains a User schema
textarea(form, :description)
#=&gt; &lt;textarea id="user_description" name="user[description]"&gt;&lt;/textarea&gt;</pre> <h4 id="textarea/3-new-lines" class="section-heading">  New lines </h4> <p>Notice the generated textarea includes a new line after the opening tag. This is because the HTML spec says new lines after tags must be ignored and all major browser implementations do that.</p> <p>So in order to avoid new lines provided by the user from being ignored when the form is resubmitted, we automatically add a new line before the text area value.</p>     <h3 class="detail-header function" id="time_input/3">  <span class="signature">time_input(form, field, opts \\ [])</span>  </h3>  <p>Generates a time input.</p> <p>Warning: this feature isn’t available in all browsers. Check <code class="inline">http://caniuse.com/#feat=input-datetime</code> for further informations.</p> <h4 id="time_input/3-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:precision</code> - Allowed values: <code class="inline">:minute</code>, <code class="inline">:second</code>, <code class="inline">:millisecond</code>. Defaults to <code class="inline">:minute</code>. </li> </ul> <p>All other options are forwarded. See <a href="#text_input/3"><code class="inline">text_input/3</code></a> for example and docs.</p> <h4 id="time_input/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">time_input form, :time
#=&gt; &lt;input id="form_time" name="form[time]" type="time" value="23:00"&gt;

time_input form, :time, precision: :second
#=&gt; &lt;input id="form_time" name="form[time]" type="time" value="23:00:00"&gt;

time_input form, :time, precision: :millisecond
#=&gt; &lt;input id="form_time" name="form[time]" type="time" value="23:00:00.000"&gt;</pre>     <h3 class="detail-header function" id="time_select/3">  <span class="signature">time_select(form, field, opts \\ [])</span>  </h3>  <p>Generates select tags for time.</p> <p>Check <a href="#datetime_select/3"><code class="inline">datetime_select/3</code></a> for more information on options and supported values.</p>     <h3 class="detail-header function" id="url_input/3">  <span class="signature">url_input(form, field, opts \\ [])</span>  </h3>  <p>Generates an url input.</p> <p>See <a href="#text_input/3"><code class="inline">text_input/3</code></a> for example and docs.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2014 Chris McCord<br>Licensed under the MIT License.<br>
    <a href="https://hexdocs.pm/phoenix_html/Phoenix.HTML.Form.html" class="_attribution-link" target="_blank">https://hexdocs.pm/phoenix_html/Phoenix.HTML.Form.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
