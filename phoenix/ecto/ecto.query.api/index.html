
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Ecto.Query.API - Phoenix - W3cubDocs</title>
  
  <meta name="description" content=" Lists all functions allowed in the query API. ">
  <meta name="keywords" content="ecto, query, api, summary, functions, -, phoenix">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/phoenix/ecto/ecto.query.api/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/phoenix.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/phoenix/" class="_nav-link" title="" style="margin-left:0;">Phoenix</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1>  Ecto.Query.API  </h1>  <p>Lists all functions allowed in the query API.</p> <ul> <li>Comparison operators: <code class="inline">==</code>, <code class="inline">!=</code>, <code class="inline">&lt;=</code>, <code class="inline">&gt;=</code>, <code class="inline">&lt;</code>, <code class="inline">&gt;</code> </li> <li>Arithmetic operators: <code class="inline">+</code>, <code class="inline">-</code>, <code class="inline">*</code>, <code class="inline">/</code> </li> <li>Boolean operators: <code class="inline">and</code>, <code class="inline">or</code>, <code class="inline">not</code> </li> <li>Inclusion operator: <a href="#in/2"><code class="inline">in/2</code></a> </li> <li>Search functions: <a href="#like/2"><code class="inline">like/2</code></a> and <a href="#ilike/2"><code class="inline">ilike/2</code></a> </li> <li>Null check functions: <a href="#is_nil/1"><code class="inline">is_nil/1</code></a> </li> <li>Aggregates: <a href="#count/0"><code class="inline">count/0</code></a>, <a href="#count/1"><code class="inline">count/1</code></a>, <a href="#avg/1"><code class="inline">avg/1</code></a>, <a href="#sum/1"><code class="inline">sum/1</code></a>, <a href="#min/1"><code class="inline">min/1</code></a>, <a href="#max/1"><code class="inline">max/1</code></a> </li> <li>Date/time intervals: <a href="#datetime_add/3"><code class="inline">datetime_add/3</code></a>, <a href="#date_add/3"><code class="inline">date_add/3</code></a>, <a href="#from_now/2"><code class="inline">from_now/2</code></a>, <a href="#ago/2"><code class="inline">ago/2</code></a> </li> <li>Inside select: <a href="#struct/2"><code class="inline">struct/2</code></a>, <a href="#map/2"><code class="inline">map/2</code></a>, <a href="#merge/2"><code class="inline">merge/2</code></a> and literals (map, tuples, lists, etc) </li> <li>General: <a href="#fragment/1"><code class="inline">fragment/1</code></a>, <a href="#field/2"><code class="inline">field/2</code></a> and <a href="#type/2"><code class="inline">type/2</code></a> </li> </ul> <p>Note the functions in this module exist for documentation purposes and one should never need to invoke them directly. Furthermore, it is possible to define your own macros and use them in Ecto queries (see docs for <a href="#fragment/1"><code class="inline">fragment/1</code></a>).</p> <h2 id="module-window-api" class="section-heading">  Window API </h2> <p>Ecto also supports many of the windows functions found in SQL databases. See <a href="../ecto.query.windowapi/"><code class="inline">Ecto.Query.WindowAPI</code></a> for more information.</p> <h2 id="module-about-the-arithmetic-operators" class="section-heading">  About the arithmetic operators </h2> <p>The Ecto implementation of these operators provide only a thin layer above the adapters. So if your adapter allows you to use them in a certain way (like adding a date and an interval in PostgreSQL), it should work just fine in Ecto queries.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#!=/2">left != right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">!=</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#*/2">left * right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">*</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#+/2">left + right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">+</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#-/2">left - right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">-</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#//2">left / right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">/</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#%3C/2">left &lt; right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">&lt;</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#%3C=/2">left &lt;= right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">&lt;=</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#==/2">left == right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">==</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#%3E/2">left &gt; right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">&gt;</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#%3E=/2">left &gt;= right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">&gt;=</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#ago/2">ago(count, interval)</a> </dt> <dd class="summary-synopsis">
<p>Subtracts the given interval from the current time in UTC</p> </dd>   <dt class="summary-signature"> <a href="#and/2">left and right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">and</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#avg/1">avg(value)</a> </dt> <dd class="summary-synopsis">
<p>Calculates the average for the given entry</p> </dd>   <dt class="summary-signature"> <a href="#coalesce/2">coalesce(value, expr)</a> </dt> <dd class="summary-synopsis">
<p>Takes whichever value is not null, or null if they both are</p> </dd>   <dt class="summary-signature"> <a href="#count/0">count()</a> </dt> <dd class="summary-synopsis">
<p>Counts the entries in the table</p> </dd>   <dt class="summary-signature"> <a href="#count/1">count(value)</a> </dt> <dd class="summary-synopsis">
<p>Counts the given entry</p> </dd>   <dt class="summary-signature"> <a href="#count/2">count(value, atom)</a> </dt> <dd class="summary-synopsis">
<p>Counts the distinct values in given entry</p> </dd>   <dt class="summary-signature"> <a href="#date_add/3">date_add(date, count, interval)</a> </dt> <dd class="summary-synopsis">
<p>Adds a given interval to a date</p> </dd>   <dt class="summary-signature"> <a href="#datetime_add/3">datetime_add(datetime, count, interval)</a> </dt> <dd class="summary-synopsis">
<p>Adds a given interval to a datetime</p> </dd>   <dt class="summary-signature"> <a href="#field/2">field(source, field)</a> </dt> <dd class="summary-synopsis">
<p>Allows a field to be dynamically accessed</p> </dd>   <dt class="summary-signature"> <a href="#filter/2">filter(value, filter)</a> </dt> <dd class="summary-synopsis">
<p>Applies the given expression as a FILTER clause against an aggregate. This is currently only supported by Postgres</p> </dd>   <dt class="summary-signature"> <a href="#fragment/1">fragment(fragments)</a> </dt> <dd class="summary-synopsis">
<p>Send fragments directly to the database</p> </dd>   <dt class="summary-signature"> <a href="#from_now/2">from_now(count, interval)</a> </dt> <dd class="summary-synopsis">
<p>Adds the given interval to the current time in UTC</p> </dd>   <dt class="summary-signature"> <a href="#ilike/2">ilike(string, search)</a> </dt> <dd class="summary-synopsis">
<p>Searches for <code class="inline">search</code> in <code class="inline">string</code> in a case insensitive fashion</p> </dd>   <dt class="summary-signature"> <a href="#in/2">left in right</a> </dt> <dd class="summary-synopsis">
<p>Checks if the left-value is included in the right one</p> </dd>   <dt class="summary-signature"> <a href="#is_nil/1">is_nil(value)</a> </dt> <dd class="summary-synopsis">
<p>Checks if the given value is nil</p> </dd>   <dt class="summary-signature"> <a href="#like/2">like(string, search)</a> </dt> <dd class="summary-synopsis">
<p>Searches for <code class="inline">search</code> in <code class="inline">string</code></p> </dd>   <dt class="summary-signature"> <a href="#map/2">map(source, fields)</a> </dt> <dd class="summary-synopsis">
<p>Used in <code class="inline">select</code> to specify which fields should be returned as a map</p> </dd>   <dt class="summary-signature"> <a href="#max/1">max(value)</a> </dt> <dd class="summary-synopsis">
<p>Calculates the maximum for the given entry</p> </dd>   <dt class="summary-signature"> <a href="#merge/2">merge(left_map, right_map)</a> </dt> <dd class="summary-synopsis">
<p>Merges the map on the right over the map on the left</p> </dd>   <dt class="summary-signature"> <a href="#min/1">min(value)</a> </dt> <dd class="summary-synopsis">
<p>Calculates the minimum for the given entry</p> </dd>   <dt class="summary-signature"> <a href="#not/1">not(value)</a> </dt> <dd class="summary-synopsis">
<p>Unary <code class="inline">not</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#or/2">left or right</a> </dt> <dd class="summary-synopsis">
<p>Binary <code class="inline">or</code> operation</p> </dd>   <dt class="summary-signature"> <a href="#struct/2">struct(source, fields)</a> </dt> <dd class="summary-synopsis">
<p>Used in <code class="inline">select</code> to specify which struct fields should be returned</p> </dd>   <dt class="summary-signature"> <a href="#sum/1">sum(value)</a> </dt> <dd class="summary-synopsis">
<p>Calculates the sum for the given entry</p> </dd>   <dt class="summary-signature"> <a href="#type/2">type(interpolated_value, type)</a> </dt> <dd class="summary-synopsis">
<p>Casts the given value to the given type at the database level</p> </dd>  </dl>   <h1 class="section-heading" id="functions">  Functions </h1>  <h3 class="detail-header function" id="!=/2">  <span class="signature">left != right</span>  </h3>  <p>Binary <code class="inline">!=</code> operation.</p>    <h3 class="detail-header function" id="*/2">  <span class="signature">left * right</span>  </h3>  <p>Binary <code class="inline">*</code> operation.</p>    <h3 class="detail-header function" id="+/2">  <span class="signature">left + right</span>  </h3>  <p>Binary <code class="inline">+</code> operation.</p>    <h3 class="detail-header function" id="-/2">  <span class="signature">left - right</span>  </h3>  <p>Binary <code class="inline">-</code> operation.</p>    <h3 class="detail-header function" id="//2">  <span class="signature">left / right</span>  </h3>  <p>Binary <code class="inline">/</code> operation.</p>     <h3 class="detail-header function" id="%3C/2">  <span class="signature">left &lt; right</span>  </h3>  <p>Binary <code class="inline">&lt;</code> operation.</p>     <h3 class="detail-header function" id="%3C=/2">  <span class="signature">left &lt;= right</span>  </h3>  <p>Binary <code class="inline">&lt;=</code> operation.</p>    <h3 class="detail-header function" id="==/2">  <span class="signature">left == right</span>  </h3>  <p>Binary <code class="inline">==</code> operation.</p>     <h3 class="detail-header function" id="%3E/2">  <span class="signature">left &gt; right</span>  </h3>  <p>Binary <code class="inline">&gt;</code> operation.</p>     <h3 class="detail-header function" id="%3E=/2">  <span class="signature">left &gt;= right</span>  </h3>  <p>Binary <code class="inline">&gt;=</code> operation.</p>    <h3 class="detail-header function" id="ago/2">  <span class="signature">ago(count, interval)</span>  </h3>  <p>Subtracts the given interval from the current time in UTC.</p> <p>The current time in UTC is retrieved from Elixir and not from the database.</p> <h4 id="ago/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">from p in Post, where: p.published_at &gt; ago(3, "month")</pre>    <h3 class="detail-header function" id="and/2">  <span class="signature">left and right</span>  </h3>  <p>Binary <code class="inline">and</code> operation.</p>    <h3 class="detail-header function" id="avg/1">  <span class="signature">avg(value)</span>  </h3>  <p>Calculates the average for the given entry.</p> <pre data-language="elixir">from p in Payment, select: avg(p.value)</pre>    <h3 class="detail-header function" id="coalesce/2">  <span class="signature">coalesce(value, expr)</span>  </h3>  <p>Takes whichever value is not null, or null if they both are.</p> <p>In SQL, COALESCE takes any number of arguments, but in ecto it only takes two, so it must be chained to achieve the same effect.</p> <pre data-language="elixir">from p in Payment, select: p.value |&gt; coalesce(p.backup_value) |&gt; coalesce(0)</pre>    <h3 class="detail-header function" id="count/0">  <span class="signature">count()</span>  </h3>  <p>Counts the entries in the table.</p> <pre data-language="elixir">from p in Post, select: count()</pre>    <h3 class="detail-header function" id="count/1">  <span class="signature">count(value)</span>  </h3>  <p>Counts the given entry.</p> <pre data-language="elixir">from p in Post, select: count(p.id)</pre>    <h3 class="detail-header function" id="count/2">  <span class="signature">count(value, atom)</span>  </h3>  <p>Counts the distinct values in given entry.</p> <pre data-language="elixir">from p in Post, select: count(p.id, :distinct)</pre>    <h3 class="detail-header function" id="date_add/3">  <span class="signature">date_add(date, count, interval)</span>  </h3>  <p>Adds a given interval to a date.</p> <p>See <a href="#datetime_add/3"><code class="inline">datetime_add/3</code></a> for more information.</p>    <h3 class="detail-header function" id="datetime_add/3">  <span class="signature">datetime_add(datetime, count, interval)</span>  </h3>  <p>Adds a given interval to a datetime.</p> <p>The first argument is a <code class="inline">datetime</code>, the second one is the count for the interval, which may be either positive or negative and the interval value:</p> <pre data-language="elixir"># Get all items published since the last month
from p in Post, where: p.published_at &gt;
                       datetime_add(^NaiveDateTime.utc_now, -1, "month")</pre> <p>In the example above, we used <a href="#datetime_add/3"><code class="inline">datetime_add/3</code></a> to subtract one month from the current datetime and compared it with the <code class="inline">p.published_at</code>. If you want to perform operations on date, <a href="#date_add/3"><code class="inline">date_add/3</code></a> could be used.</p> <p>The following intervals are supported: year, month, week, day, hour, minute, second, millisecond and microsecond.</p>    <h3 class="detail-header function" id="field/2">  <span class="signature">field(source, field)</span>  </h3>  <p>Allows a field to be dynamically accessed.</p> <pre data-language="elixir">def at_least_four(doors_or_tires) do
    from c in Car,
  where: field(c, ^doors_or_tires) &gt;= 4
end</pre> <p>In the example above, both <code class="inline">at_least_four(:doors)</code> and <code class="inline">at_least_four(:tires)</code> would be valid calls as the field is dynamically generated.</p>    <h3 class="detail-header function" id="filter/2">  <span class="signature">filter(value, filter)</span>  </h3>  <p>Applies the given expression as a FILTER clause against an aggregate. This is currently only supported by Postgres.</p> <pre data-language="elixir">from p in Payment, select: filter(avg(p.value), p.value &gt; 0 and p.value &lt; 100)

from p in Payment, select: avg(p.value) |&gt; filter(p.value &lt; 0)</pre>    <h3 class="detail-header function" id="fragment/1">  <span class="signature">fragment(fragments)</span>  </h3>  <p>Send fragments directly to the database.</p> <p>It is not possible to represent all possible database queries using Ecto’s query syntax. When such is required, it is possible to use fragments to send any expression to the database:</p> <pre data-language="elixir">def unpublished_by_title(title) do
  from p in Post,
    where: is_nil(p.published_at) and
           fragment("lower(?)", p.title) == ^title
end</pre> <p>Every occurence of the <code class="inline">?</code> character will be interpreted as a place for additional argument. If the literal character <code class="inline">?</code> is required, it can be escaped with <code class="inline">\\?</code> (one escape for strings, another for fragment).</p> <p>In the example above, we are using the lower procedure in the database to downcase the title column.</p> <p>It is very important to keep in mind that Ecto is unable to do any type casting described above when fragments are used. You can however use the <a href="#type/2"><code class="inline">type/2</code></a> function to give Ecto some hints:</p> <pre data-language="elixir">fragment("lower(?)", p.title) == type(^title, :string)</pre> <p>Or even say the right side is of the same type as <code class="inline">p.title</code>:</p> <pre data-language="elixir">fragment("lower(?)", p.title) == type(^title, p.title)</pre> <p>It is possible to make use of PostgreSQL’s JSON/JSONB data type with fragments, as well:</p> <pre data-language="elixir">fragment("?-&gt;&gt;? ILIKE ?", p.map, "key_name", ^some_value)</pre> <h4 id="fragment/1-keyword-fragments" class="section-heading">  Keyword fragments </h4> <p>In order to support databases that do not have string-based queries, like MongoDB, fragments also allow keywords to be given:</p> <pre data-language="elixir">from p in Post,
    where: fragment(title: ["$eq": ^some_value])</pre> <h4 id="fragment/1-defining-custom-functions-using-macros-and-fragment" class="section-heading">  Defining custom functions using macros and fragment </h4> <p>You can add a custom Ecto query function using macros. For example to expose SQL’s coalesce function you can define this macro:</p> <pre data-language="elixir">defmodule CustomFunctions do
  defmacro coalesce(left, right) do
    quote do
      fragment("coalesce(?, ?)", unquote(left), unquote(right))
    end
  end
end</pre> <p>To have coalesce/2 available, just import the module that defines it.</p> <pre data-language="elixir">import CustomFunctions</pre> <p>The only downside is that it will show up as a fragment when inspecting the Elixir query. Other than that, it should be equivalent to a built-in Ecto query function.</p>    <h3 class="detail-header function" id="from_now/2">  <span class="signature">from_now(count, interval)</span>  </h3>  <p>Adds the given interval to the current time in UTC.</p> <p>The current time in UTC is retrieved from Elixir and not from the database.</p> <h4 id="from_now/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">from a in Account, where: a.expires_at &lt; from_now(3, "month")</pre>    <h3 class="detail-header function" id="ilike/2">  <span class="signature">ilike(string, search)</span>  </h3>  <p>Searches for <code class="inline">search</code> in <code class="inline">string</code> in a case insensitive fashion.</p> <pre data-language="elixir">from p in Post, where: ilike(p.body, "Chapter%")</pre> <p>Translates to the underlying SQL ILIKE query. This operation is only available on PostgreSQL.</p>    <h3 class="detail-header function" id="in/2">  <span class="signature">left in right</span>  </h3>  <p>Checks if the left-value is included in the right one.</p> <pre data-language="elixir">from p in Post, where: p.id in [1, 2, 3]</pre> <p>The right side may either be a list, a literal list or even a column in the database with array type:</p> <pre data-language="elixir">from p in Post, where: "elixir" in p.tags</pre>    <h3 class="detail-header function" id="is_nil/1">  <span class="signature">is_nil(value)</span>  </h3>  <p>Checks if the given value is nil.</p> <pre data-language="elixir">from p in Post, where: is_nil(p.published_at)</pre> <p>To check if a given value is not nil use:</p> <pre data-language="elixir">from p in Post, where: not is_nil(p.published_at)</pre>    <h3 class="detail-header function" id="like/2">  <span class="signature">like(string, search)</span>  </h3>  <p>Searches for <code class="inline">search</code> in <code class="inline">string</code>.</p> <pre data-language="elixir">from p in Post, where: like(p.body, "Chapter%")</pre> <p>Translates to the underlying SQL LIKE query, therefore its behaviour is dependent on the database. In particular, PostgreSQL will do a case-sensitive operation, while the majority of other databases will be case-insensitive. For performing a case-insensitive <code class="inline">like</code> in PostgreSQL, see <a href="#ilike/2"><code class="inline">ilike/2</code></a>.</p> <p>You should be very careful when allowing user sent data to be used as part of LIKE query, since they allow to perform <a href="https://githubengineering.com/like-injection/" target="_blank">LIKE-injections</a>.</p>    <h3 class="detail-header function" id="map/2">  <span class="signature">map(source, fields)</span>  </h3>  <p>Used in <code class="inline">select</code> to specify which fields should be returned as a map.</p> <p>For example, if you don’t need all fields to be returned or neither need a struct, you can use <a href="#map/2"><code class="inline">map/2</code></a> to achieve both:</p> <pre data-language="elixir">from p in Post,
  select: map(p, [:title, :body])</pre> <p><a href="#map/2"><code class="inline">map/2</code></a> can also be used to dynamically select fields:</p> <pre data-language="elixir">fields = [:title, :body]
from p in Post, select: map(p, ^fields)</pre> <p>If the same source is selected multiple times with a <code class="inline">map</code>, the fields are merged in order to avoid fetching multiple copies from the database. In other words, the expression below:</p> <pre data-language="elixir">from(city in City, preload: :country,
     select: {map(city, [:country_id]), map(city, [:name])}</pre> <p>is expanded to:</p> <pre data-language="elixir">from(city in City, preload: :country,
     select: {map(city, [:country_id, :name]), map(city, [:country_id, :name])}</pre> <p>For preloads, the selected fields may be specified from the parent:</p> <pre data-language="elixir">from(city in City, preload: :country,
     select: map(city, [:country_id, :name, country: [:id, :population]]))</pre> <p><strong>IMPORTANT</strong>: When filtering fields for associations, you MUST include the foreign keys used in the relationship, otherwise Ecto will be unable to find associated records.</p>    <h3 class="detail-header function" id="max/1">  <span class="signature">max(value)</span>  </h3>  <p>Calculates the maximum for the given entry.</p> <pre data-language="elixir">from p in Payment, select: max(p.value)</pre>    <h3 class="detail-header function" id="merge/2">  <span class="signature">merge(left_map, right_map)</span>  </h3>  <p>Merges the map on the right over the map on the left.</p> <p>If the map on the left side is a struct, Ecto will check all of the field on the right previously exist on the left before merging.</p> <pre data-language="elixir">from(city in City, select: merge(city, %{virtual_field: "some_value"}))</pre> <p>This function is primarily used by <a href="../ecto.query/#select_merge/3"><code class="inline">Ecto.Query.select_merge/3</code></a> to merge different select clauses.</p>    <h3 class="detail-header function" id="min/1">  <span class="signature">min(value)</span>  </h3>  <p>Calculates the minimum for the given entry.</p> <pre data-language="elixir">from p in Payment, select: min(p.value)</pre>    <h3 class="detail-header function" id="not/1">  <span class="signature">not(value)</span>  </h3>  <p>Unary <code class="inline">not</code> operation.</p>    <h3 class="detail-header function" id="or/2">  <span class="signature">left or right</span>  </h3>  <p>Binary <code class="inline">or</code> operation.</p>    <h3 class="detail-header function" id="struct/2">  <span class="signature">struct(source, fields)</span>  </h3>  <p>Used in <code class="inline">select</code> to specify which struct fields should be returned.</p> <p>For example, if you don’t need all fields to be returned as part of a struct, you can filter it to include only certain fields by using <a href="#struct/2"><code class="inline">struct/2</code></a>:</p> <pre data-language="elixir">from p in Post,
  select: struct(p, [:title, :body])</pre> <p><a href="#struct/2"><code class="inline">struct/2</code></a> can also be used to dynamically select fields:</p> <pre data-language="elixir">fields = [:title, :body]
from p in Post, select: struct(p, ^fields)</pre> <p>As a convenience, <code class="inline">select</code> allows developers to take fields without an explicit call to <a href="#struct/2"><code class="inline">struct/2</code></a>:</p> <pre data-language="elixir">from p in Post, select: [:title, :body]</pre> <p>Or even dynamically:</p> <pre data-language="elixir">fields = [:title, :body]
from p in Post, select: ^fields</pre> <p>For preloads, the selected fields may be specified from the parent:</p> <pre data-language="elixir">from(city in City, preload: :country,
     select: struct(city, [:country_id, :name, country: [:id, :population]]))</pre> <p>If the same source is selected multiple times with a <code class="inline">struct</code>, the fields are merged in order to avoid fetching multiple copies from the database. In other words, the expression below:</p> <pre data-language="elixir">from(city in City, preload: :country,
     select: {struct(city, [:country_id]), struct(city, [:name])}</pre> <p>is expanded to:</p> <pre data-language="elixir">from(city in City, preload: :country,
     select: {struct(city, [:country_id, :name]), struct(city, [:country_id, :name])}</pre> <p><strong>IMPORTANT</strong>: When filtering fields for associations, you MUST include the foreign keys used in the relationship, otherwise Ecto will be unable to find associated records.</p>    <h3 class="detail-header function" id="sum/1">  <span class="signature">sum(value)</span>  </h3>  <p>Calculates the sum for the given entry.</p> <pre data-language="elixir">from p in Payment, select: sum(p.value)</pre>    <h3 class="detail-header function" id="type/2">  <span class="signature">type(interpolated_value, type)</span>  </h3>  <p>Casts the given value to the given type at the database level.</p> <p>Most of the times, Ecto is able to proper cast interpolated values due to its type checking mechanism. In some situations though, you may want to tell Ecto that a parameter has some particular type:</p> <pre data-language="elixir">type(^title, :string)</pre> <p>It is also possible to say the type must match the same of a column:</p> <pre data-language="elixir">type(^title, p.title)</pre> <p>Ecto will ensure <code class="inline">^title</code> is cast to the given type and enforce such type at the database level. If the value is returned in a <code class="inline">select</code>, Ecto will also enforce the proper type throughout.</p> <p>When performing arithmetic operations, <a href="#type/2"><code class="inline">type/2</code></a> can be used to cast all the parameters in the operation to the same type:</p> <pre data-language="elixir">from p in Post,
  select: type(p.visits + ^a_float + ^a_integer, :decimal)</pre> <p>Inside <code class="inline">select</code>, <a href="#type/2"><code class="inline">type/2</code></a> can also be used to cast fragments:</p> <pre data-language="elixir">type(fragment("NOW"), :naive_datetime)</pre> <p>Or to type fields from schemaless queries:</p> <pre data-language="elixir">from p in "posts", select: type(p.cost, :decimal)</pre> <p>Or to type aggregation results:</p> <pre data-language="elixir">from p in Post, select: type(avg(p.cost), :integer)</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/ecto/Ecto.Query.API.html" class="_attribution-link" target="_blank">https://hexdocs.pm/ecto/Ecto.Query.API.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
