
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Form Validation - Angular 7 - W3cubDocs</title>
  
  <meta name="description" content=" Improve overall data quality by validating user input for accuracy and completeness. ">
  <meta name="keywords" content="form, validation, -, angular, angular~7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/angular~7/guide/form-validation/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/angular~7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/angular~7/" class="_nav-link" title="" style="margin-left:0;">Angular 7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _angular">
				
				
<h1 id="form-validation">Form Validation</h1> <p>Improve overall data quality by validating user input for accuracy and completeness.</p> <p>This page shows how to validate user input in the UI and display useful validation messages using both reactive and template-driven forms. It assumes some basic knowledge of the two forms modules.</p> <blockquote class="alert is-helpful"> <p>If you're new to forms, start by reviewing the <a href="../forms/">Forms</a> and <a href="../reactive-forms/">Reactive Forms</a> guides.</p> </blockquote> <h2 id="template-driven-validation">Template-driven validation</h2> <p>To add validation to a template-driven form, you add the same validation attributes as you would with <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation" target="_blank">native HTML form validation</a>. Angular uses directives to match these attributes with validator functions in the framework.</p> <p>Every time the value of a form control changes, Angular runs validation and generates either a list of validation errors, which results in an INVALID status, or null, which results in a VALID status.</p> <p>You can then inspect the control's state by exporting <code><a href="../../api/forms/ngmodel/" class="code-anchor">ngModel</a></code> to a local template variable. The following example exports <code><a href="../../api/forms/ngmodel/" class="code-anchor">NgModel</a></code> into a variable called <code>name</code>:</p> <pre header="template/hero-form-template.component.html (name)" data-language="html">&lt;input id="name" name="name" class="form-control"
      required minlength="4" appForbiddenName="bob"
      [(ngModel)]="hero.name" #name="ngModel" &gt;

&lt;div *ngIf="name.invalid &amp;&amp; (name.dirty || name.touched)"
    class="alert alert-danger"&gt;

  &lt;div *ngIf="name.errors.required"&gt;
    Name is required.
  &lt;/div&gt;
  &lt;div *ngIf="name.errors.minlength"&gt;
    Name must be at least 4 characters long.
  &lt;/div&gt;
  &lt;div *ngIf="name.errors.forbiddenName"&gt;
    Name cannot be Bob.
  &lt;/div&gt;

&lt;/div&gt;</pre> <p>Note the following:</p> <ul> <li> <p>The <code>&lt;input&gt;</code> element carries the HTML validation attributes: <code>required</code> and <code><a href="../../api/forms/minlengthvalidator/" class="code-anchor">minlength</a></code>. It also carries a custom validator directive, <code>forbiddenName</code>. For more information, see <a href="../form-validation/#custom-validators">Custom validators</a> section.</p> </li> <li> <p><code>#name="<a href="../../api/forms/ngmodel/" class="code-anchor">ngModel</a>"</code> exports <code><a href="../../api/forms/ngmodel/" class="code-anchor">NgModel</a></code> into a local variable called <code>name</code>. <code><a href="../../api/forms/ngmodel/" class="code-anchor">NgModel</a></code> mirrors many of the properties of its underlying <code><a href="../../api/forms/formcontrol/" class="code-anchor">FormControl</a></code> instance, so you can use this in the template to check for control states such as <code>valid</code> and <code>dirty</code>. For a full list of control properties, see the <a href="../../api/forms/abstractcontrol/">AbstractControl</a> API reference.</p> </li> <li> <p>The <code>*<a href="../../api/common/ngif/" class="code-anchor">ngIf</a></code> on the <code>&lt;div&gt;</code> element reveals a set of nested message <code>divs</code> but only if the <code>name</code> is invalid and the control is either <code>dirty</code> or <code>touched</code>.</p> </li> <li> <p>Each nested <code>&lt;div&gt;</code> can present a custom message for one of the possible validation errors. There are messages for <code>required</code>, <code><a href="../../api/forms/minlengthvalidator/" class="code-anchor">minlength</a></code>, and <code>forbiddenName</code>.</p> </li> </ul> <blockquote class="alert is-helpful"> <h4 id="why-check-dirty-and-touched">Why check <em>dirty</em> and <em>touched</em>?</h4> <p>You may not want your application to display errors before the user has a chance to edit the form. The checks for <code>dirty</code> and <code>touched</code> prevent errors from showing until the user does one of two things: changes the value, turning the control dirty; or blurs the form control element, setting the control to touched.</p> </blockquote> <h2 id="reactive-form-validation">Reactive form validation</h2> <p>In a reactive form, the source of truth is the component class. Instead of adding validators through attributes in the template, you add validator functions directly to the form control model in the component class. Angular then calls these functions whenever the value of the control changes.</p> <h3 id="validator-functions">Validator functions</h3> <p>There are two types of validator functions: sync validators and async validators.</p> <ul> <li> <p><strong>Sync validators</strong>: functions that take a control instance and immediately return either a set of validation errors or <code>null</code>. You can pass these in as the second argument when you instantiate a <code><a href="../../api/forms/formcontrol/" class="code-anchor">FormControl</a></code>.</p> </li> <li> <p><strong>Async validators</strong>: functions that take a control instance and return a Promise or Observable that later emits a set of validation errors or <code>null</code>. You can pass these in as the third argument when you instantiate a <code><a href="../../api/forms/formcontrol/" class="code-anchor">FormControl</a></code>.</p> </li> </ul> <p>Note: for performance reasons, Angular only runs async validators if all sync validators pass. Each must complete before errors are set.</p> <h3 id="built-in-validators">Built-in validators</h3> <p>You can choose to <a href="../form-validation/#custom-validators">write your own validator functions</a>, or you can use some of Angular's built-in validators.</p> <p>The same built-in validators that are available as attributes in template-driven forms, such as <code>required</code> and <code><a href="../../api/forms/minlengthvalidator/" class="code-anchor">minlength</a></code>, are all available to use as functions from the <code><a href="../../api/forms/validators/" class="code-anchor">Validators</a></code> class. For a full list of built-in validators, see the <a href="../../api/forms/validators/">Validators</a> API reference.</p> <p>To update the hero form to be a reactive form, you can use some of the same built-in validatorsâ€”this time, in function form. See below:</p>  <pre header="reactive/hero-form-reactive.component.ts (validator functions)" data-language="typescript">ngOnInit(): void {
  this.heroForm = new FormGroup({
    'name': new FormControl(this.hero.name, [
      Validators.required,
      Validators.minLength(4),
      forbiddenNameValidator(/bob/i) // &lt;-- Here's how you pass in the custom validator.
    ]),
    'alterEgo': new FormControl(this.hero.alterEgo),
    'power': new FormControl(this.hero.power, Validators.required)
  });

}

get name() { return this.heroForm.get('name'); }

get power() { return this.heroForm.get('power'); }</pre> <p>Note that:</p> <ul> <li>The name control sets up two built-in validatorsâ€”<code>Validators.required</code> and <code>Validators.minLength(4)</code>â€”and one custom validator, <code>forbiddenNameValidator</code>. For more details see the <a href="../form-validation/#custom-validators">Custom validators</a> section in this guide.</li> <li>As these validators are all sync validators, you pass them in as the second argument.</li> <li>Support multiple validators by passing the functions in as an array.</li> <li>This example adds a few getter methods. In a reactive form, you can always access any form control through the <code>get</code> method on its parent group, but sometimes it's useful to define getters as shorthands for the template.</li> </ul> <p>If you look at the template for the name input again, it is fairly similar to the template-driven example.</p> <pre header="reactive/hero-form-reactive.component.html (name with error msg)" data-language="html">&lt;input id="name" class="form-control"
      formControlName="name" required &gt;

&lt;div *ngIf="name.invalid &amp;&amp; (name.dirty || name.touched)"
    class="alert alert-danger"&gt;

  &lt;div *ngIf="name.errors.required"&gt;
    Name is required.
  &lt;/div&gt;
  &lt;div *ngIf="name.errors.minlength"&gt;
    Name must be at least 4 characters long.
  &lt;/div&gt;
  &lt;div *ngIf="name.errors.forbiddenName"&gt;
    Name cannot be Bob.
  &lt;/div&gt;
&lt;/div&gt;</pre> <p>Key takeaways:</p> <ul> <li>The form no longer exports any directives, and instead uses the <code>name</code> getter defined in the component class.</li> <li>The <code>required</code> attribute is still present. While it's not necessary for validation purposes, you may want to keep it in your template for CSS styling or accessibility reasons.</li> </ul> <h2 id="custom-validators">Custom validators</h2> <p>Since the built-in validators won't always match the exact use case of your application, sometimes you'll want to create a custom validator.</p> <p>Consider the <code>forbiddenNameValidator</code> function from previous <a href="../form-validation/#reactive-component-class">examples</a> in this guide. Here's what the definition of that function looks like:</p> <pre header="shared/forbidden-name.directive.ts (forbiddenNameValidator)" data-language="typescript">/** A hero's name can't match the given regular expression */
export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn {
  return (control: AbstractControl): {[key: string]: any} | null =&gt; {
    const forbidden = nameRe.test(control.value);
    return forbidden ? {'forbiddenName': {value: control.value}} : null;
  };
}</pre> <p>The function is actually a factory that takes a regular expression to detect a <em>specific</em> forbidden name and returns a validator function.</p> <p>In this sample, the forbidden name is "bob", so the validator will reject any hero name containing "bob". Elsewhere it could reject "alice" or any name that the configuring regular expression matches.</p> <p>The <code>forbiddenNameValidator</code> factory returns the configured validator function. That function takes an Angular control object and returns <em>either</em> null if the control value is valid <em>or</em> a validation error object. The validation error object typically has a property whose name is the validation key, <code>'forbiddenName'</code>, and whose value is an arbitrary dictionary of values that you could insert into an error message, <code>{name}</code>.</p> <p>Custom async validators are similar to sync validators, but they must instead return a Promise or Observable that later emits null or a validation error object. In the case of an Observable, the Observable must complete, at which point the form uses the last value emitted for validation.</p> <h3 id="adding-to-reactive-forms">Adding to reactive forms</h3> <p>In reactive forms, custom validators are fairly simple to add. All you have to do is pass the function directly to the <code><a href="../../api/forms/formcontrol/" class="code-anchor">FormControl</a></code>.</p> <pre header="reactive/hero-form-reactive.component.ts (validator functions)" data-language="typescript">this.heroForm = new FormGroup({
  'name': new FormControl(this.hero.name, [
    Validators.required,
    Validators.minLength(4),
    forbiddenNameValidator(/bob/i) // &lt;-- Here's how you pass in the custom validator.
  ]),
  'alterEgo': new FormControl(this.hero.alterEgo),
  'power': new FormControl(this.hero.power, Validators.required)
});</pre> <h3 id="adding-to-template-driven-forms">Adding to template-driven forms</h3> <p>In template-driven forms, you don't have direct access to the <code><a href="../../api/forms/formcontrol/" class="code-anchor">FormControl</a></code> instance, so you can't pass the validator in like you can for reactive forms. Instead, you need to add a directive to the template.</p> <p>The corresponding <code>ForbiddenValidatorDirective</code> serves as a wrapper around the <code>forbiddenNameValidator</code>.</p> <p>Angular recognizes the directive's role in the validation process because the directive registers itself with the <code><a href="../../api/forms/ng_validators/" class="code-anchor">NG_VALIDATORS</a></code> provider, a provider with an extensible collection of validators.</p> <pre header="shared/forbidden-name.directive.ts (providers)" data-language="typescript">providers: [{provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true}]</pre> <p>The directive class then implements the <code><a href="../../api/forms/validator/" class="code-anchor">Validator</a></code> interface, so that it can easily integrate with Angular forms. Here is the rest of the directive to help you get an idea of how it all comes together:</p> <pre header="shared/forbidden-name.directive.ts (directive)" data-language="typescript">@Directive({
  selector: '[appForbiddenName]',
  providers: [{provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true}]
})
export class ForbiddenValidatorDirective implements Validator {
  @Input('appForbiddenName') forbiddenName: string;

  validate(control: AbstractControl): {[key: string]: any} | null {
    return this.forbiddenName ? forbiddenNameValidator(new RegExp(this.forbiddenName, 'i'))(control)
                              : null;
  }
}</pre> <p>Once the <code>ForbiddenValidatorDirective</code> is ready, you can simply add its selector, <code>appForbiddenName</code>, to any input element to activate it. For example:</p> <pre header="template/hero-form-template.component.html (forbidden-name-input)" data-language="html">&lt;input id="name" name="name" class="form-control"
      required minlength="4" appForbiddenName="bob"
      [(ngModel)]="hero.name" #name="ngModel" &gt;</pre> <blockquote class="alert is-helpful"> <p>You may have noticed that the custom validation directive is instantiated with <code>useExisting</code> rather than <code>useClass</code>. The registered validator must be <em>this instance</em> of the <code>ForbiddenValidatorDirective</code>â€”the instance in the form with its <code>forbiddenName</code> property bound to â€œbob". If you were to replace <code>useExisting</code> with <code>useClass</code>, then youâ€™d be registering a new class instance, one that doesnâ€™t have a <code>forbiddenName</code>.</p> </blockquote> <h2 id="control-status-css-classes">Control status CSS classes</h2> <p>Like in AngularJS, Angular automatically mirrors many control properties onto the form control element as CSS classes. You can use these classes to style form control elements according to the state of the form. The following classes are currently supported:</p> <ul> <li><code>.ng-valid</code></li> <li><code>.ng-invalid</code></li> <li><code>.ng-pending</code></li> <li><code>.ng-pristine</code></li> <li><code>.ng-dirty</code></li> <li><code>.ng-untouched</code></li> <li><code>.ng-touched</code></li> </ul> <p>The hero form uses the <code>.ng-valid</code> and <code>.ng-invalid</code> classes to set the color of each form control's border.</p> <pre header="forms.css (status classes)" data-language="css">.ng-valid[required], .ng-valid.required  {
  border-left: 5px solid #42A948; /* green */
}

.ng-invalid:not(form)  {
  border-left: 5px solid #a94442; /* red */
}</pre> <h2 id="cross-field-validation">Cross field validation</h2> <p>This section shows how to perform cross field validation. It assumes some basic knowledge of creating custom validators.</p> <blockquote class="alert is-helpful"> <p>If you haven't created custom validators before, start by reviewing the <a href="../form-validation/#custom-validators">custom validators section</a>.</p> </blockquote> <p>In the following section, we will make sure that our heroes do not reveal their true identities by filling out the Hero Form. We will do that by validating that the hero names and alter egos do not match.</p> <h3 id="adding-to-reactive-forms-1">Adding to reactive forms</h3> <p>The form has the following structure:</p> <pre data-language="javascript">const heroForm = new FormGroup({
  'name': new FormControl(),
  'alterEgo': new FormControl(),
  'power': new FormControl()
});</pre> <p>Notice that the name and alterEgo are sibling controls. To evaluate both controls in a single custom validator, we should perform the validation in a common ancestor control: the <code><a href="../../api/forms/formgroup/" class="code-anchor">FormGroup</a></code>. That way, we can query the <code><a href="../../api/forms/formgroup/" class="code-anchor">FormGroup</a></code> for the child controls which will allow us to compare their values.</p> <p>To add a validator to the <code><a href="../../api/forms/formgroup/" class="code-anchor">FormGroup</a></code>, pass the new validator in as the second argument on creation.</p> <pre data-language="javascript">const heroForm = new FormGroup({
  'name': new FormControl(),
  'alterEgo': new FormControl(),
  'power': new FormControl()
}, { validators: identityRevealedValidator });</pre> <p>The validator code is as follows:</p> <pre header="shared/identity-revealed.directive.ts" data-language="typescript">/** A hero's name can't match the hero's alter ego */
export const identityRevealedValidator: ValidatorFn = (control: FormGroup): ValidationErrors | null =&gt; {
  const name = control.get('name');
  const alterEgo = control.get('alterEgo');

  return name &amp;&amp; alterEgo &amp;&amp; name.value === alterEgo.value ? { 'identityRevealed': true } : null;
};</pre> <p>The identity validator implements the <code><a href="../../api/forms/validatorfn/" class="code-anchor">ValidatorFn</a></code> interface. It takes an Angular control object as an argument and returns either null if the form is valid, or <code><a href="../../api/forms/validationerrors/" class="code-anchor">ValidationErrors</a></code> otherwise.</p> <p>First we retrieve the child controls by calling the <code><a href="../../api/forms/formgroup/" class="code-anchor">FormGroup</a></code>'s <a href="../../api/forms/abstractcontrol/#get">get</a> method. Then we simply compare the values of the <code>name</code> and <code>alterEgo</code> controls.</p> <p>If the values do not match, the hero's identity remains secret, and we can safely return null. Otherwise, the hero's identity is revealed and we must mark the form as invalid by returning an error object.</p> <p>Next, to provide better user experience, we show an appropriate error message when the form is invalid. </p>
<pre header="reactive/hero-form-template.component.html" data-language="html">&lt;div *ngIf="heroForm.errors?.identityRevealed &amp;&amp; (heroForm.touched || heroForm.dirty)" class="cross-validation-error-message alert alert-danger"&gt;
    Name cannot match alter ego.
&lt;/div&gt;</pre> <p>Note that we check if:</p> <ul> <li>the <code><a href="../../api/forms/formgroup/" class="code-anchor">FormGroup</a></code> has the cross validation error returned by the <code>identityRevealed</code> validator,</li> <li>the user is yet to <a href="../form-validation/#why-check-dirty-and-touched">interact</a> with the form.</li> </ul> <h3 id="adding-to-template-driven-forms-1">Adding to template driven forms</h3> <p>First we must create a directive that will wrap the validator function. We provide it as the validator using the <code><a href="../../api/forms/ng_validators/" class="code-anchor">NG_VALIDATORS</a></code> token. If you are not sure why, or you do not fully understand the syntax, revisit the previous <a href="../form-validation/#adding-to-template-driven-forms">section</a>.</p> <pre header="shared/identity-revealed.directive.ts" data-language="typescript">@Directive({
  selector: '[appIdentityRevealed]',
  providers: [{ provide: NG_VALIDATORS, useExisting: IdentityRevealedValidatorDirective, multi: true }]
})
export class IdentityRevealedValidatorDirective implements Validator {
  validate(control: AbstractControl): ValidationErrors {
    return identityRevealedValidator(control)
  }
}</pre> <p>Next, we have to add the directive to the html template. Since the validator must be registered at the highest level in the form, we put the directive on the <code>form</code> tag. </p>
<pre header="template/hero-form-template.component.html" data-language="html">&lt;form #heroForm="ngForm" appIdentityRevealed&gt;</pre> <p>To provide better user experience, we show an appropriate error message when the form is invalid. </p>
<pre header="template/hero-form-template.component.html" data-language="html">&lt;div *ngIf="heroForm.errors?.identityRevealed &amp;&amp; (heroForm.touched || heroForm.dirty)" class="cross-validation-error-message alert alert-danger"&gt;
    Name cannot match alter ego.
&lt;/div&gt;</pre> <p>Note that we check if:</p> <ul> <li>the form has the cross validation error returned by the <code>identityRevealed</code> validator,</li> <li>the user is yet to <a href="../form-validation/#why-check-dirty-and-touched">interact</a> with the form.</li> </ul> <p>This completes the cross validation example. We managed to:</p> <ul> <li>validate the form based on the values of two sibling controls,</li> <li>show a descriptive error message after the user interacted with the form and the validation failed.</li> </ul> <h2 id="async-validation">Async Validation</h2> <p>This section shows how to create asynchronous validators. It assumes some basic knowledge of creating <a href="../form-validation/#custom-validators">custom validators</a>.</p> <h3 id="the-basics">The Basics</h3> <p>Just like synchronous validators have the <code><a href="../../api/forms/validatorfn/" class="code-anchor">ValidatorFn</a></code> and <code><a href="../../api/forms/validator/" class="code-anchor">Validator</a></code> interfaces, asynchronous validators have their own counterparts: <code><a href="../../api/forms/asyncvalidatorfn/" class="code-anchor">AsyncValidatorFn</a></code> and <code><a href="../../api/forms/asyncvalidator/" class="code-anchor">AsyncValidator</a></code>.</p> <p>They are very similar with the only difference being:</p> <ul> <li>They must return a Promise or an Observable,</li> <li>The observable returned must be finite, meaning it must complete at some point. To convert an infinite observable into a finite one, pipe the observable through a filtering operator such as <code>first</code>, <code>last</code>, <code>take</code>, or <code>takeUntil</code>.</li> </ul> <p>It is important to note that the asynchronous validation happens after the synchronous validation, and is performed only if the synchronous validation is successful. This check allows forms to avoid potentially expensive async validation processes such as an HTTP request if more basic validation methods fail.</p> <p>After asynchronous validation begins, the form control enters a <code>pending</code> state. You can inspect the control's <code>pending</code> property and use it to give visual feedback about the ongoing validation.</p> <p>A common UI pattern is to show a spinner while the async validation is being performed. The following example presents how to achieve this with template-driven forms:</p> <pre data-language="html">&lt;input [(ngModel)]="name" #model="ngModel" appSomeAsyncValidator&gt;
&lt;app-spinner *ngIf="model.pending"&gt;&lt;/app-spinner&gt;</pre> <h3 id="implementing-custom-async-validator">Implementing Custom Async Validator</h3> <p>In the following section, validation is performed asynchronously to ensure that our heroes pick an alter ego that is not already taken. New heroes are constantly enlisting and old heroes are leaving the service. That means that we do not have the list of available alter egos ahead of time.</p> <p>To validate the potential alter ego, we need to consult a central database of all currently enlisted heroes. The process is asynchronous, so we need a special validator for that.</p> <p>Let's start by creating the validator class.</p> <pre data-language="typescript">@Injectable({ providedIn: 'root' })
export class UniqueAlterEgoValidator implements AsyncValidator {
  constructor(private heroesService: HeroesService) {}

  validate(
    ctrl: AbstractControl
  ): Promise&lt;ValidationErrors | null&gt; | Observable&lt;ValidationErrors | null&gt; {
    return this.heroesService.isAlterEgoTaken(ctrl.value).pipe(
      map(isTaken =&gt; (isTaken ? { uniqueAlterEgo: true } : null)),
      catchError(() =&gt; null)
    );
  }
}</pre> <p>As you can see, the <code>UniqueAlterEgoValidator</code> class implements the <code><a href="../../api/forms/asyncvalidator/" class="code-anchor">AsyncValidator</a></code> interface. In the constructor, we inject the <code>HeroesService</code> that has the following interface:</p> <pre data-language="typescript">interface HeroesService {
  isAlterEgoTaken: (alterEgo: string) =&gt; Observable&lt;boolean&gt;;
}</pre> <p>In a real world application, the <code>HeroesService</code> is responsible for making an HTTP request to the hero database to check if the alter ego is available. From the validator's point of view, the actual implementation of the service is not important, so we can just code against the <code>HeroesService</code> interface.</p> <p>As the validation begins, the <code>UniqueAlterEgoValidator</code> delegates to the <code>HeroesService</code> <code>isAlterEgoTaken()</code> method with the current control value. At this point the control is marked as <code>pending</code> and remains in this state until the observable chain returned from the <code>validate()</code> method completes.</p> <p>The <code>isAlterEgoTaken()</code> method dispatches an HTTP request that checks if the alter ego is available, and returns <code>Observable&lt;boolean&gt;</code> as the result. We pipe the response through the <code>map</code> operator and transform it into a validation result. As always, we return <code>null</code> if the form is valid, and <code><a href="../../api/forms/validationerrors/" class="code-anchor">ValidationErrors</a></code> if it is not. We make sure to handle any potential errors with the <code>catchError</code> operator.</p> <p>Here we decided that <code>isAlterEgoTaken()</code> error is treated as a successful validation, because failure to make a validation request does not necessarily mean that the alter ego is invalid. You could handle the error differently and return the <code>ValidationError</code> object instead.</p> <p>After some time passes, the observable chain completes and the async validation is done. The <code>pending</code> flag is set to <code>false</code>, and the form validity is updated.</p> <h3 id="note-on-performance">Note on performance</h3> <p>By default, all validators are run after every form value change. With synchronous validators, this will not likely have a noticeable impact on application performance. However, it's common for async validators to perform some kind of HTTP request to validate the control. Dispatching an HTTP request after every keystroke could put a strain on the backend API, and should be avoided if possible.</p> <p>We can delay updating the form validity by changing the <code>updateOn</code> property from <code>change</code> (default) to <code>submit</code> or <code>blur</code>.</p> <p>With template-driven forms:</p> <pre data-language="html">&lt;input [(ngModel)]="name" [ngModelOptions]="{updateOn: 'blur'}"&gt;</pre> <p>With reactive forms:</p> <pre data-language="typescript">new FormControl('', {updateOn: 'blur'});</pre> <p><strong>You can run the live example to see the complete reactive and template-driven example code.</strong></p>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 2010â€“2019 Google, Inc.<br>Licensed under the Creative Commons Attribution License 4.0.<br>
    <a href="https://v7.angular.io/guide/form-validation" class="_attribution-link" target="_blank">https://v7.angular.io/guide/form-validation</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
