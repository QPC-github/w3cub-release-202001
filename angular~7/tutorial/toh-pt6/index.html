
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>6. HTTP - Angular 7 - W3cubDocs</title>
  
  <meta name="description" content=" In this tutorial, you&#39;ll add the following data persistence features with help from Angular&#39;s HttpClient. ">
  <meta name="keywords" content="http, -, angular, angular~7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/angular~7/tutorial/toh-pt6/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/angular~7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/angular~7/" class="_nav-link" title="" style="margin-left:0;">Angular 7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _angular">
				
				
<h1 id="http">HTTP</h1> <p>In this tutorial, you'll add the following data persistence features with help from Angular's <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code>.</p> <ul> <li>The <code>HeroService</code> gets hero data with HTTP requests.</li> <li>Users can add, edit, and delete heroes and save these changes over HTTP.</li> <li>Users can search for heroes by name.</li> </ul> <p>When you're done with this page, the app should look like this live example.</p> <h2 id="enable-http-services">Enable HTTP services</h2> <p><code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> is Angular's mechanism for communicating with a remote server over HTTP. </p> <p>To make <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> available everywhere in the app:</p> <ul> <li>open the root <code>AppModule</code> </li> <li>import the <code><a href="../../api/common/http/httpclientmodule/" class="code-anchor">HttpClientModule</a></code> symbol from <code>@angular/common/<a href="../../api/common/http/" class="code-anchor">http</a></code>
</li> </ul> <pre header="src/app/app.module.ts (Http Client import)" data-language="typescript">import { HttpClientModule }    from '@angular/common/http';</pre> <ul> <li>add it to the <code>@<a href="../../api/core/ngmodule/#imports" class="code-anchor">NgModule.imports</a></code> array</li> </ul> <h2 id="simulate-a-data-server">Simulate a data server</h2> <p>This tutorial sample <em>mimics</em> communication with a remote data server by using the <a href="https://github.com/angular/in-memory-web-api" title="In-memory Web API" target="_blank"><em>In-memory Web API</em></a> module.</p> <p>After installing the module, the app will make requests to and receive responses from the <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> without knowing that the <em>In-memory Web API</em> is intercepting those requests, applying them to an in-memory data store, and returning simulated responses.</p> <p>This facility is a great convenience for the tutorial. You won't have to set up a server to learn about <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code>.</p> <p>It may also be convenient in the early stages of your own app development when the server's web api is ill-defined or not yet implemented.</p> <blockquote class="alert is-important"> <p><strong>Important:</strong> the <em>In-memory Web API</em> module has nothing to do with HTTP in Angular.</p> <p>If you're just <em>reading</em> this tutorial to learn about <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code>, you can <a href="../toh-pt6/#import-heroes">skip over</a> this step. If you're <em>coding along</em> with this tutorial, stay here and add the <em>In-memory Web API</em> now.</p> </blockquote> <p>Install the <em>In-memory Web API</em> package from <em>npm</em></p> <pre data-language="sh">npm install angular-in-memory-web-api --save</pre> <p>Import the <code>HttpClientInMemoryWebApiModule</code> and the <code>InMemoryDataService</code> class, which you will create in a moment.</p> <pre header="src/app/app.module.ts (In-memory Web API imports)" data-language="typescript">import { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';
import { InMemoryDataService }  from './in-memory-data.service';</pre> <p>Add the <code>HttpClientInMemoryWebApiModule</code> to the <code>@<a href="../../api/core/ngmodule/#imports" class="code-anchor">NgModule.imports</a></code> array— <em>after importing the <code><a href="../../api/common/http/httpclientmodule/" class="code-anchor">HttpClientModule</a></code></em>, —while configuring it with the <code>InMemoryDataService</code>.</p> <pre data-language="typescript">HttpClientModule,

// The HttpClientInMemoryWebApiModule module intercepts HTTP requests
// and returns simulated server responses.
// Remove it when a real server is ready to receive requests.
HttpClientInMemoryWebApiModule.forRoot(
  InMemoryDataService, { dataEncapsulation: false }
)</pre> <p>The <code><a href="../../api/router/routermodule/#forRoot" class="code-anchor">forRoot()</a></code> configuration method takes an <code>InMemoryDataService</code> class that primes the in-memory database.</p> <p>The class <code>src/app/in-memory-data.service.ts</code> is generated by the following command:</p> <pre data-language="sh">ng generate service InMemoryData</pre> <p>This class has the following content:</p> <pre header="src/app/in-memory-data.service.ts" data-language="typescript">import { InMemoryDbService } from 'angular-in-memory-web-api';
import { Hero } from './hero';
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class InMemoryDataService implements InMemoryDbService {
  createDb() {
    const heroes = [
      { id: 11, name: 'Mr. Nice' },
      { id: 12, name: 'Narco' },
      { id: 13, name: 'Bombasto' },
      { id: 14, name: 'Celeritas' },
      { id: 15, name: 'Magneta' },
      { id: 16, name: 'RubberMan' },
      { id: 17, name: 'Dynama' },
      { id: 18, name: 'Dr IQ' },
      { id: 19, name: 'Magma' },
      { id: 20, name: 'Tornado' }
    ];
    return {heroes};
  }

  // Overrides the genId method to ensure that a hero always has an id.
  // If the heroes array is empty,
  // the method below returns the initial number (11).
  // if the heroes array is not empty, the method below returns the highest
  // hero id + 1.
  genId(heroes: Hero[]): number {
    return heroes.length &gt; 0 ? Math.max(...heroes.map(hero =&gt; hero.id)) + 1 : 11;
  }
}</pre> <p>This file replaces <code>mock-heroes.ts</code>, which is now safe to delete.</p> <p>When your server is ready, detach the <em>In-memory Web API</em>, and the app's requests will go through to the server.</p> <p>Now back to the <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> story.</p>  <h2 id="heroes-and-http">Heroes and HTTP</h2> <p>Import some HTTP symbols that you'll need:</p> <pre header="src/app/hero.service.ts (import HTTP symbols)" data-language="typescript">import { HttpClient, HttpHeaders } from '@angular/common/http';</pre> <p>Inject <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> into the constructor in a private property called <code><a href="../../api/common/http/" class="code-anchor">http</a></code>.</p> <pre data-language="typescript">constructor(
  private http: HttpClient,
  private messageService: MessageService) { }</pre> <p>Keep injecting the <code>MessageService</code>. You'll call it so frequently that you'll wrap it in a private <code><a href="../../api/animations/browser/testing/mockanimationdriver/#log" class="code-anchor">log</a>()</code> method.</p> <pre data-language="typescript">/** Log a HeroService message with the MessageService */
private log(message: string) {
  this.messageService.add(`HeroService: ${message}`);
}</pre> <p>Define the <code>heroesUrl</code> of the form <code>:base/:collectionName</code> with the address of the heroes resource on the server. Here <code>base</code> is the resource to which requests are made, and <code>collectionName</code> is the heroes data object in the <code>in-memory-data-service.ts</code>.</p> <pre data-language="typescript">private heroesUrl = 'api/heroes';  // URL to web api</pre> <h3 id="get-heroes-with-httpclient">Get heroes with <code>HttpClient</code>
</h3> <p>The current <code>HeroService.getHeroes()</code> uses the RxJS <code>of()</code> function to return an array of mock heroes as an <code>Observable&lt;Hero[]&gt;</code>.</p> <pre header="src/app/hero.service.ts (getHeroes with RxJs 'of()')" data-language="typescript">getHeroes(): Observable&lt;Hero[]&gt; {
  return of(HEROES);
}</pre> <p>Convert that method to use <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> </p>
<pre data-language="typescript">/** GET heroes from the server */
getHeroes (): Observable&lt;Hero[]&gt; {
  return this.http.get&lt;Hero[]&gt;(this.heroesUrl)
}</pre> <p>Refresh the browser. The hero data should successfully load from the mock server.</p> <p>You've swapped <code>of</code> for <code>http.get</code> and the app keeps working without any other changes because both functions return an <code>Observable&lt;Hero[]&gt;</code>.</p> <h3 id="http-methods-return-one-value">Http methods return one value</h3> <p>All <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> methods return an RxJS <code>Observable</code> of something.</p> <p>HTTP is a request/response protocol. You make a request, it returns a single response.</p> <p>In general, an observable <em>can</em> return multiple values over time. An observable from <code><a href="../../api/common/http/httpclient/" class="code-anchor">HttpClient</a></code> always emits a single value and then completes, never to emit again.</p> <p>This particular <code>HttpClient.get</code> call returns an <code>Observable&lt;Hero[]&gt;</code>, literally "<em>an observable of hero arrays</em>". In practice, it will only return a single hero array.</p> <h3 id="httpclientget-returns-response-data">
<code>HttpClient.get</code> returns response data</h3> <p><code>HttpClient.get</code> returns the <em>body</em> of the response as an untyped JSON object by default. Applying the optional type specifier, <code>&lt;Hero[]&gt;</code> , gives you a typed result object.</p> <p>The shape of the JSON data is determined by the server's data API. The <em>Tour of Heroes</em> data API returns the hero data as an array.</p> <blockquote class="alert is-helpful"> <p>Other APIs may bury the data that you want within an object. You might have to dig that data out by processing the <code>Observable</code> result with the RxJS <code>map</code> operator.</p> <p>Although not discussed here, there's an example of <code>map</code> in the <code>getHeroNo404()</code> method included in the sample source code.</p> </blockquote> <h3 id="error-handling">Error handling</h3> <p>Things go wrong, especially when you're getting data from a remote server. The <code>HeroService.getHeroes()</code> method should catch errors and do something appropriate.</p> <p>To catch errors, you <strong>"pipe" the observable</strong> result from <code>http.get()</code> through an RxJS <code>catchError()</code> operator.</p> <p>Import the <code>catchError</code> symbol from <code>rxjs/operators</code>, along with some other operators you'll need later.</p> <pre data-language="typescript">import { catchError, map, tap } from 'rxjs/operators';</pre> <p>Now extend the observable result with the <code>.pipe()</code> method and give it a <code>catchError()</code> operator.</p> <pre data-language="typescript">getHeroes (): Observable&lt;Hero[]&gt; {
  return this.http.get&lt;Hero[]&gt;(this.heroesUrl)
    .pipe(
      catchError(this.handleError&lt;Hero[]&gt;('getHeroes', []))
    );
}</pre> <p>The <code>catchError()</code> operator intercepts an <strong><code>Observable</code> that failed</strong>. It passes the error an <em>error handler</em> that can do what it wants with the error.</p> <p>The following <code><a href="../../api/core/errorhandler/#handleError" class="code-anchor">handleError()</a></code> method reports the error and then returns an innocuous result so that the application keeps working.</p> <h4 id="handleerror"><em>handleError</em></h4> <p>The following <code><a href="../../api/core/errorhandler/#handleError" class="code-anchor">handleError()</a></code> will be shared by many <code>HeroService</code> methods so it's generalized to meet their different needs.</p> <p>Instead of handling the error directly, it returns an <em>error handler</em> function to <code>catchError</code> that it has configured with both the name of the operation that failed and a safe return value.</p> <pre data-language="typescript">/**
 * Handle Http operation that failed.
 * Let the app continue.
 * @param operation - name of the operation that failed
 * @param result - optional value to return as the observable result
 */
private handleError&lt;T&gt; (operation = 'operation', result?: T) {
  return (error: any): Observable&lt;T&gt; =&gt; {

    // TODO: send the error to remote logging infrastructure
    console.error(error); // log to console instead

    // TODO: better job of transforming error for user consumption
    this.log(`${operation} failed: ${error.message}`);

    // Let the app keep running by returning an empty result.
    return of(result as T);
  };
}</pre> <p>After reporting the error to console, the handler constructs a user friendly message and returns a safe value to the app so it can keep working.</p> <p>Because each service method returns a different kind of <code>Observable</code> result, <code><a href="../../api/core/errorhandler/#handleError" class="code-anchor">handleError()</a></code> takes a type parameter so it can return the safe value as the type that the app expects.</p> <h3 id="tap-into-the-observable">Tap into the <code>Observable</code>
</h3> <p>The <code>HeroService</code> methods will <strong>tap</strong> into the flow of observable values and send a message (via <code><a href="../../api/animations/browser/testing/mockanimationdriver/#log" class="code-anchor">log</a>()</code>) to the message area at the bottom of the page.</p> <p>They'll do that with the RxJS <code>tap</code> operator, which <em>looks</em> at the observable values, does <em>something</em> with those values, and passes them along. The <code>tap</code> call back doesn't touch the values themselves.</p> <p>Here is the final version of <code>getHeroes</code> with the <code>tap</code> that logs the operation.</p> <pre data-language="typescript">/** GET heroes from the server */
getHeroes (): Observable&lt;Hero[]&gt; {
  return this.http.get&lt;Hero[]&gt;(this.heroesUrl)
    .pipe(
      tap(_ =&gt; this.log('fetched heroes')),
      catchError(this.handleError&lt;Hero[]&gt;('getHeroes', []))
    );
}</pre> <h3 id="get-hero-by-id">Get hero by id</h3> <p>Most web APIs support a <em>get by id</em> request in the form <code>:baseURL/:id</code>.</p> <p>Here, the <em>base URL</em> is the <code>heroesURL</code> defined in the <a href="../toh-pt6/#heroes-and-http">Heroes and HTTP</a> section (<code>api/heroes</code>) and <em>id</em> is the number of the hero that you want to retrieve. For example, <code>api/heroes/11</code>.</p> <p>Add a <code>HeroService.getHero()</code> method to make that request:</p> <pre header="src/app/hero.service.ts" data-language="typescript">/** GET hero by id. Will 404 if id not found */
getHero(id: number): Observable&lt;Hero&gt; {
  const url = `${this.heroesUrl}/${id}`;
  return this.http.get&lt;Hero&gt;(url).pipe(
    tap(_ =&gt; this.log(`fetched hero id=${id}`)),
    catchError(this.handleError&lt;Hero&gt;(`getHero id=${id}`))
  );
}</pre> <p>There are three significant differences from <code>getHeroes()</code>.</p> <ul> <li>it constructs a request URL with the desired hero's id.</li> <li>the server should respond with a single hero rather than an array of heroes.</li> <li>therefore, <code>getHero</code> returns an <code>Observable&lt;Hero&gt;</code> ("<em>an observable of Hero objects</em>") rather than an observable of hero <em>arrays</em> .</li> </ul> <h2 id="update-heroes">Update heroes</h2> <p>Edit a hero's name in the <em>hero detail</em> view. As you type, the hero name updates the heading at the top of the page. But when you click the "go back button", the changes are lost.</p> <p>If you want changes to persist, you must write them back to the server.</p> <p>At the end of the hero detail template, add a save button with a <code>click</code> event binding that invokes a new component method named <code>save()</code>.</p> <pre header="src/app/hero-detail/hero-detail.component.html (save)" data-language="html">&lt;button (click)="save()"&gt;save&lt;/button&gt;</pre> <p>Add the following <code>save()</code> method, which persists hero name changes using the hero service <code>updateHero()</code> method and then navigates back to the previous view.</p> <pre header="src/app/hero-detail/hero-detail.component.ts (save)" data-language="typescript">save(): void {
   this.heroService.updateHero(this.hero)
     .subscribe(() =&gt; this.goBack());
 }</pre> <h4 id="add-heroserviceupdatehero">Add <em>HeroService.updateHero()</em>
</h4> <p>The overall structure of the <code>updateHero()</code> method is similar to that of <code>getHeroes()</code>, but it uses <code>http.put()</code> to persist the changed hero on the server.</p> <pre header="src/app/hero.service.ts (update)" data-language="typescript">/** PUT: update the hero on the server */
updateHero (hero: Hero): Observable&lt;any&gt; {
  return this.http.put(this.heroesUrl, hero, httpOptions).pipe(
    tap(_ =&gt; this.log(`updated hero id=${hero.id}`)),
    catchError(this.handleError&lt;any&gt;('updateHero'))
  );
}</pre> <p>The <code><a href="../../api/common/http/httpclient/#put" class="code-anchor">HttpClient.put()</a></code> method takes three parameters</p> <ul> <li>the URL</li> <li>the data to update (the modified hero in this case)</li> <li>options</li> </ul> <p>The URL is unchanged. The heroes web API knows which hero to update by looking at the hero's <code>id</code>.</p> <p>The heroes web API expects a special header in HTTP save requests. That header is in the <code>httpOptions</code> constant defined in the <code>HeroService</code>.</p> <pre header="src/app/hero.service.ts" data-language="typescript">const httpOptions = {
  headers: new HttpHeaders({ 'Content-Type': 'application/json' })
};</pre> <p>Refresh the browser, change a hero name and save your change. Navigating to the previous view is implemented in the <code>save()</code> method defined in <code>HeroDetailComponent</code>. The hero now appears in the list with the changed name.</p> <h2 id="add-a-new-hero">Add a new hero</h2> <p>To add a hero, this app only needs the hero's name. You can use an <code>input</code> element paired with an add button.</p> <p>Insert the following into the <code>HeroesComponent</code> template, just after the heading:</p> <pre header="src/app/heroes/heroes.component.html (add)" data-language="html">&lt;div&gt;
  &lt;label&gt;Hero name:
    &lt;input #heroName /&gt;
  &lt;/label&gt;
  &lt;!-- (click) passes input value to add() and then clears the input --&gt;
  &lt;button (click)="add(heroName.value); heroName.value=''"&gt;
    add
  &lt;/button&gt;
&lt;/div&gt;</pre> <p>In response to a click event, call the component's click handler and then clear the input field so that it's ready for another name.</p> <pre header="src/app/heroes/heroes.component.ts (add)" data-language="typescript">add(name: string): void {
  name = name.trim();
  if (!name) { return; }
  this.heroService.addHero({ name } as Hero)
    .subscribe(hero =&gt; {
      this.heroes.push(hero);
    });
}</pre> <p>When the given name is non-blank, the handler creates a <code>Hero</code>-like object from the name (it's only missing the <code>id</code>) and passes it to the services <code>addHero()</code> method.</p> <p>When <code>addHero</code> saves successfully, the <code>subscribe</code> callback receives the new hero and pushes it into to the <code>heroes</code> list for display.</p> <p>You'll write <code>HeroService.addHero</code> in the next section.</p> <h4 id="add-heroserviceaddhero">Add <em>HeroService.addHero()</em>
</h4> <p>Add the following <code>addHero()</code> method to the <code>HeroService</code> class.</p> <pre header="src/app/hero.service.ts (addHero)" data-language="typescript">/** POST: add a new hero to the server */
addHero (hero: Hero): Observable&lt;Hero&gt; {
  return this.http.post&lt;Hero&gt;(this.heroesUrl, hero, httpOptions).pipe(
    tap((newHero: Hero) =&gt; this.log(`added hero w/ id=${newHero.id}`)),
    catchError(this.handleError&lt;Hero&gt;('addHero'))
  );
}</pre> <p><code>HeroService.addHero()</code> differs from <code>updateHero</code> in two ways.</p> <ul> <li>it calls <code><a href="../../api/common/http/httpclient/#post" class="code-anchor">HttpClient.post()</a></code> instead of <code>put()</code>.</li> <li>it expects the server to generate an id for the new hero, which it returns in the <code>Observable&lt;Hero&gt;</code> to the caller.</li> </ul> <p>Refresh the browser and add some heroes.</p> <h2 id="delete-a-hero">Delete a hero</h2> <p>Each hero in the heroes list should have a delete button.</p> <p>Add the following button element to the <code>HeroesComponent</code> template, after the hero name in the repeated <code>&lt;li&gt;</code> element.</p> <pre data-language="html">&lt;button class="delete" title="delete hero"
  (click)="delete(hero)"&gt;x&lt;/button&gt;</pre> <p>The HTML for the list of heroes should look like this:</p> <pre header="src/app/heroes/heroes.component.html (list of heroes)" data-language="html">&lt;ul class="heroes"&gt;
  &lt;li *ngFor="let hero of heroes"&gt;
    &lt;a routerLink="/detail/{{hero.id}}"&gt;
      &lt;span class="badge"&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
    &lt;/a&gt;
    &lt;button class="delete" title="delete hero"
      (click)="delete(hero)"&gt;x&lt;/button&gt;
  &lt;/li&gt;
&lt;/ul&gt;</pre> <p>To position the delete button at the far right of the hero entry, add some CSS to the <code>heroes.component.css</code>. You'll find that CSS in the <a href="../toh-pt6/#heroescomponent">final review code</a> below.</p> <p>Add the <code>delete()</code> handler to the component.</p> <pre header="src/app/heroes/heroes.component.ts (delete)" data-language="typescript">delete(hero: Hero): void {
  this.heroes = this.heroes.filter(h =&gt; h !== hero);
  this.heroService.deleteHero(hero).subscribe();
}</pre> <p>Although the component delegates hero deletion to the <code>HeroService</code>, it remains responsible for updating its own list of heroes. The component's <code>delete()</code> method immediately removes the <em>hero-to-delete</em> from that list, anticipating that the <code>HeroService</code> will succeed on the server.</p> <p>There's really nothing for the component to do with the <code>Observable</code> returned by <code>heroService.delete()</code>. <strong>It must subscribe anyway</strong>.</p> <blockquote class="alert is-important"> <p> If you neglect to <code>subscribe()</code>, the service will not send the delete request to the server! As a rule, an <code>Observable</code> <em>does nothing</em> until something subscribes!</p> <p> Confirm this for yourself by temporarily removing the <code>subscribe()</code>, clicking "Dashboard", then clicking "Heroes". You'll see the full list of heroes again.</p> </blockquote> <h4 id="add-heroservicedeletehero">Add <em>HeroService.deleteHero()</em>
</h4> <p>Add a <code>deleteHero()</code> method to <code>HeroService</code> like this.</p> <pre header="src/app/hero.service.ts (delete)" data-language="typescript">/** DELETE: delete the hero from the server */
deleteHero (hero: Hero | number): Observable&lt;Hero&gt; {
  const id = typeof hero === 'number' ? hero : hero.id;
  const url = `${this.heroesUrl}/${id}`;

  return this.http.delete&lt;Hero&gt;(url, httpOptions).pipe(
    tap(_ =&gt; this.log(`deleted hero id=${id}`)),
    catchError(this.handleError&lt;Hero&gt;('deleteHero'))
  );
}</pre> <p>Note that</p> <ul> <li>it calls <code>HttpClient.delete</code>.</li> <li>the URL is the heroes resource URL plus the <code>id</code> of the hero to delete</li> <li>you don't send data as you did with <code>put</code> and <code>post</code>.</li> <li>you still send the <code>httpOptions</code>.</li> </ul> <p>Refresh the browser and try the new delete functionality.</p> <h2 id="search-by-name">Search by name</h2> <p>In this last exercise, you learn to chain <code>Observable</code> operators together so you can minimize the number of similar HTTP requests and consume network bandwidth economically.</p> <p>You will add a <em>heroes search</em> feature to the <em>Dashboard</em>. As the user types a name into a search box, you'll make repeated HTTP requests for heroes filtered by that name. Your goal is to issue only as many requests as necessary.</p> <h4 id="heroservicesearchheroes"><em>HeroService.searchHeroes</em></h4> <p>Start by adding a <code>searchHeroes</code> method to the <code>HeroService</code>.</p> <pre header="src/app/hero.service.ts" data-language="typescript">/* GET heroes whose name contains search term */
searchHeroes(term: string): Observable&lt;Hero[]&gt; {
  if (!term.trim()) {
    // if not search term, return empty hero array.
    return of([]);
  }
  return this.http.get&lt;Hero[]&gt;(`${this.heroesUrl}/?name=${term}`).pipe(
    tap(_ =&gt; this.log(`found heroes matching "${term}"`)),
    catchError(this.handleError&lt;Hero[]&gt;('searchHeroes', []))
  );
}</pre> <p>The method returns immediately with an empty array if there is no search term. The rest of it closely resembles <code>getHeroes()</code>. The only significant difference is the URL, which includes a query string with the search term.</p> <h3 id="add-search-to-the-dashboard">Add search to the Dashboard</h3> <p>Open the <code>DashboardComponent</code> <em>template</em> and Add the hero search element, <code>&lt;app-hero-search&gt;</code>, to the bottom of the <code>DashboardComponent</code> template.</p> <pre header="src/app/dashboard/dashboard.component.html" data-language="html">&lt;h3&gt;Top Heroes&lt;/h3&gt;
&lt;div class="grid grid-pad"&gt;
  &lt;a *ngFor="let hero of heroes" class="col-1-4"
      routerLink="/detail/{{hero.id}}"&gt;
    &lt;div class="module hero"&gt;
      &lt;h4&gt;{{hero.name}}&lt;/h4&gt;
    &lt;/div&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;app-hero-search&gt;&lt;/app-hero-search&gt;</pre> <p>This template looks a lot like the <code>*<a href="../../api/common/ngforof/" class="code-anchor">ngFor</a></code> repeater in the <code>HeroesComponent</code> template.</p> <p>Unfortunately, adding this element breaks the app. Angular can't find a component with a selector that matches <code>&lt;app-hero-search&gt;</code>.</p> <p>The <code>HeroSearchComponent</code> doesn't exist yet. Fix that.</p> <h3 id="create-herosearchcomponent">Create <code>HeroSearchComponent</code>
</h3> <p>Create a <code>HeroSearchComponent</code> with the CLI.</p> <pre data-language="sh">ng generate component hero-search</pre> <p>The CLI generates the three <code>HeroSearchComponent</code> files and adds the component to the <code>AppModule</code> declarations</p> <p>Replace the generated <code>HeroSearchComponent</code> <em>template</em> with a text box and a list of matching search results like this.</p> <pre header="src/app/hero-search/hero-search.component.html" data-language="html">&lt;div id="search-component"&gt;
  &lt;h4&gt;Hero Search&lt;/h4&gt;

  &lt;input #searchBox id="search-box" (input)="search(searchBox.value)" /&gt;

  &lt;ul class="search-result"&gt;
    &lt;li *ngFor="let hero of heroes$ | async" &gt;
      &lt;a routerLink="/detail/{{hero.id}}"&gt;
        {{hero.name}}
      &lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</pre> <p>Add private CSS styles to <code>hero-search.component.css</code> as listed in the <a href="../toh-pt6/#herosearchcomponent">final code review</a> below.</p> <p>As the user types in the search box, an <em>input</em> event binding calls the component's <code>search()</code> method with the new search box value.</p>  <h3 id="asyncpipe"><code>AsyncPipe</code></h3> <p>As expected, the <code>*<a href="../../api/common/ngforof/" class="code-anchor">ngFor</a></code> repeats hero objects.</p> <p>Look closely and you'll see that the <code>*<a href="../../api/common/ngforof/" class="code-anchor">ngFor</a></code> iterates over a list called <code>heroes$</code>, not <code>heroes</code>.</p> <pre data-language="html">&lt;li *ngFor="let hero of heroes$ | async" &gt;</pre> <p>The <code>$</code> is a convention that indicates <code>heroes$</code> is an <code>Observable</code>, not an array.</p> <p>The <code>*<a href="../../api/common/ngforof/" class="code-anchor">ngFor</a></code> can't do anything with an <code>Observable</code>. But there's also a pipe character (<code>|</code>) followed by <code><a href="../../api/core/testing/async/" class="code-anchor">async</a></code>, which identifies Angular's <code><a href="../../api/common/asyncpipe/" class="code-anchor">AsyncPipe</a></code>.</p> <p>The <code><a href="../../api/common/asyncpipe/" class="code-anchor">AsyncPipe</a></code> subscribes to an <code>Observable</code> automatically so you won't have to do so in the component class.</p> <h3 id="fix-the-herosearchcomponent-class">Fix the <code>HeroSearchComponent</code> class</h3> <p>Replace the generated <code>HeroSearchComponent</code> class and metadata as follows.</p> <pre header="src/app/hero-search/hero-search.component.ts" data-language="typescript">import { Component, OnInit } from '@angular/core';

import { Observable, Subject } from 'rxjs';

import {
   debounceTime, distinctUntilChanged, switchMap
 } from 'rxjs/operators';

import { Hero } from '../hero';
import { HeroService } from '../hero.service';

@Component({
  selector: 'app-hero-search',
  templateUrl: './hero-search.component.html',
  styleUrls: [ './hero-search.component.css' ]
})
export class HeroSearchComponent implements OnInit {
  heroes$: Observable&lt;Hero[]&gt;;
  private searchTerms = new Subject&lt;string&gt;();

  constructor(private heroService: HeroService) {}

  // Push a search term into the observable stream.
  search(term: string): void {
    this.searchTerms.next(term);
  }

  ngOnInit(): void {
    this.heroes$ = this.searchTerms.pipe(
      // wait 300ms after each keystroke before considering the term
      debounceTime(300),

      // ignore new term if same as previous term
      distinctUntilChanged(),

      // switch to new search observable each time the term changes
      switchMap((term: string) =&gt; this.heroService.searchHeroes(term)),
    );
  }
}</pre> <p>Notice the declaration of <code>heroes$</code> as an <code>Observable</code> </p>
<pre data-language="typescript">heroes$: Observable&lt;Hero[]&gt;;</pre> <p>You'll set it in <a href="../toh-pt6/#search-pipe"><code>ngOnInit()</code></a>. Before you do, focus on the definition of <code>searchTerms</code>.</p> <h3 id="the-searchterms-rxjs-subject">The <code>searchTerms</code> RxJS subject</h3> <p>The <code>searchTerms</code> property is declared as an RxJS <code>Subject</code>.</p> <pre data-language="typescript">private searchTerms = new Subject&lt;string&gt;();

// Push a search term into the observable stream.
search(term: string): void {
  this.searchTerms.next(term);
}</pre> <p>A <code>Subject</code> is both a source of <em>observable</em> values and an <code>Observable</code> itself. You can subscribe to a <code>Subject</code> as you would any <code>Observable</code>.</p> <p>You can also push values into that <code>Observable</code> by calling its <code>next(value)</code> method as the <code>search()</code> method does.</p> <p>The <code>search()</code> method is called via an <em>event binding</em> to the textbox's <code>input</code> event.</p> <pre data-language="html">&lt;input #searchBox id="search-box" (input)="search(searchBox.value)" /&gt;</pre> <p>Every time the user types in the textbox, the binding calls <code>search()</code> with the textbox value, a "search term". The <code>searchTerms</code> becomes an <code>Observable</code> emitting a steady stream of search terms.</p>  <h3 id="chaining-rxjs-operators">Chaining RxJS operators</h3> <p>Passing a new search term directly to the <code>searchHeroes()</code> after every user keystroke would create an excessive amount of HTTP requests, taxing server resources and burning through the cellular network data plan.</p> <p>Instead, the <code>ngOnInit()</code> method pipes the <code>searchTerms</code> observable through a sequence of RxJS operators that reduce the number of calls to the <code>searchHeroes()</code>, ultimately returning an observable of timely hero search results (each a <code>Hero[]</code>).</p> <p>Here's the code.</p> <pre data-language="typescript">this.heroes$ = this.searchTerms.pipe(
  // wait 300ms after each keystroke before considering the term
  debounceTime(300),

  // ignore new term if same as previous term
  distinctUntilChanged(),

  // switch to new search observable each time the term changes
  switchMap((term: string) =&gt; this.heroService.searchHeroes(term)),
);</pre> <ul> <li>
<code>debounceTime(300)</code> waits until the flow of new string events pauses for 300 milliseconds before passing along the latest string. You'll never make requests more frequently than 300ms.</li> </ul> <ul> <li>
<code>distinctUntilChanged()</code> ensures that a request is sent only if the filter text changed.</li> </ul> <ul> <li>
<code>switchMap()</code> calls the search service for each search term that makes it through <code>debounce</code> and <code>distinctUntilChanged</code>. It cancels and discards previous search observables, returning only the latest search service observable.</li> </ul> <blockquote class="alert is-helpful"> <p> With the <a href="http://www.learnrxjs.io/operators/transformation/switchmap.html" target="_blank">switchMap operator</a>, every qualifying key event can trigger an <code><a href="../../api/common/http/httpclient/#get" class="code-anchor">HttpClient.get()</a></code> method call. Even with a 300ms pause between requests, you could have multiple HTTP requests in flight and they may not return in the order sent.</p> <p> <code>switchMap()</code> preserves the original request order while returning only the observable from the most recent HTTP method call. Results from prior calls are canceled and discarded.</p> <p> Note that <em>canceling</em> a previous <code>searchHeroes()</code> <em>Observable</em> doesn't actually abort a pending HTTP request. Unwanted results are simply discarded before they reach your application code.</p> </blockquote> <p>Remember that the component <em>class</em> does not subscribe to the <code>heroes$</code> <em>observable</em>. That's the job of the <a href="../toh-pt6/#asyncpipe"><code>AsyncPipe</code></a> in the template.</p> <h4 id="try-it">Try it</h4> <p>Run the app again. In the <em>Dashboard</em>, enter some text in the search box. If you enter characters that match any existing hero names, you'll see something like this.</p> <figure> <img src="data:image/png;base64,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" alt="Hero Search Component" width="240" height="224"> </figure> <h2 id="final-code-review">Final code review</h2> <p>Your app should look like this live example.</p> <p>Here are the code files discussed on this page (all in the <code>src/app/</code> folder).</p>    <h4 id="heroservice-inmemorydataservice-appmodule">
<em>HeroService</em>, <em>InMemoryDataService</em>, <em>AppModule</em>
</h4> <code-tabs> <pre header="hero.service.ts" data-language="typescript">import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';

import { Observable, of } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';

import { Hero } from './hero';
import { MessageService } from './message.service';

const httpOptions = {
  headers: new HttpHeaders({ 'Content-Type': 'application/json' })
};

@Injectable({ providedIn: 'root' })
export class HeroService {

  private heroesUrl = 'api/heroes';  // URL to web api

  constructor(
    private http: HttpClient,
    private messageService: MessageService) { }

  /** GET heroes from the server */
  getHeroes (): Observable&lt;Hero[]&gt; {
    return this.http.get&lt;Hero[]&gt;(this.heroesUrl)
      .pipe(
        tap(_ =&gt; this.log('fetched heroes')),
        catchError(this.handleError&lt;Hero[]&gt;('getHeroes', []))
      );
  }

  /** GET hero by id. Return `undefined` when id not found */
  getHeroNo404&lt;Data&gt;(id: number): Observable&lt;Hero&gt; {
    const url = `${this.heroesUrl}/?id=${id}`;
    return this.http.get&lt;Hero[]&gt;(url)
      .pipe(
        map(heroes =&gt; heroes[0]), // returns a {0|1} element array
        tap(h =&gt; {
          const outcome = h ? `fetched` : `did not find`;
          this.log(`${outcome} hero id=${id}`);
        }),
        catchError(this.handleError&lt;Hero&gt;(`getHero id=${id}`))
      );
  }

  /** GET hero by id. Will 404 if id not found */
  getHero(id: number): Observable&lt;Hero&gt; {
    const url = `${this.heroesUrl}/${id}`;
    return this.http.get&lt;Hero&gt;(url).pipe(
      tap(_ =&gt; this.log(`fetched hero id=${id}`)),
      catchError(this.handleError&lt;Hero&gt;(`getHero id=${id}`))
    );
  }

  /* GET heroes whose name contains search term */
  searchHeroes(term: string): Observable&lt;Hero[]&gt; {
    if (!term.trim()) {
      // if not search term, return empty hero array.
      return of([]);
    }
    return this.http.get&lt;Hero[]&gt;(`${this.heroesUrl}/?name=${term}`).pipe(
      tap(_ =&gt; this.log(`found heroes matching "${term}"`)),
      catchError(this.handleError&lt;Hero[]&gt;('searchHeroes', []))
    );
  }

  //////// Save methods //////////

  /** POST: add a new hero to the server */
  addHero (hero: Hero): Observable&lt;Hero&gt; {
    return this.http.post&lt;Hero&gt;(this.heroesUrl, hero, httpOptions).pipe(
      tap((newHero: Hero) =&gt; this.log(`added hero w/ id=${newHero.id}`)),
      catchError(this.handleError&lt;Hero&gt;('addHero'))
    );
  }

  /** DELETE: delete the hero from the server */
  deleteHero (hero: Hero | number): Observable&lt;Hero&gt; {
    const id = typeof hero === 'number' ? hero : hero.id;
    const url = `${this.heroesUrl}/${id}`;

    return this.http.delete&lt;Hero&gt;(url, httpOptions).pipe(
      tap(_ =&gt; this.log(`deleted hero id=${id}`)),
      catchError(this.handleError&lt;Hero&gt;('deleteHero'))
    );
  }

  /** PUT: update the hero on the server */
  updateHero (hero: Hero): Observable&lt;any&gt; {
    return this.http.put(this.heroesUrl, hero, httpOptions).pipe(
      tap(_ =&gt; this.log(`updated hero id=${hero.id}`)),
      catchError(this.handleError&lt;any&gt;('updateHero'))
    );
  }

  /**
   * Handle Http operation that failed.
   * Let the app continue.
   * @param operation - name of the operation that failed
   * @param result - optional value to return as the observable result
   */
  private handleError&lt;T&gt; (operation = 'operation', result?: T) {
    return (error: any): Observable&lt;T&gt; =&gt; {

      // TODO: send the error to remote logging infrastructure
      console.error(error); // log to console instead

      // TODO: better job of transforming error for user consumption
      this.log(`${operation} failed: ${error.message}`);

      // Let the app keep running by returning an empty result.
      return of(result as T);
    };
  }

  /** Log a HeroService message with the MessageService */
  private log(message: string) {
    this.messageService.add(`HeroService: ${message}`);
  }
}</pre> <pre header="in-memory-data.service.ts" data-language="typescript">import { InMemoryDbService } from 'angular-in-memory-web-api';
import { Hero } from './hero';
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class InMemoryDataService implements InMemoryDbService {
  createDb() {
    const heroes = [
      { id: 11, name: 'Mr. Nice' },
      { id: 12, name: 'Narco' },
      { id: 13, name: 'Bombasto' },
      { id: 14, name: 'Celeritas' },
      { id: 15, name: 'Magneta' },
      { id: 16, name: 'RubberMan' },
      { id: 17, name: 'Dynama' },
      { id: 18, name: 'Dr IQ' },
      { id: 19, name: 'Magma' },
      { id: 20, name: 'Tornado' }
    ];
    return {heroes};
  }

  // Overrides the genId method to ensure that a hero always has an id.
  // If the heroes array is empty,
  // the method below returns the initial number (11).
  // if the heroes array is not empty, the method below returns the highest
  // hero id + 1.
  genId(heroes: Hero[]): number {
    return heroes.length &gt; 0 ? Math.max(...heroes.map(hero =&gt; hero.id)) + 1 : 11;
  }
}</pre> <pre header="app.module.ts" data-language="typescript">import { NgModule }       from '@angular/core';
import { BrowserModule }  from '@angular/platform-browser';
import { FormsModule }    from '@angular/forms';
import { HttpClientModule }    from '@angular/common/http';

import { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';
import { InMemoryDataService }  from './in-memory-data.service';

import { AppRoutingModule }     from './app-routing.module';

import { AppComponent }         from './app.component';
import { DashboardComponent }   from './dashboard/dashboard.component';
import { HeroDetailComponent }  from './hero-detail/hero-detail.component';
import { HeroesComponent }      from './heroes/heroes.component';
import { HeroSearchComponent }  from './hero-search/hero-search.component';
import { MessagesComponent }    from './messages/messages.component';

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    AppRoutingModule,
    HttpClientModule,

    // The HttpClientInMemoryWebApiModule module intercepts HTTP requests
    // and returns simulated server responses.
    // Remove it when a real server is ready to receive requests.
    HttpClientInMemoryWebApiModule.forRoot(
      InMemoryDataService, { dataEncapsulation: false }
    )
  ],
  declarations: [
    AppComponent,
    DashboardComponent,
    HeroesComponent,
    HeroDetailComponent,
    MessagesComponent,
    HeroSearchComponent
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }</pre> </code-tabs>  <h4 id="heroescomponent"><em>HeroesComponent</em></h4> <code-tabs> <pre header="heroes/heroes.component.html" data-language="html">&lt;h2&gt;My Heroes&lt;/h2&gt;

&lt;div&gt;
  &lt;label&gt;Hero name:
    &lt;input #heroName /&gt;
  &lt;/label&gt;
  &lt;!-- (click) passes input value to add() and then clears the input --&gt;
  &lt;button (click)="add(heroName.value); heroName.value=''"&gt;
    add
  &lt;/button&gt;
&lt;/div&gt;

&lt;ul class="heroes"&gt;
  &lt;li *ngFor="let hero of heroes"&gt;
    &lt;a routerLink="/detail/{{hero.id}}"&gt;
      &lt;span class="badge"&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
    &lt;/a&gt;
    &lt;button class="delete" title="delete hero"
      (click)="delete(hero)"&gt;x&lt;/button&gt;
  &lt;/li&gt;
&lt;/ul&gt;</pre> <pre header="heroes/heroes.component.ts" data-language="typescript">import { Component, OnInit } from '@angular/core';

import { Hero } from '../hero';
import { HeroService } from '../hero.service';

@Component({
  selector: 'app-heroes',
  templateUrl: './heroes.component.html',
  styleUrls: ['./heroes.component.css']
})
export class HeroesComponent implements OnInit {
  heroes: Hero[];

  constructor(private heroService: HeroService) { }

  ngOnInit() {
    this.getHeroes();
  }

  getHeroes(): void {
    this.heroService.getHeroes()
    .subscribe(heroes =&gt; this.heroes = heroes);
  }

  add(name: string): void {
    name = name.trim();
    if (!name) { return; }
    this.heroService.addHero({ name } as Hero)
      .subscribe(hero =&gt; {
        this.heroes.push(hero);
      });
  }

  delete(hero: Hero): void {
    this.heroes = this.heroes.filter(h =&gt; h !== hero);
    this.heroService.deleteHero(hero).subscribe();
  }

}</pre> <pre header="heroes/heroes.component.css" data-language="css">/* HeroesComponent's private CSS styles */
.heroes {
  margin: 0 0 2em 0;
  list-style-type: none;
  padding: 0;
  width: 15em;
}
.heroes li {
  position: relative;
  cursor: pointer;
  background-color: #EEE;
  margin: .5em;
  padding: .3em 0;
  height: 1.6em;
  border-radius: 4px;
}

.heroes li:hover {
  color: #607D8B;
  background-color: #DDD;
  left: .1em;
}

.heroes a {
  color: #888;
  text-decoration: none;
  position: relative;
  display: block;
  width: 250px;
}

.heroes a:hover {
  color:#607D8B;
}

.heroes .badge {
  display: inline-block;
  font-size: small;
  color: white;
  padding: 0.8em 0.7em 0 0.7em;
  background-color: #607D8B;
  line-height: 1em;
  position: relative;
  left: -1px;
  top: -4px;
  height: 1.8em;
  min-width: 16px;
  text-align: right;
  margin-right: .8em;
  border-radius: 4px 0 0 4px;
}

button {
  background-color: #eee;
  border: none;
  padding: 5px 10px;
  border-radius: 4px;
  cursor: pointer;
  cursor: hand;
  font-family: Arial;
}

button:hover {
  background-color: #cfd8dc;
}

button.delete {
  position: relative;
  left: 194px;
  top: -32px;
  background-color: gray !important;
  color: white;
}</pre> </code-tabs>  <h4 id="herodetailcomponent"><em>HeroDetailComponent</em></h4> <code-tabs> <pre header="hero-detail/hero-detail.component.html" data-language="html">&lt;div *ngIf="hero"&gt;
  &lt;h2&gt;{{hero.name | uppercase}} Details&lt;/h2&gt;
  &lt;div&gt;&lt;span&gt;id: &lt;/span&gt;{{hero.id}}&lt;/div&gt;
  &lt;div&gt;
    &lt;label&gt;name:
      &lt;input [(ngModel)]="hero.name" placeholder="name"/&gt;
    &lt;/label&gt;
  &lt;/div&gt;
  &lt;button (click)="goBack()"&gt;go back&lt;/button&gt;
  &lt;button (click)="save()"&gt;save&lt;/button&gt;
&lt;/div&gt;</pre> <pre header="hero-detail/hero-detail.component.ts" data-language="typescript">import { Component, OnInit, Input } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Location } from '@angular/common';

import { Hero }         from '../hero';
import { HeroService }  from '../hero.service';

@Component({
  selector: 'app-hero-detail',
  templateUrl: './hero-detail.component.html',
  styleUrls: [ './hero-detail.component.css' ]
})
export class HeroDetailComponent implements OnInit {
  @Input() hero: Hero;

  constructor(
    private route: ActivatedRoute,
    private heroService: HeroService,
    private location: Location
  ) {}

  ngOnInit(): void {
    this.getHero();
  }

  getHero(): void {
    const id = +this.route.snapshot.paramMap.get('id');
    this.heroService.getHero(id)
      .subscribe(hero =&gt; this.hero = hero);
  }

  goBack(): void {
    this.location.back();
  }

 save(): void {
    this.heroService.updateHero(this.hero)
      .subscribe(() =&gt; this.goBack());
  }
}</pre> </code-tabs>  <h4 id="dashboardcomponent"><em>DashboardComponent</em></h4> <code-tabs> <pre header="src/app/dashboard/dashboard.component.html" data-language="html">&lt;h3&gt;Top Heroes&lt;/h3&gt;
&lt;div class="grid grid-pad"&gt;
  &lt;a *ngFor="let hero of heroes" class="col-1-4"
      routerLink="/detail/{{hero.id}}"&gt;
    &lt;div class="module hero"&gt;
      &lt;h4&gt;{{hero.name}}&lt;/h4&gt;
    &lt;/div&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;app-hero-search&gt;&lt;/app-hero-search&gt;</pre> </code-tabs>  <h4 id="herosearchcomponent"><em>HeroSearchComponent</em></h4> <code-tabs> <pre header="hero-search/hero-search.component.html" data-language="html">&lt;div id="search-component"&gt;
  &lt;h4&gt;Hero Search&lt;/h4&gt;

  &lt;input #searchBox id="search-box" (input)="search(searchBox.value)" /&gt;

  &lt;ul class="search-result"&gt;
    &lt;li *ngFor="let hero of heroes$ | async" &gt;
      &lt;a routerLink="/detail/{{hero.id}}"&gt;
        {{hero.name}}
      &lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</pre> <pre header="hero-search/hero-search.component.ts" data-language="typescript">import { Component, OnInit } from '@angular/core';

import { Observable, Subject } from 'rxjs';

import {
   debounceTime, distinctUntilChanged, switchMap
 } from 'rxjs/operators';

import { Hero } from '../hero';
import { HeroService } from '../hero.service';

@Component({
  selector: 'app-hero-search',
  templateUrl: './hero-search.component.html',
  styleUrls: [ './hero-search.component.css' ]
})
export class HeroSearchComponent implements OnInit {
  heroes$: Observable&lt;Hero[]&gt;;
  private searchTerms = new Subject&lt;string&gt;();

  constructor(private heroService: HeroService) {}

  // Push a search term into the observable stream.
  search(term: string): void {
    this.searchTerms.next(term);
  }

  ngOnInit(): void {
    this.heroes$ = this.searchTerms.pipe(
      // wait 300ms after each keystroke before considering the term
      debounceTime(300),

      // ignore new term if same as previous term
      distinctUntilChanged(),

      // switch to new search observable each time the term changes
      switchMap((term: string) =&gt; this.heroService.searchHeroes(term)),
    );
  }
}</pre> <pre header="hero-search/hero-search.component.css" data-language="css">/* HeroSearch private styles */
.search-result li {
  border-bottom: 1px solid gray;
  border-left: 1px solid gray;
  border-right: 1px solid gray;
  width: 195px;
  height: 16px;
  padding: 5px;
  background-color: white;
  cursor: pointer;
  list-style-type: none;
}

.search-result li:hover {
  background-color: #607D8B;
}

.search-result li a {
  color: #888;
  display: block;
  text-decoration: none;
}

.search-result li a:hover {
  color: white;
}
.search-result li a:active {
  color: white;
}
#search-box {
  width: 200px;
  height: 20px;
}


ul.search-result {
  margin-top: 0;
  padding-left: 0;
}</pre> </code-tabs> <h2 id="summary">Summary</h2> <p>You're at the end of your journey, and you've accomplished a lot.</p> <ul> <li>You added the necessary dependencies to use HTTP in the app.</li> <li>You refactored <code>HeroService</code> to load heroes from a web API.</li> <li>You extended <code>HeroService</code> to support <code>post()</code>, <code>put()</code>, and <code>delete()</code> methods.</li> <li>You updated the components to allow adding, editing, and deleting of heroes.</li> <li>You configured an in-memory web API.</li> <li>You learned how to use observables.</li> </ul> <p>This concludes the "Tour of Heroes" tutorial. You're ready to learn more about Angular development in the fundamentals section, starting with the <a href="../../guide/architecture/" title="Architecture">Architecture</a> guide.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2019 Google, Inc.<br>Licensed under the Creative Commons Attribution License 4.0.<br>
    <a href="https://v7.angular.io/tutorial/toh-pt6" class="_attribution-link" target="_blank">https://v7.angular.io/tutorial/toh-pt6</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
