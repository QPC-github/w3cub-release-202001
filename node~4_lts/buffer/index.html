
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Buffer - Node.js 4 LTS - W3cubDocs</title>
  
  <meta name="description" content="Prior to the introduction of TypedArray in ECMAScript 2015 (ES6), the JavaScript language had no mechanism for reading or manipulating streams of &hellip;">
  <meta name="keywords" content="buffer, -, node, js, lts, node~4_lts">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/node~4_lts/buffer/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/node~4_lts.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/node~4_lts/" class="_nav-link" title="" style="margin-left:0;">Node.js 4 LTS</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _node">
				
				
<h1 id="buffer_buffer">Buffer</h1> <div class="api_stability api_stability_2">Stability: 2 - Stable</div>
<p>Prior to the introduction of <code>TypedArray</code> in ECMAScript 2015 (ES6), the JavaScript language had no mechanism for reading or manipulating streams of binary data. The <code>Buffer</code> class was introduced as part of the Node.js API to make it possible to interact with octet streams in the context of things like TCP streams and file system operations.</p> <p>Now that <code>TypedArray</code> has been added in ES6, the <code>Buffer</code> class implements the <code>Uint8Array</code> API in a manner that is more optimized and suitable for Node.js' use cases.</p> <p>Instances of the <code>Buffer</code> class are similar to arrays of integers but correspond to fixed-sized, raw memory allocations outside the V8 heap. The size of the <code>Buffer</code> is established when it is created and cannot be resized.</p> <p>The <code>Buffer</code> class is a global within Node.js, making it unlikely that one would need to ever use <code>require('buffer').Buffer</code>.</p> <pre data-language="js">const buf1 = new Buffer(10);
  // creates a buffer of length 10
  // This is the same as Buffer.allocUnsafe(10), and the returned
  // Buffer instance might contain old data that needs to be
  // overwritten using either fill() or write().

const buf2 = new Buffer([1,2,3]);
  // creates a buffer containing [01, 02, 03]
  // This is the same as Buffer.from([1,2,3]).

const buf3 = new Buffer('test');
  // creates a buffer containing ASCII bytes [74, 65, 73, 74]
  // This is the same as Buffer.from('test').

const buf4 = new Buffer('tést', 'utf8');
  // creates a buffer containing UTF8 bytes [74, c3, a9, 73, 74]
  // This is the same as Buffer.from('tést', 'utf8').

const buf5 = Buffer.alloc(10);
  // Creates a zero-filled Buffer of length 10.

const buf6 = Buffer.alloc(10, 1);
  // Creates a Buffer of length 10, filled with 0x01.

const buf7 = Buffer.allocUnsafe(10);
  // Creates an uninitialized buffer of length 10.
  // This is faster than calling Buffer.alloc() but the returned
  // Buffer instance might contain old data that needs to be
  // overwritten using either fill() or write().

const buf8 = Buffer.from([1,2,3]);
  // Creates a Buffer containing [01, 02, 03].

const buf9 = Buffer.from('test');
  // Creates a Buffer containing ASCII bytes [74, 65, 73, 74].

const buf8 = Buffer.from('tést', 'utf8');
  // Creates a Buffer containing UTF8 bytes [74, c3, a9, 73, 74].
</pre> <h2 id="buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe">
<code>Buffer.from()</code>, <code>Buffer.alloc()</code>, and <code>Buffer.allocUnsafe()</code>
</h2> <p>Historically, <code>Buffer</code> instances have been created using the <code>Buffer</code> constructor function, which allocates the returned <code>Buffer</code> differently based on what arguments are provided:</p> <ul> <li>Passing a number as the first argument to <code>Buffer()</code> (e.g. <code>new Buffer(10)</code>), allocates a new <code>Buffer</code> object of the specified size. The memory allocated for such <code>Buffer</code> instances is <em>not</em> initialized and <em>can contain sensitive data</em>. Such <code>Buffer</code> objects <em>must</em> be initialized <em>manually</em> by using either <a href="#buffer_buf_fill_value_offset_end"><code>buf.fill(0)</code></a> or by writing to the <code>Buffer</code> completely. While this behavior is <em>intentional</em> to improve performance, development experience has demonstrated that a more explicit distinction is required between creating a fast-but-uninitialized <code>Buffer</code> versus creating a slower-but-safer <code>Buffer</code>.</li> <li>Passing a string, array, or <code>Buffer</code> as the first argument copies the passed object's data into the <code>Buffer</code>.</li> <li>Passing an <code>ArrayBuffer</code> returns a <code>Buffer</code> that shares allocated memory with the given <code>ArrayBuffer</code>.</li> </ul> <p>Because the behavior of <code>new Buffer()</code> changes significantly based on the type of value passed as the first argument, applications that do not properly validate the input arguments passed to <code>new Buffer()</code>, or that fail to appropriately initialize newly allocated <code>Buffer</code> content, can inadvertently introduce security and reliability issues into their code.</p> <p>To make the creation of <code>Buffer</code> objects more reliable and less error prone, new <code>Buffer.from()</code>, <code>Buffer.alloc()</code>, and <code>Buffer.allocUnsafe()</code> methods have been introduced as an alternative means of creating <code>Buffer</code> instances.</p> <p><em>Developers should migrate all existing uses of the <code>new Buffer()</code> constructors to one of these new APIs.</em></p> <ul> <li>
<a href="#buffer_class_method_buffer_from_array"><code>Buffer.from(array)</code></a> returns a new <code>Buffer</code> containing a <em>copy</em> of the provided octets.</li> <li>
<a href="#buffer_class_method_buffer_from_arraybuffer"><code>Buffer.from(arrayBuffer)</code></a> returns a new <code>Buffer</code> that <em>shares</em> the same allocated memory as the given <code>ArrayBuffer</code>.</li> <li>
<a href="#buffer_class_method_buffer_from_buffer"><code>Buffer.from(buffer)</code></a> returns a new <code>Buffer</code> containing a <em>copy</em> of the contents of the given <code>Buffer</code>.</li> <li>
<a href="#buffer_class_method_buffer_from_str_encoding"><code>Buffer.from(str[, encoding])</code></a> returns a new <code>Buffer</code> containing a <em>copy</em> of the provided string.</li> <li>
<a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc(size[, fill[, encoding]])</code></a> returns a "filled" <code>Buffer</code> instance of the specified size. This method can be significantly slower than <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe(size)</code></a> but ensures that newly created <code>Buffer</code> instances never contain old and potentially sensitive data.</li> <li>
<a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe(size)</code></a> and <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow(size)</code></a> each return a new <code>Buffer</code> of the specified <code>size</code> whose content <em>must</em> be initialized using either <a href="#buffer_buf_fill_value_offset_end"><code>buf.fill(0)</code></a> or written to completely.</li> </ul> <p><code>Buffer</code> instances returned by <code>Buffer.allocUnsafe(size)</code> <em>may</em> be allocated off a shared internal memory pool if <code>size</code> is less than or equal to half <code>Buffer.poolSize</code>. Instances returned by <code>Buffer.allocUnsafeSlow(size)</code> <em>never</em> use the shared internal memory pool.</p> <h3 id="buffer_what_makes_buffer_allocunsafe_size_and_buffer_allocunsafeslow_size_unsafe">What makes <code>Buffer.allocUnsafe(size)</code> and <code>Buffer.allocUnsafeSlow(size)</code> "unsafe"?</h3> <p>When calling <code>Buffer.allocUnsafe()</code> (and <code>Buffer.allocUnsafeSlow()</code>), the segment of allocated memory is <em>uninitialized</em> (it is not zeroed-out). While this design makes the allocation of memory quite fast, the allocated segment of memory might contain old data that is potentially sensitive. Using a <code>Buffer</code> created by <code>Buffer.allocUnsafe()</code> without <em>completely</em> overwriting the memory can allow this old data to be leaked when the <code>Buffer</code> memory is read.</p> <p>While there are clear performance advantages to using <code>Buffer.allocUnsafe()</code>, extra care <em>must</em> be taken in order to avoid introducing security vulnerabilities into an application.</p> <h2 id="buffer_buffers_and_character_encodings">Buffers and Character Encodings</h2> <p>Buffers are commonly used to represent sequences of encoded characters such as UTF8, UCS2, Base64 or even Hex-encoded data. It is possible to convert back and forth between Buffers and ordinary JavaScript string objects by using an explicit encoding method.</p> <pre data-language="js">const buf = new Buffer('hello world', 'ascii');
console.log(buf.toString('hex'));
  // prints: 68656c6c6f20776f726c64
console.log(buf.toString('base64'));
  // prints: aGVsbG8gd29ybGQ=
</pre> <p>The character encodings currently supported by Node.js include:</p> <ul> <li>
<p><code>'ascii'</code> - for 7-bit ASCII data only. This encoding method is very fast and will strip the high bit if set.</p> </li> <li>
<p><code>'utf8'</code> - Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.</p> </li> <li>
<p><code>'utf16le'</code> - 2 or 4 bytes, little-endian encoded Unicode characters. Surrogate pairs (U+10000 to U+10FFFF) are supported.</p> </li> <li>
<p><code>'ucs2'</code> - Alias of <code>'utf16le'</code>.</p> </li> <li>
<p><code>'base64'</code> - Base64 string encoding. When creating a buffer from a string, this encoding will also correctly accept "URL and Filename Safe Alphabet" as specified in <a href="https://tools.ietf.org/html/rfc4648#section-5" target="_blank">RFC 4648, Section 5</a>.</p> </li> <li>
<p><code>'binary'</code> - A way of encoding the buffer into a one-byte (<code>latin-1</code>) encoded string. The string <code>'latin-1'</code> is not supported. Instead, pass <code>'binary'</code> to use <code>'latin-1'</code> encoding.</p> </li> <li>
<p><code>'hex'</code> - Encode each byte as two hexadecimal characters.</p> </li> </ul> <h2 id="buffer_buffers_and_typedarray">Buffers and TypedArray</h2> <p>Buffers are also <code>Uint8Array</code> TypedArray instances. However, there are subtle incompatibilities with the TypedArray specification in ECMAScript 2015. For instance, while <code>ArrayBuffer#slice()</code> creates a copy of the slice, the implementation of <a href="#buffer_buf_slice_start_end"><code>Buffer#slice()</code></a> creates a view over the existing Buffer without copying, making <code>Buffer#slice()</code> far more efficient.</p> <p>It is also possible to create new TypedArray instances from a <code>Buffer</code> with the following caveats:</p> <ol> <li>
<p>The Buffer instances's memory is copied to the TypedArray, not shared.</p> </li> <li>
<p>The Buffer's memory is interpreted as an array of distinct elements, and not as a byte array of the target type. That is, <code>new Uint32Array(new Buffer([1,2,3,4]))</code> creates a 4-element <code>Uint32Array</code> with elements <code>[1,2,3,4]</code>, not a <code>Uint32Array</code> with a single element <code>[0x1020304]</code> or <code>[0x4030201]</code>.</p> </li> </ol> <p>It is possible to create a new Buffer that shares the same allocated memory as a TypedArray instance by using the TypeArray objects <code>.buffer</code> property:</p> <pre data-language="js">const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf1 = new Buffer(arr); // copies the buffer
const buf2 = new Buffer(arr.buffer); // shares the memory with arr;

console.log(buf1);
  // Prints: &lt;Buffer 88 a0&gt;, copied buffer has only two elements
console.log(buf2);
  // Prints: &lt;Buffer 88 13 a0 0f&gt;

arr[1] = 6000;
console.log(buf1);
  // Prints: &lt;Buffer 88 a0&gt;
console.log(buf2);
  // Prints: &lt;Buffer 88 13 70 17&gt;
</pre> <p>Note that when creating a Buffer using the TypeArray's <code>.buffer</code>, it is not currently possible to use only a portion of the underlying <code>ArrayBuffer</code>. To create a Buffer that uses only a part of the <code>ArrayBuffer</code>, use the <a href="#buffer_buf_slice_start_end"><code>buf.slice()</code></a> function after the Buffer is created:</p> <pre data-language="js">const arr = new Uint16Array(20);
const buf = new Buffer(arr.buffer).slice(0, 16);
console.log(buf.length);
  // Prints: 16
</pre> <p>The <code>Buffer.from()</code> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from" target="_blank"><code>TypedArray.from()</code></a> (e.g.<code>Uint8Array.from()</code>) have different signatures and implementations. Specifically, the TypedArray variants accept a second argument that is a mapping function that is invoked on every element of the typed array:</p> <ul> <li><code>TypedArray.from(source[, mapFn[, thisArg]])</code></li> </ul> <p>The <code>Buffer.from()</code> method, however, does not support the use of a mapping function:</p> <ul> <li><a href="#buffer_class_method_buffer_from_array"><code>Buffer.from(array)</code></a></li> <li><a href="#buffer_class_method_buffer_from_buffer"><code>Buffer.from(buffer)</code></a></li> <li><a href="#buffer_class_method_buffer_from_arraybuffer"><code>Buffer.from(arrayBuffer)</code></a></li> <li><a href="#buffer_class_method_buffer_from_str_encoding"><code>Buffer.from(str[, encoding])</code></a></li> </ul> <h2 id="buffer_buffers_and_es6_iteration">Buffers and ES6 iteration</h2> <p>Buffers can be iterated over using the ECMAScript 2015 (ES6) <code>for..of</code> syntax:</p> <pre data-language="js">const buf = new Buffer([1, 2, 3]);

for (var b of buf)
  console.log(b)

// Prints:
//   1
//   2
//   3
</pre> <p>Additionally, the <a href="#buffer_buf_values"><code>buf.values()</code></a>, <a href="#buffer_buf_keys"><code>buf.keys()</code></a>, and <a href="#buffer_buf_entries"><code>buf.entries()</code></a> methods can be used to create iterators.</p> <h2 id="buffer_the_zero_fill_buffers_command_line_option">The <code>--zero-fill-buffers</code> command line option</h2> <p>Node.js can be started using the <code>--zero-fill-buffers</code> command line option to force all newly allocated <code>Buffer</code> and <code>SlowBuffer</code> instances created using either <code>new Buffer(size)</code> and <code>new SlowBuffer(size)</code> to be <em>automatically zero-filled</em> upon creation. Use of this flag <em>changes the default behavior</em> of these methods and <em>can have a significant impact</em> on performance. Use of the <code>--zero-fill-buffers</code> option is recommended only when absolutely necessary to enforce that newly allocated <code>Buffer</code> instances cannot contain potentially sensitive data.</p> <pre>$ node --zero-fill-buffers
&gt; Buffer(5);
&lt;Buffer 00 00 00 00 00&gt;
</pre>
<h2 id="buffer_class_buffer">Class: Buffer</h2> <p>The Buffer class is a global type for dealing with binary data directly. It can be constructed in a variety of ways.</p> <h3 id="buffer_new_buffer_array">new Buffer(array)</h3> <div class="signature">
<ul> <li>
<code>array</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" class="type" target="_blank">&lt;Array&gt;</a>
</li> </ul> </div>
<p>Allocates a new Buffer using an <code>array</code> of octets.</p> <pre data-language="js">const buf = new Buffer([0x62,0x75,0x66,0x66,0x65,0x72]);
  // creates a new Buffer containing ASCII bytes
  // ['b','u','f','f','e','r']
</pre> <h3 id="buffer_new_buffer_buffer">new Buffer(buffer)</h3> <div class="signature">
<ul> <li>
<code>buffer</code> <a href="../buffer/#buffer_class_buffer" class="type">&lt;Buffer&gt;</a>
</li> </ul> </div>
<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p> <pre data-language="js">const buf1 = new Buffer('buffer');
const buf2 = new Buffer(buf1);

buf1[0] = 0x61;
console.log(buf1.toString());
  // 'auffer'
console.log(buf2.toString());
  // 'buffer' (copy is not changed)
</pre> <h3 id="buffer_new_buffer_arraybuffer">new Buffer(arrayBuffer)</h3> <div class="signature">
<ul> <li>
<code>arrayBuffer</code> - The <code>.buffer</code> property of a <code>TypedArray</code> or a <code>new
ArrayBuffer()</code>
</li> </ul> </div>
<p>When passed a reference to the <code>.buffer</code> property of a <code>TypedArray</code> instance, the newly created Buffer will share the same allocated memory as the TypedArray.</p> <pre data-language="js">const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf = new Buffer(arr.buffer); // shares the memory with arr;

console.log(buf);
  // Prints: &lt;Buffer 88 13 a0 0f&gt;

// changing the TypdArray changes the Buffer also
arr[1] = 6000;

console.log(buf);
  // Prints: &lt;Buffer 88 13 70 17&gt;
</pre> <h3 id="buffer_new_buffer_size">new Buffer(size)</h3> <div class="signature">
<ul> <li>
<code>size</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> </ul> </div>
<p>Allocates a new Buffer of <code>size</code> bytes. The <code>size</code> must be less than or equal to the value of <code>require('buffer').kMaxLength</code> (on 64-bit architectures, <code>kMaxLength</code> is <code>(2^31)-1</code>). Otherwise, a <a href="../errors/#errors_class_rangeerror"><code>RangeError</code></a> is thrown. If a <code>size</code> less than 0 is specified, a zero-length Buffer will be created.</p> <p>Unlike <code>ArrayBuffers</code>, the underlying memory for Buffer instances created in this way is not initialized. The contents of a newly created <code>Buffer</code> are unknown and could contain sensitive data. Use <a href="#buffer_buf_fill_value_offset_end"><code>buf.fill(0)</code></a> to initialize a Buffer to zeroes.</p> <pre data-language="js">const buf = new Buffer(5);
console.log(buf);
  // &lt;Buffer 78 e0 82 02 01&gt;
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // &lt;Buffer 00 00 00 00 00&gt;
</pre> <h3 id="buffer_new_buffer_str_encoding">new Buffer(str[, encoding])</h3> <div class="signature">
<ul> <li>
<code>str</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type" target="_blank">&lt;String&gt;</a> String to encode.</li> <li>
<code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type" target="_blank">&lt;String&gt;</a> Default: <code>'utf8'</code>
</li> </ul> </div>
<p>Creates a new Buffer containing the given JavaScript string <code>str</code>. If provided, the <code>encoding</code> parameter identifies the strings character encoding.</p> <pre data-language="js">const buf1 = new Buffer('this is a tést');
console.log(buf1.toString());
  // prints: this is a tést
console.log(buf1.toString('ascii'));
  // prints: this is a tC)st

const buf2 = new Buffer('7468697320697320612074c3a97374', 'hex');
console.log(buf2.toString());
  // prints: this is a tést
</pre> <h3 id="buffer_class_method_buffer_alloc_size_fill_encoding">Class Method: Buffer.alloc(size[, fill[, encoding]])</h3> <div class="api_metadata"> <span>Added in: v4.5.0</span> </div>
<ul> <li>
<code>size</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> <li>
<code>fill</code> <span class="type">&lt;Value&gt;</span> Default: <code>undefined</code>
</li> <li>
<code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type" target="_blank">&lt;String&gt;</a> Default: <code>utf8</code>
</li> </ul> <p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>fill</code> is <code>undefined</code>, the <code>Buffer</code> will be <em>zero-filled</em>.</p> <pre data-language="js">const buf = Buffer.alloc(5);
console.log(buf);
  // &lt;Buffer 00 00 00 00 00&gt;
</pre> <p>The <code>size</code> must be less than or equal to the value of <code>require('buffer').kMaxLength</code> (on 64-bit architectures, <code>kMaxLength</code> is <code>(2^31)-1</code>). Otherwise, a <a href="../errors/#errors_class_rangeerror"><code>RangeError</code></a> is thrown. If a <code>size</code> less than 0 is specified, a zero-length <code>Buffer</code> will be created.</p> <p>If <code>fill</code> is specified, the allocated <code>Buffer</code> will be initialized by calling <code>buf.fill(fill)</code>. See [<code>buf.fill()</code>][] for more information.</p> <pre data-language="js">const buf = Buffer.alloc(5, 'a');
console.log(buf);
  // &lt;Buffer 61 61 61 61 61&gt;
</pre> <p>If both <code>fill</code> and <code>encoding</code> are specified, the allocated <code>Buffer</code> will be initialized by calling <code>buf.fill(fill, encoding)</code>. For example:</p> <pre data-language="js">const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
console.log(buf);
  // &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;
</pre> <p>Calling <code>Buffer.alloc(size)</code> can be significantly slower than the alternative <code>Buffer.allocUnsafe(size)</code> but ensures that the newly created <code>Buffer</code> instance contents will <em>never contain sensitive data</em>.</p> <p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p> <h3 id="buffer_class_method_buffer_allocunsafe_size">Class Method: Buffer.allocUnsafe(size)</h3> <div class="api_metadata"> <span>Added in: v4.5.0</span> </div>
<ul> <li>
<code>size</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> </ul> <p>Allocates a new <em>non-zero-filled</em> <code>Buffer</code> of <code>size</code> bytes. The <code>size</code> must be less than or equal to the value of <code>require('buffer').kMaxLength</code> (on 64-bit architectures, <code>kMaxLength</code> is <code>(2^31)-1</code>). Otherwise, a <a href="../errors/#errors_class_rangeerror"><code>RangeError</code></a> is thrown. If a <code>size</code> less than 0 is specified, a zero-length <code>Buffer</code> will be created.</p> <p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not initialized</em>. The contents of the newly created <code>Buffer</code> are unknown and <em>may contain sensitive data</em>. Use <a href="#buffer_buf_fill_value_offset_end"><code>buf.fill(0)</code></a> to initialize such <code>Buffer</code> instances to zeroes.</p> <pre data-language="js">const buf = Buffer.allocUnsafe(5);
console.log(buf);
  // &lt;Buffer 78 e0 82 02 01&gt;
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // &lt;Buffer 00 00 00 00 00&gt;
</pre> <p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p> <p>Note that the <code>Buffer</code> module pre-allocates an internal <code>Buffer</code> instance of size <code>Buffer.poolSize</code> that is used as a pool for the fast allocation of new <code>Buffer</code> instances created using <code>Buffer.allocUnsafe(size)</code> (and the <code>new Buffer(size)</code> constructor) only when <code>size</code> is less than or equal to <code>Buffer.poolSize &gt;&gt; 1</code> (floor of <code>Buffer.poolSize</code> divided by two). The default value of <code>Buffer.poolSize</code> is <code>8192</code> but can be modified.</p> <p>Use of this pre-allocated internal memory pool is a key difference between calling <code>Buffer.alloc(size, fill)</code> vs. <code>Buffer.allocUnsafe(size).fill(fill)</code>. Specifically, <code>Buffer.alloc(size, fill)</code> will <em>never</em> use the internal Buffer pool, while <code>Buffer.allocUnsafe(size).fill(fill)</code> <em>will</em> use the internal Buffer pool if <code>size</code> is less than or equal to half <code>Buffer.poolSize</code>. The difference is subtle but can be important when an application requires the additional performance that <code>Buffer.allocUnsafe(size)</code> provides.</p> <h3 id="buffer_class_method_buffer_allocunsafeslow_size">Class Method: Buffer.allocUnsafeSlow(size)</h3> <div class="api_metadata"> <span>Added in: v4.5.0</span> </div>
<ul> <li>
<code>size</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> </ul> <p>Allocates a new <em>non-zero-filled</em> and non-pooled <code>Buffer</code> of <code>size</code> bytes. The <code>size</code> must be less than or equal to the value of <code>require('buffer').kMaxLength</code> (on 64-bit architectures, <code>kMaxLength</code> is <code>(2^31)-1</code>). Otherwise, a <a href="../errors/#errors_class_rangeerror"><code>RangeError</code></a> is thrown. If a <code>size</code> less than 0 is specified, a zero-length <code>Buffer</code> will be created.</p> <p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not initialized</em>. The contents of the newly created <code>Buffer</code> are unknown and <em>may contain sensitive data</em>. Use <a href="#buffer_buf_fill_value_offset_end"><code>buf.fill(0)</code></a> to initialize such <code>Buffer</code> instances to zeroes.</p> <p>When using <code>Buffer.allocUnsafe()</code> to allocate new <code>Buffer</code> instances, allocations under 4KB are, by default, sliced from a single pre-allocated <code>Buffer</code>. This allows applications to avoid the garbage collection overhead of creating many individually allocated Buffers. This approach improves both performance and memory usage by eliminating the need to track and cleanup as many <code>Persistent</code> objects.</p> <p>However, in the case where a developer may need to retain a small chunk of memory from a pool for an indeterminate amount of time, it may be appropriate to create an un-pooled Buffer instance using <code>Buffer.allocUnsafeSlow()</code> then copy out the relevant bits.</p> <pre data-language="js">// need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () =&gt; {
  const data = socket.read();
  // allocate for retained data
  const sb = Buffer.allocUnsafeSlow(10);
  // copy the data into the new allocation
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});
</pre> <p>Use of <code>Buffer.allocUnsafeSlow()</code> should be used only as a last resort <em>after</em> a developer has observed undue memory retention in their applications.</p> <p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p> <h3 id="buffer_class_method_buffer_bytelength_string_encoding">Class Method: Buffer.byteLength(string[, encoding])</h3> <div class="signature">
<ul> <li>
<code>string</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type" target="_blank">&lt;String&gt;</a>
</li> <li>
<code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type" target="_blank">&lt;String&gt;</a> Default: <code>'utf8'</code>
</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> </ul> </div>
<p>Returns the actual byte length of a string. This is not the same as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length" target="_blank"><code>String.prototype.length</code></a> since that returns the number of <em>characters</em> in a string.</p> <p><em>Note</em> that for <code>'base64'</code> and <code>'hex'</code>, this function assumes valid input. For strings that contain non-Base64/Hex-encoded data (e.g. whitespace), the return value might be greater than the length of a <code>Buffer</code> created from the string.</p> <p>Example:</p> <pre data-language="js">const str = '\u00bd + \u00bc = \u00be';

console.log(`${str}: ${str.length} characters, ` +
            `${Buffer.byteLength(str, 'utf8')} bytes`);

// ½ + ¼ = ¾: 9 characters, 12 bytes
</pre> <h3 id="buffer_class_method_buffer_compare_buf1_buf2">Class Method: Buffer.compare(buf1, buf2)</h3> <div class="api_metadata"> <span>Added in: v0.11.13</span> </div>
<ul> <li>
<code>buf1</code> <a href="../buffer/#buffer_class_buffer" class="type">&lt;Buffer&gt;</a>
</li> <li>
<code>buf2</code> <a href="../buffer/#buffer_class_buffer" class="type">&lt;Buffer&gt;</a>
</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> </ul> <p>Compares <code>buf1</code> to <code>buf2</code> typically for the purpose of sorting arrays of Buffers. This is equivalent is calling <a href="#buffer_buf_compare_otherbuffer"><code>buf1.compare(buf2)</code></a>.</p> <pre data-language="js">const arr = [Buffer('1234'), Buffer('0123')];
arr.sort(Buffer.compare);
</pre> <h3 id="buffer_class_method_buffer_concat_list_totallength">Class Method: Buffer.concat(list[, totalLength])</h3> <div class="api_metadata"> <span>Added in: v0.7.11</span> </div>
<ul> <li>
<code>list</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" class="type" target="_blank">&lt;Array&gt;</a> List of Buffer objects to concat</li> <li>
<code>totalLength</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Total length of the Buffers in the list when concatenated</li> <li>Returns: <a href="../buffer/#buffer_class_buffer" class="type">&lt;Buffer&gt;</a>
</li> </ul> <p>Returns a new Buffer which is the result of concatenating all the Buffers in the <code>list</code> together.</p> <p>If the list has no items, or if the <code>totalLength</code> is 0, then a new zero-length Buffer is returned.</p> <p>If <code>totalLength</code> is not provided, it is calculated from the Buffers in the <code>list</code>. This, however, adds an additional loop to the function, so it is faster to provide the length explicitly.</p> <p>Example: build a single Buffer from a list of three Buffers:</p> <pre data-language="js">const buf1 = new Buffer(10).fill(0);
const buf2 = new Buffer(14).fill(0);
const buf3 = new Buffer(18).fill(0);
const totalLength = buf1.length + buf2.length + buf3.length;

console.log(totalLength);
const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);
console.log(bufA);
console.log(bufA.length);

// 42
// &lt;Buffer 00 00 00 00 ...&gt;
// 42
</pre> <h3 id="buffer_class_method_buffer_from_array">Class Method: Buffer.from(array)</h3> <div class="api_metadata"> <span>Added in: v4.5.0</span> </div>
<ul> <li>
<code>array</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" class="type" target="_blank">&lt;Array&gt;</a>
</li> </ul> <p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p> <pre data-language="js">const buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);
  // creates a new Buffer containing ASCII bytes
  // ['b','u','f','f','e','r']
</pre> <p>A <code>TypeError</code> will be thrown if <code>array</code> is not an <code>Array</code>.</p> <h3 id="buffer_class_method_buffer_from_arraybuffer">Class Method: Buffer.from(arrayBuffer)</h3> <div class="api_metadata"> <span>Added in: v4.5.0</span> </div>
<ul> <li>
<code>arrayBuffer</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" class="type" target="_blank">&lt;ArrayBuffer&gt;</a> The <code>.buffer</code> property of a <code>TypedArray</code> or a <code>new ArrayBuffer()</code>
</li> </ul> <p>When passed a reference to the <code>.buffer</code> property of a <code>TypedArray</code> instance, the newly created <code>Buffer</code> will share the same allocated memory as the TypedArray.</p> <pre data-language="js">const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf = Buffer.from(arr.buffer); // shares the memory with arr;

console.log(buf);
  // Prints: &lt;Buffer 88 13 a0 0f&gt;

// changing the TypedArray changes the Buffer also
arr[1] = 6000;

console.log(buf);
  // Prints: &lt;Buffer 88 13 70 17&gt;
</pre> <p>A <code>TypeError</code> will be thrown if <code>arrayBuffer</code> is not an <code>ArrayBuffer</code>.</p> <h3 id="buffer_class_method_buffer_from_buffer">Class Method: Buffer.from(buffer)</h3> <div class="api_metadata"> <span>Added in: v4.5.0</span> </div>
<ul> <li>
<code>buffer</code> <a href="../buffer/#buffer_class_buffer" class="type">&lt;Buffer&gt;</a>
</li> </ul> <p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p> <pre data-language="js">const buf1 = Buffer.from('buffer');
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;
console.log(buf1.toString());
  // 'auffer'
console.log(buf2.toString());
  // 'buffer' (copy is not changed)
</pre> <p>A <code>TypeError</code> will be thrown if <code>buffer</code> is not a <code>Buffer</code>.</p> <h3 id="buffer_class_method_buffer_from_str_encoding">Class Method: Buffer.from(str[, encoding])</h3> <div class="api_metadata"> <span>Added in: v4.5.0</span> </div>
<ul> <li>
<code>str</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type" target="_blank">&lt;String&gt;</a> String to encode.</li> <li>
<code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type" target="_blank">&lt;String&gt;</a> Encoding to use, Default: <code>'utf8'</code>
</li> </ul> <p>Creates a new <code>Buffer</code> containing the given JavaScript string <code>str</code>. If provided, the <code>encoding</code> parameter identifies the character encoding. If not provided, <code>encoding</code> defaults to <code>'utf8'</code>.</p> <pre data-language="js">const buf1 = Buffer.from('this is a tést');
console.log(buf1.toString());
  // prints: this is a tést
console.log(buf1.toString('ascii'));
  // prints: this is a tC)st

const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');
console.log(buf2.toString());
  // prints: this is a tést
</pre> <p>A <code>TypeError</code> will be thrown if <code>str</code> is not a string.</p> <h3 id="buffer_class_method_buffer_isbuffer_obj">Class Method: Buffer.isBuffer(obj)</h3> <div class="signature">
<ul> <li>
<code>obj</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type" target="_blank">&lt;Object&gt;</a>
</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a>
</li> </ul> </div>
<p>Returns 'true' if <code>obj</code> is a Buffer.</p> <h3 id="buffer_class_method_buffer_isencoding_encoding">Class Method: Buffer.isEncoding(encoding)</h3> <div class="api_metadata"> <span>Added in: v0.9.1</span> </div>
<ul> <li>
<code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type" target="_blank">&lt;String&gt;</a> The encoding string to test</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a>
</li> </ul> <p>Returns true if the <code>encoding</code> is a valid encoding argument, or false otherwise.</p> <h3 id="buffer_buf_index">buf[index]</h3> 
<p>The index operator <code>[index]</code> can be used to get and set the octet at position <code>index</code> in the Buffer. The values refer to individual bytes, so the legal value range is between <code>0x00</code> and <code>0xFF</code> (hex) or <code>0</code> and <code>255</code> (decimal).</p> <p>Example: copy an ASCII string into a Buffer, one byte at a time:</p> <pre data-language="js">const str = "Node.js";
const buf = new Buffer(str.length);

for (var i = 0; i &lt; str.length ; i++) {
  buf[i] = str.charCodeAt(i);
}

console.log(buf.toString('ascii'));
  // Prints: Node.js
</pre> <h3 id="buffer_buf_compare_otherbuffer">buf.compare(otherBuffer)</h3> <div class="api_metadata"> <span>Added in: v0.11.13</span> </div>
<ul> <li>
<code>otherBuffer</code> <a href="../buffer/#buffer_class_buffer" class="type">&lt;Buffer&gt;</a>
</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> </ul> <p>Compares two Buffer instances and returns a number indicating whether <code>buf</code> comes before, after, or is the same as the <code>otherBuffer</code> in sort order. Comparison is based on the actual sequence of bytes in each Buffer.</p> <ul> <li>
<code>0</code> is returned if <code>otherBuffer</code> is the same as <code>buf</code>
</li> <li>
<code>1</code> is returned if <code>otherBuffer</code> should come <em>before</em> <code>buf</code> when sorted.</li> <li>
<code>-1</code> is returned if <code>otherBuffer</code> should come <em>after</em> <code>buf</code> when sorted.</li> </ul> <pre data-language="js">const buf1 = new Buffer('ABC');
const buf2 = new Buffer('BCD');
const buf3 = new Buffer('ABCD');

console.log(buf1.compare(buf1));
  // Prints: 0
console.log(buf1.compare(buf2));
  // Prints: -1
console.log(buf1.compare(buf3));
  // Prints: -1
console.log(buf2.compare(buf1));
  // Prints: 1
console.log(buf2.compare(buf3));
  // Prints: 1

[buf1, buf2, buf3].sort(Buffer.compare);
  // produces sort order [buf1, buf3, buf2]
</pre> <h3 id="buffer_buf_copy_targetbuffer_targetstart_sourcestart_sourceend">buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</h3> <div class="signature">
<ul> <li>
<code>targetBuffer</code> <a href="../buffer/#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> Buffer to copy into</li> <li>
<code>targetStart</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Default: 0</li> <li>
<code>sourceStart</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Default: 0</li> <li>
<code>sourceEnd</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Default: <code>buffer.length</code>
</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> The number of bytes copied.</li> </ul> </div>
<p>Copies data from a region of this Buffer to a region in the target Buffer even if the target memory region overlaps with the source.</p> <p>Example: build two Buffers, then copy <code>buf1</code> from byte 16 through byte 19 into <code>buf2</code>, starting at the 8th byte in <code>buf2</code>.</p> <pre data-language="js">const buf1 = new Buffer(26);
const buf2 = new Buffer(26).fill('!');

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
}

buf1.copy(buf2, 8, 16, 20);
console.log(buf2.toString('ascii', 0, 25));
  // Prints: !!!!!!!!qrst!!!!!!!!!!!!!
</pre> <p>Example: Build a single Buffer, then copy data from one region to an overlapping region in the same Buffer</p> <pre data-language="js">const buf = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf[i] = i + 97; // 97 is ASCII a
}

buf.copy(buf, 0, 4, 10);
console.log(buf.toString());

// efghijghijklmnopqrstuvwxyz
</pre> <h3 id="buffer_buf_entries">buf.entries()</h3> <div class="api_metadata"> <span>Added in: v1.1.0</span> </div>
<ul> <li>Returns: <span class="type">&lt;Iterator&gt;</span>
</li> </ul> <p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank">iterator</a> of <code>[index, byte]</code> pairs from the Buffer contents.</p> <pre data-language="js">const buf = new Buffer('buffer');
for (var pair of buf.entries()) {
  console.log(pair);
}
// prints:
//   [0, 98]
//   [1, 117]
//   [2, 102]
//   [3, 102]
//   [4, 101]
//   [5, 114]
</pre> <h3 id="buffer_buf_equals_otherbuffer">buf.equals(otherBuffer)</h3> <div class="api_metadata"> <span>Added in: v1.0.0</span> </div>
<ul> <li>
<code>otherBuffer</code> <a href="../buffer/#buffer_class_buffer" class="type">&lt;Buffer&gt;</a>
</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a>
</li> </ul> <p>Returns a boolean indicating whether <code>this</code> and <code>otherBuffer</code> have exactly the same bytes.</p> <pre data-language="js">const buf1 = new Buffer('ABC');
const buf2 = new Buffer('414243', 'hex');
const buf3 = new Buffer('ABCD');

console.log(buf1.equals(buf2));
  // Prints: true
console.log(buf1.equals(buf3));
  // Prints: false
</pre> <h3 id="buffer_buf_fill_value_offset_end">buf.fill(value[, offset[, end]])</h3> <div class="api_metadata"> <span>Added in: v0.5.0</span> </div>
<ul> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type" target="_blank">&lt;String&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Default: 0</li> <li>
<code>end</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Default: <code>buffer.length</code>
</li> <li>Returns: <a href="../buffer/#buffer_class_buffer" class="type">&lt;Buffer&gt;</a>
</li> </ul> <p>Fills the Buffer with the specified value. If the <code>offset</code> and <code>end</code> are not given it will fill the entire Buffer. The method returns a reference to the Buffer so calls can be chained.</p> <pre data-language="js">const b = new Buffer(50).fill('h');
console.log(b.toString());
  // Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
</pre> <h3 id="buffer_buf_indexof_value_byteoffset_encoding">buf.indexOf(value[, byteOffset][, encoding])</h3> <div class="api_metadata"> <span>Added in: v1.5.0</span> </div>
<ul> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type" target="_blank">&lt;String&gt;</a> | <a href="../buffer/#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> <li>
<code>byteOffset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Default: 0</li> <li>
<code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type" target="_blank">&lt;String&gt;</a> Default: <code>'utf8'</code>
</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> </ul> <p>Operates similar to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" target="_blank"><code>Array#indexOf()</code></a> in that it returns either the starting index position of <code>value</code> in Buffer or <code>-1</code> if the Buffer does not contain <code>value</code>. The <code>value</code> can be a String, Buffer or Number. Strings are by default interpreted as UTF8. Buffers will use the entire Buffer (to compare a partial Buffer use <a href="#buffer_buf_slice_start_end"><code>buf.slice()</code></a>). Numbers will be interpreted as unsigned 8-bit integer values between <code>0</code> and <code>255</code>.</p> <pre data-language="js">const buf = new Buffer('this is a buffer');

buf.indexOf('this');
  // returns 0
buf.indexOf('is');
  // returns 2
buf.indexOf(new Buffer('a buffer'));
  // returns 8
buf.indexOf(97); // ascii for 'a'
  // returns 8
buf.indexOf(new Buffer('a buffer example'));
  // returns -1
buf.indexOf(new Buffer('a buffer example').slice(0,8));
  // returns 8

const utf16Buffer = new Buffer('\u039a\u0391\u03a3\u03a3\u0395', 'ucs2');

utf16Buffer.indexOf('\u03a3',  0, 'ucs2');
  // returns 4
utf16Buffer.indexOf('\u03a3', -4, 'ucs2');
  // returns 6
</pre> <h3 id="buffer_buf_keys">buf.keys()</h3> <div class="api_metadata"> <span>Added in: v1.1.0</span> </div>
<ul> <li>Returns: <span class="type">&lt;Iterator&gt;</span>
</li> </ul> <p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank">iterator</a> of Buffer keys (indices).</p> <pre data-language="js">const buf = new Buffer('buffer');
for (var key of buf.keys()) {
  console.log(key);
}
// prints:
//   0
//   1
//   2
//   3
//   4
//   5
</pre> <h3 id="buffer_buf_length">buf.length</h3> <div class="signature">
<ul> <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a></li> </ul> </div>
<p>Returns the amount of memory allocated for the Buffer in number of bytes. Note that this does not necessarily reflect the amount of usable data within the Buffer. For instance, in the example below, a Buffer with 1234 bytes is allocated, but only 11 ASCII bytes are written.</p> <pre data-language="js">const buf = new Buffer(1234);

console.log(buf.length);
  // Prints: 1234

buf.write('some string', 0, 'ascii');
console.log(buf.length);
  // Prints: 1234
</pre> <p>While the <code>length</code> property is not immutable, changing the value of <code>length</code> can result in undefined and inconsistent behavior. Applications that wish to modify the length of a Buffer should therefore treat <code>length</code> as read-only and use <a href="#buffer_buf_slice_start_end"><code>buf.slice()</code></a> to create a new Buffer.</p> <pre data-language="js">var buf = new Buffer(10);
buf.write('abcdefghj', 0, 'ascii');
console.log(buf.length);
  // Prints: 10
buf = buf.slice(0,5);
console.log(buf.length);
  // Prints: 5
</pre> <h3 id="buffer_buf_readdoublebe_offset_noassert">buf.readDoubleBE(offset[, noAssert])</h3> <h3 id="buffer_buf_readdoublele_offset_noassert">buf.readDoubleLE(offset[, noAssert])</h3> <div class="signature">
<ul> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - 8</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> </ul> </div>
<p>Reads a 64-bit double from the Buffer at the specified <code>offset</code> with specified endian format (<code>readDoubleBE()</code> returns big endian, <code>readDoubleLE()</code> returns little endian).</p> <p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the <code>offset</code> to be beyond the end of the Buffer.</p> <pre data-language="js">const buf = new Buffer([1,2,3,4,5,6,7,8]);

buf.readDoubleBE();
  // Returns: 8.20788039913184e-304
buf.readDoubleLE();
  // Returns: 5.447603722011605e-270
buf.readDoubleLE(1);
  // throws RangeError: Index out of range

buf.readDoubleLE(1, true); // Warning: reads passed end of buffer!
  // Segmentation fault! don't do this!
</pre> <h3 id="buffer_buf_readfloatbe_offset_noassert">buf.readFloatBE(offset[, noAssert])</h3> <h3 id="buffer_buf_readfloatle_offset_noassert">buf.readFloatLE(offset[, noAssert])</h3> <div class="signature">
<ul> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - 4</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> </ul> </div>
<p>Reads a 32-bit float from the Buffer at the specified <code>offset</code> with specified endian format (<code>readFloatBE()</code> returns big endian, <code>readFloatLE()</code> returns little endian).</p> <p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the <code>offset</code> to be beyond the end of the Buffer.</p> <pre data-language="js">const buf = new Buffer([1,2,3,4]);

buf.readFloatBE();
  // Returns: 2.387939260590663e-38
buf.readFloatLE();
  // Returns: 1.539989614439558e-36
buf.readFloatLE(1);
  // throws RangeError: Index out of range

buf.readFloatLE(1, true); // Warning: reads passed end of buffer!
  // Segmentation fault! don't do this!
</pre> <h3 id="buffer_buf_readint8_offset_noassert">buf.readInt8(offset[, noAssert])</h3> <div class="signature">
<ul> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - 1</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> </ul> </div>
<p>Reads a signed 8-bit integer from the Buffer at the specified <code>offset</code>.</p> <p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the <code>offset</code> to be beyond the end of the Buffer.</p> <p>Integers read from the Buffer are interpreted as two's complement signed values.</p> <pre data-language="js">const buf = new Buffer([1,-2,3,4]);

buf.readInt8(0);
  // returns 1
buf.readInt8(1);
  // returns -2
</pre> <h3 id="buffer_buf_readint16be_offset_noassert">buf.readInt16BE(offset[, noAssert])</h3> <h3 id="buffer_buf_readint16le_offset_noassert">buf.readInt16LE(offset[, noAssert])</h3> <div class="signature">
<ul> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - 2</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> </ul> </div>
<p>Reads a signed 16-bit integer from the Buffer at the specified <code>offset</code> with the specified endian format (<code>readInt16BE()</code> returns big endian, <code>readInt16LE()</code> returns little endian).</p> <p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the <code>offset</code> to be beyond the end of the Buffer.</p> <p>Integers read from the Buffer are interpreted as two's complement signed values.</p> <pre data-language="js">const buf = new Buffer([1,-2,3,4]);

buf.readInt16BE();
  // returns 510
buf.readInt16LE(1);
  // returns 1022
</pre> <h3 id="buffer_buf_readint32be_offset_noassert">buf.readInt32BE(offset[, noAssert])</h3> <h3 id="buffer_buf_readint32le_offset_noassert">buf.readInt32LE(offset[, noAssert])</h3> <div class="signature">
<ul> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - 4</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> </ul> </div>
<p>Reads a signed 32-bit integer from the Buffer at the specified <code>offset</code> with the specified endian format (<code>readInt32BE()</code> returns big endian, <code>readInt32LE()</code> returns little endian).</p> <p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the <code>offset</code> to be beyond the end of the Buffer.</p> <p>Integers read from the Buffer are interpreted as two's complement signed values.</p> <pre data-language="js">const buf = new Buffer([1,-2,3,4]);

buf.readInt32BE();
  // returns 33424132
buf.readInt32LE();
  // returns 67370497
buf.readInt32LE(1);
  // throws RangeError: Index out of range
</pre> <h3 id="buffer_buf_readintbe_offset_bytelength_noassert">buf.readIntBE(offset, byteLength[, noAssert])</h3> <h3 id="buffer_buf_readintle_offset_bytelength_noassert">buf.readIntLE(offset, byteLength[, noAssert])</h3> <div class="api_metadata"> <span>Added in: v1.0.0</span> </div>
<ul> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - byteLength</code>
</li> <li>
<code>byteLength</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt; byteLength &lt;= 6</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> </ul> <p>Reads <code>byteLength</code> number of bytes from the Buffer at the specified <code>offset</code> and interprets the result as a two's complement signed value. Supports up to 48 bits of accuracy. For example:</p> <pre data-language="js">const buf = new Buffer(6);
buf.writeUInt16LE(0x90ab, 0);
buf.writeUInt32LE(0x12345678, 2);
buf.readIntLE(0, 6).toString(16);  // Specify 6 bytes (48 bits)
// Returns: '1234567890ab'

buf.readIntBE(0, 6).toString(16);
// Returns: -546f87a9cbee
</pre> <p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the <code>offset</code> to be beyond the end of the Buffer.</p> <h3 id="buffer_buf_readuint8_offset_noassert">buf.readUInt8(offset[, noAssert])</h3> <div class="signature">
<ul> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - 1</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> </ul> </div>
<p>Reads an unsigned 8-bit integer from the Buffer at the specified <code>offset</code>.</p> <p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the <code>offset</code> to be beyond the end of the Buffer.</p> <pre data-language="js">const buf = new Buffer([1,-2,3,4]);

buf.readUInt8(0);
  // returns 1
buf.readUInt8(1);
  // returns 254
</pre> <h3 id="buffer_buf_readuint16be_offset_noassert">buf.readUInt16BE(offset[, noAssert])</h3> <h3 id="buffer_buf_readuint16le_offset_noassert">buf.readUInt16LE(offset[, noAssert])</h3> <div class="signature">
<ul> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - 2</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> </ul> </div>
<p>Reads an unsigned 16-bit integer from the Buffer at the specified <code>offset</code> with specified endian format (<code>readUInt16BE()</code> returns big endian, <code>readUInt16LE()</code> returns little endian).</p> <p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the <code>offset</code> to be beyond the end of the Buffer.</p> <p>Example:</p> <pre data-language="js">const buf = new Buffer([0x3, 0x4, 0x23, 0x42]);

buf.readUInt16BE(0);
  // Returns: 0x0304
buf.readUInt16LE(0);
  // Returns: 0x0403
buf.readUInt16BE(1);
  // Returns: 0x0423
buf.readUInt16LE(1);
  // Returns: 0x2304
buf.readUInt16BE(2);
  // Returns: 0x2342
buf.readUInt16LE(2);
  // Returns: 0x4223
</pre> <h3 id="buffer_buf_readuint32be_offset_noassert">buf.readUInt32BE(offset[, noAssert])</h3> <h3 id="buffer_buf_readuint32le_offset_noassert">buf.readUInt32LE(offset[, noAssert])</h3> <div class="signature">
<ul> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - 4</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> </ul> </div>
<p>Reads an unsigned 32-bit integer from the Buffer at the specified <code>offset</code> with specified endian format (<code>readUInt32BE()</code> returns big endian, <code>readUInt32LE()</code> returns little endian).</p> <p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the <code>offset</code> to be beyond the end of the Buffer.</p> <p>Example:</p> <pre data-language="js">const buf = new Buffer([0x3, 0x4, 0x23, 0x42]);

buf.readUInt32BE(0);
  // Returns: 0x03042342
console.log(buf.readUInt32LE(0));
  // Returns: 0x42230403
</pre> <h3 id="buffer_buf_readuintbe_offset_bytelength_noassert">buf.readUIntBE(offset, byteLength[, noAssert])</h3> <h3 id="buffer_buf_readuintle_offset_bytelength_noassert">buf.readUIntLE(offset, byteLength[, noAssert])</h3> <div class="api_metadata"> <span>Added in: v1.0.0</span> </div>
<ul> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - byteLength</code>
</li> <li>
<code>byteLength</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt; byteLength &lt;= 6</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a>
</li> </ul> <p>Reads <code>byteLength</code> number of bytes from the Buffer at the specified <code>offset</code> and interprets the result as an unsigned integer. Supports up to 48 bits of accuracy. For example:</p> <pre data-language="js">const buf = new Buffer(6);
buf.writeUInt16LE(0x90ab, 0);
buf.writeUInt32LE(0x12345678, 2);
buf.readUIntLE(0, 6).toString(16);  // Specify 6 bytes (48 bits)
// Returns: '1234567890ab'

buf.readUIntBE(0, 6).toString(16);
// Returns: ab9078563412
</pre> <p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the <code>offset</code> to be beyond the end of the Buffer.</p> <h3 id="buffer_buf_slice_start_end">buf.slice([start[, end]])</h3> <div class="signature">
<ul> <li>
<code>start</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Default: 0</li> <li>
<code>end</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Default: <code>buffer.length</code>
</li> <li>Returns: <a href="../buffer/#buffer_class_buffer" class="type">&lt;Buffer&gt;</a>
</li> </ul> </div>
<p>Returns a new Buffer that references the same memory as the original, but offset and cropped by the <code>start</code> and <code>end</code> indices.</p> <p><strong>Note that modifying the new Buffer slice will modify the memory in the original Buffer because the allocated memory of the two objects overlap.</strong></p> <p>Example: build a Buffer with the ASCII alphabet, take a slice, then modify one byte from the original Buffer.</p> <pre data-language="js">const buf1 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
}

const buf2 = buf1.slice(0, 3);
buf2.toString('ascii', 0, buf2.length);
  // Returns: 'abc'
buf1[0] = 33;
buf2.toString('ascii', 0, buf2.length);
  // Returns : '!bc'
</pre> <p>Specifying negative indexes causes the slice to be generated relative to the end of the Buffer rather than the beginning.</p> <pre data-language="js">const buf = new Buffer('buffer');

buf.slice(-6, -1).toString();
  // Returns 'buffe', equivalent to buf.slice(0, 5)
buf.slice(-6, -2).toString();
  // Returns 'buff', equivalent to buf.slice(0, 4)
buf.slice(-5, -2).toString();
  // Returns 'uff', equivalent to buf.slice(1, 4)
</pre> <h3 id="buffer_buf_tostring_encoding_start_end">buf.toString([encoding[, start[, end]]])</h3> <div class="signature">
<ul> <li>
<code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type" target="_blank">&lt;String&gt;</a> Default: <code>'utf8'</code>
</li> <li>
<code>start</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Default: 0</li> <li>
<code>end</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Default: <code>buffer.length</code>
</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type" target="_blank">&lt;String&gt;</a>
</li> </ul> </div>
<p>Decodes and returns a string from the Buffer data using the specified character set <code>encoding</code>.</p> <pre data-language="js">const buf = new Buffer(26);
for (var i = 0 ; i &lt; 26 ; i++) {
  buf[i] = i + 97; // 97 is ASCII a
}
buf.toString('ascii');
  // Returns: 'abcdefghijklmnopqrstuvwxyz'
buf.toString('ascii',0,5);
  // Returns: 'abcde'
buf.toString('utf8',0,5);
  // Returns: 'abcde'
buf.toString(undefined,0,5);
  // Returns: 'abcde', encoding defaults to 'utf8'
</pre> <h3 id="buffer_buf_tojson">buf.toJSON()</h3> <div class="api_metadata"> <span>Added in: v0.9.2</span> </div>
<ul> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type" target="_blank">&lt;Object&gt;</a>
</li> </ul> <p>Returns a JSON representation of the Buffer instance. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank"><code>JSON.stringify()</code></a> implicitly calls this function when stringifying a Buffer instance.</p> <p>Example:</p> <pre data-language="js">const buf = new Buffer('test');
const json = JSON.stringify(buf);

console.log(json);
// Prints: '{"type":"Buffer","data":[116,101,115,116]}'

const copy = JSON.parse(json, (key, value) =&gt; {
    return value &amp;&amp; value.type === 'Buffer'
      ? new Buffer(value.data)
      : value;
  });

console.log(copy.toString());
// Prints: 'test'
</pre> <h3 id="buffer_buf_values">buf.values()</h3> <div class="api_metadata"> <span>Added in: v1.1.0</span> </div>
<ul> <li>Returns: <span class="type">&lt;Iterator&gt;</span>
</li> </ul> <p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank">iterator</a> for Buffer values (bytes). This function is called automatically when the Buffer is used in a <code>for..of</code> statement.</p> <pre data-language="js">const buf = new Buffer('buffer');
for (var value of buf.values()) {
  console.log(value);
}
// prints:
//   98
//   117
//   102
//   102
//   101
//   114

for (var value of buf) {
  console.log(value);
}
// prints:
//   98
//   117
//   102
//   102
//   101
//   114
</pre> <h3 id="buffer_buf_write_string_offset_length_encoding">buf.write(string[, offset[, length]][, encoding])</h3> <div class="signature">
<ul> <li>
<code>string</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type" target="_blank">&lt;String&gt;</a> Bytes to be written to buffer</li> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Default: 0</li> <li>
<code>length</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Default: <code>buffer.length - offset</code>
</li> <li>
<code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type" target="_blank">&lt;String&gt;</a> Default: <code>'utf8'</code>
</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Numbers of bytes written</li> </ul> </div>
<p>Writes <code>string</code> to the Buffer at <code>offset</code> using the given <code>encoding</code>. The <code>length</code> parameter is the number of bytes to write. If the Buffer did not contain enough space to fit the entire string, only a partial amount of the string will be written however, it will not write only partially encoded characters.</p> <pre data-language="js">const buf = new Buffer(256);
const len = buf.write('\u00bd + \u00bc = \u00be', 0);
console.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);
  // Prints: 12 bytes: ½ + ¼ = ¾
</pre> <h3 id="buffer_buf_writedoublebe_value_offset_noassert">buf.writeDoubleBE(value, offset[, noAssert])</h3> <h3 id="buffer_buf_writedoublele_value_offset_noassert">buf.writeDoubleLE(value, offset[, noAssert])</h3> <div class="signature">
<ul> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Bytes to be written to Buffer</li> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - 8</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> The offset plus the number of written bytes</li> </ul> </div>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian format (<code>writeDoubleBE()</code> writes big endian, <code>writeDoubleLE()</code> writes little endian). The <code>value</code> argument <em>should</em> be a valid 64-bit double. Behavior is not defined when <code>value</code> is anything other than a 64-bit double.</p> <p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means that <code>value</code> may be too large for the specific function and <code>offset</code> may be beyond the end of the Buffer leading to the values being silently dropped. This should not be used unless you are certain of correctness.</p> <p>Example:</p> <pre data-language="js">const buf = new Buffer(8);
buf.writeDoubleBE(0xdeadbeefcafebabe, 0);

console.log(buf);
  // Prints: &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;

buf.writeDoubleLE(0xdeadbeefcafebabe, 0);

console.log(buf);
  // Prints: &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;
</pre> <h3 id="buffer_buf_writefloatbe_value_offset_noassert">buf.writeFloatBE(value, offset[, noAssert])</h3> <h3 id="buffer_buf_writefloatle_value_offset_noassert">buf.writeFloatLE(value, offset[, noAssert])</h3> <div class="signature">
<ul> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Bytes to be written to Buffer</li> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - 4</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> The offset plus the number of written bytes</li> </ul> </div>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian format (<code>writeFloatBE()</code> writes big endian, <code>writeFloatLE()</code> writes little endian). Behavior is not defined when <code>value</code> is anything other than a 32-bit float.</p> <p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means that <code>value</code> may be too large for the specific function and <code>offset</code> may be beyond the end of the Buffer leading to the values being silently dropped. This should not be used unless you are certain of correctness.</p> <p>Example:</p> <pre data-language="js">const buf = new Buffer(4);
buf.writeFloatBE(0xcafebabe, 0);

console.log(buf);
  // Prints: &lt;Buffer 4f 4a fe bb&gt;

buf.writeFloatLE(0xcafebabe, 0);

console.log(buf);
  // Prints: &lt;Buffer bb fe 4a 4f&gt;
</pre> <h3 id="buffer_buf_writeint8_value_offset_noassert">buf.writeInt8(value, offset[, noAssert])</h3> <div class="signature">
<ul> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Bytes to be written to Buffer</li> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - 1</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> The offset plus the number of written bytes</li> </ul> </div>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code>. The <code>value</code> should be a valid signed 8-bit integer. Behavior is not defined when <code>value</code> is anything other than a signed 8-bit integer.</p> <p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means that <code>value</code> may be too large for the specific function and <code>offset</code> may be beyond the end of the Buffer leading to the values being silently dropped. This should not be used unless you are certain of correctness.</p> <p>The <code>value</code> is interpreted and written as a two's complement signed integer.</p> <pre data-language="js">const buf = new Buffer(2);
buf.writeInt8(2, 0);
buf.writeInt8(-2, 1);
console.log(buf);
  // Prints: &lt;Buffer 02 fe&gt;
</pre> <h3 id="buffer_buf_writeint16be_value_offset_noassert">buf.writeInt16BE(value, offset[, noAssert])</h3> <h3 id="buffer_buf_writeint16le_value_offset_noassert">buf.writeInt16LE(value, offset[, noAssert])</h3> <div class="signature">
<ul> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Bytes to be written to Buffer</li> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - 2</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> The offset plus the number of written bytes</li> </ul> </div>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian format (<code>writeInt16BE()</code> writes big endian, <code>writeInt16LE()</code> writes little endian). The <code>value</code> should be a valid signed 16-bit integer. Behavior is not defined when <code>value</code> is anything other than a signed 16-bit integer.</p> <p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means that <code>value</code> may be too large for the specific function and <code>offset</code> may be beyond the end of the Buffer leading to the values being silently dropped. This should not be used unless you are certain of correctness.</p> <p>The <code>value</code> is interpreted and written as a two's complement signed integer.</p> <pre data-language="js">const buf = new Buffer(4);
buf.writeInt16BE(0x0102,0);
buf.writeInt16LE(0x0304,2);
console.log(buf);
  // Prints: &lt;Buffer 01 02 04 03&gt;
</pre> <h3 id="buffer_buf_writeint32be_value_offset_noassert">buf.writeInt32BE(value, offset[, noAssert])</h3> <h3 id="buffer_buf_writeint32le_value_offset_noassert">buf.writeInt32LE(value, offset[, noAssert])</h3> <div class="signature">
<ul> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Bytes to be written to Buffer</li> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - 4</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> The offset plus the number of written bytes</li> </ul> </div>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian format (<code>writeInt32BE()</code> writes big endian, <code>writeInt32LE()</code> writes little endian). The <code>value</code> should be a valid signed 32-bit integer. Behavior is not defined when <code>value</code> is anything other than a signed 32-bit integer.</p> <p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means that <code>value</code> may be too large for the specific function and <code>offset</code> may be beyond the end of the Buffer leading to the values being silently dropped. This should not be used unless you are certain of correctness.</p> <p>The <code>value</code> is interpreted and written as a two's complement signed integer.</p> <pre data-language="js">const buf = new Buffer(8);
buf.writeInt32BE(0x01020304,0);
buf.writeInt32LE(0x05060708,4);
console.log(buf);
  // Prints: &lt;Buffer 01 02 03 04 08 07 06 05&gt;
</pre> <h3 id="buffer_buf_writeintbe_value_offset_bytelength_noassert">buf.writeIntBE(value, offset, byteLength[, noAssert])</h3> <h3 id="buffer_buf_writeintle_value_offset_bytelength_noassert">buf.writeIntLE(value, offset, byteLength[, noAssert])</h3> <div class="api_metadata"> <span>Added in: v1.0.0</span> </div>
<ul> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Bytes to be written to Buffer</li> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - byteLength</code>
</li> <li>
<code>byteLength</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt; byteLength &lt;= 6</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> The offset plus the number of written bytes</li> </ul> <p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> and <code>byteLength</code>. Supports up to 48 bits of accuracy. For example:</p> <pre data-language="js">const buf1 = new Buffer(6);
buf1.writeUIntBE(0x1234567890ab, 0, 6);
console.log(buf1);
  // Prints: &lt;Buffer 12 34 56 78 90 ab&gt;

const buf2 = new Buffer(6);
buf2.writeUIntLE(0x1234567890ab, 0, 6);
console.log(buf2);
  // Prints: &lt;Buffer ab 90 78 56 34 12&gt;
</pre> <p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means that <code>value</code> may be too large for the specific function and <code>offset</code> may be beyond the end of the Buffer leading to the values being silently dropped. This should not be used unless you are certain of correctness.</p> <p>Behavior is not defined when <code>value</code> is anything other than an integer.</p> <h3 id="buffer_buf_writeuint8_value_offset_noassert">buf.writeUInt8(value, offset[, noAssert])</h3> <div class="signature">
<ul> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Bytes to be written to Buffer</li> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - 1</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> The offset plus the number of written bytes</li> </ul> </div>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code>. The <code>value</code> should be a valid unsigned 8-bit integer. Behavior is not defined when <code>value</code> is anything other than an unsigned 8-bit integer.</p> <p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means that <code>value</code> may be too large for the specific function and <code>offset</code> may be beyond the end of the Buffer leading to the values being silently dropped. This should not be used unless you are certain of correctness.</p> <p>Example:</p> <pre data-language="js">const buf = new Buffer(4);
buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

console.log(buf);
  // Prints: &lt;Buffer 03 04 23 42&gt;
</pre> <h3 id="buffer_buf_writeuint16be_value_offset_noassert">buf.writeUInt16BE(value, offset[, noAssert])</h3> <h3 id="buffer_buf_writeuint16le_value_offset_noassert">buf.writeUInt16LE(value, offset[, noAssert])</h3> <div class="signature">
<ul> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Bytes to be written to Buffer</li> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - 2</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> The offset plus the number of written bytes</li> </ul> </div>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian format (<code>writeUInt16BE()</code> writes big endian, <code>writeUInt16LE()</code> writes little endian). The <code>value</code> should be a valid unsigned 16-bit integer. Behavior is not defined when <code>value</code> is anything other than an unsigned 16-bit integer.</p> <p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means that <code>value</code> may be too large for the specific function and <code>offset</code> may be beyond the end of the Buffer leading to the values being silently dropped. This should not be used unless you are certain of correctness.</p> <p>Example:</p> <pre data-language="js">const buf = new Buffer(4);
buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

console.log(buf);
  // Prints: &lt;Buffer de ad be ef&gt;

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

console.log(buf);
  // Prints: &lt;Buffer ad de ef be&gt;
</pre> <h3 id="buffer_buf_writeuint32be_value_offset_noassert">buf.writeUInt32BE(value, offset[, noAssert])</h3> <h3 id="buffer_buf_writeuint32le_value_offset_noassert">buf.writeUInt32LE(value, offset[, noAssert])</h3> <div class="signature">
<ul> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Bytes to be written to Buffer</li> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - 4</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> The offset plus the number of written bytes</li> </ul> </div>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian format (<code>writeUInt32BE()</code> writes big endian, <code>writeUInt32LE()</code> writes little endian). The <code>value</code> should be a valid unsigned 32-bit integer. Behavior is not defined when <code>value</code> is anything other than an unsigned 32-bit integer.</p> <p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means that <code>value</code> may be too large for the specific function and <code>offset</code> may be beyond the end of the Buffer leading to the values being silently dropped. This should not be used unless you are certain of correctness.</p> <p>Example:</p> <pre data-language="js">const buf = new Buffer(4);
buf.writeUInt32BE(0xfeedface, 0);

console.log(buf);
  // Prints: &lt;Buffer fe ed fa ce&gt;

buf.writeUInt32LE(0xfeedface, 0);

console.log(buf);
  // Prints: &lt;Buffer ce fa ed fe&gt;
</pre> <h3 id="buffer_buf_writeuintbe_value_offset_bytelength_noassert">buf.writeUIntBE(value, offset, byteLength[, noAssert])</h3> <h3 id="buffer_buf_writeuintle_value_offset_bytelength_noassert">buf.writeUIntLE(value, offset, byteLength[, noAssert])</h3> <div class="signature">
<ul> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Bytes to be written to Buffer</li> <li>
<code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt;= offset &lt;= buf.length - byteLength</code>
</li> <li>
<code>byteLength</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> <code>0 &lt; byteLength &lt;= 6</code>
</li> <li>
<code>noAssert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type" target="_blank">&lt;Boolean&gt;</a> Default: false</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> The offset plus the number of written bytes</li> </ul> </div>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> and <code>byteLength</code>. Supports up to 48 bits of accuracy. For example:</p> <pre data-language="js">const buf = new Buffer(6);
buf.writeUIntBE(0x1234567890ab, 0, 6);
console.log(buf);
  // Prints: &lt;Buffer 12 34 56 78 90 ab&gt;
</pre> <p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means that <code>value</code> may be too large for the specific function and <code>offset</code> may be beyond the end of the Buffer leading to the values being silently dropped. This should not be used unless you are certain of correctness.</p> <p>Behavior is not defined when <code>value</code> is anything other than an unsigned integer.</p> <h2 id="buffer_buffer_inspect_max_bytes">buffer.INSPECT_MAX_BYTES</h2> <div class="signature">
<ul> <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type" target="_blank">&lt;Number&gt;</a> Default: 50</li> </ul> </div>
<p>Returns the maximum number of bytes that will be returned when <code>buffer.inspect()</code> is called. This can be overridden by user modules. See <a href="../util/#util_util_inspect_object_options"><code>util.inspect()</code></a> for more details on <code>buffer.inspect()</code> behavior.</p> <p>Note that this is a property on the <code>buffer</code> module as returned by <code>require('buffer')</code>, not on the Buffer global or a Buffer instance.</p> <h2 id="buffer_class_slowbuffer">Class: SlowBuffer</h2> <p>Returns an un-pooled <code>Buffer</code>.</p> <p>In order to avoid the garbage collection overhead of creating many individually allocated Buffers, by default allocations under 4KB are sliced from a single larger allocated object. This approach improves both performance and memory usage since v8 does not need to track and cleanup as many <code>Persistent</code> objects.</p> <p>In the case where a developer may need to retain a small chunk of memory from a pool for an indeterminate amount of time, it may be appropriate to create an un-pooled Buffer instance using <code>SlowBuffer</code> then copy out the relevant bits.</p> <pre data-language="js">// need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () =&gt; {
  var data = socket.read();
  // allocate for retained data
  var sb = new SlowBuffer(10);
  // copy the data into the new allocation
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});
</pre> <p>Use of <code>SlowBuffer</code> should be used only as a last resort <em>after</em> a developer has observed undue memory retention in their applications.</p> <h3 id="buffer_new_slowbuffer_size">new SlowBuffer(size)</h3> <div class="signature">
<ul> <li>
<code>size</code> Number</li> </ul> </div>
<p>Allocates a new <code>SlowBuffer</code> of <code>size</code> bytes. The <code>size</code> must be less than or equal to the value of <code>require('buffer').kMaxLength</code> (on 64-bit architectures, <code>kMaxLength</code> is <code>(2^31)-1</code>). Otherwise, a <a href="../errors/#errors_class_rangeerror"><code>RangeError</code></a> is thrown. If a <code>size</code> less than 0 is specified, a zero-length <code>SlowBuffer</code> will be created.</p> <p>The underlying memory for <code>SlowBuffer</code> instances is <em>not initialized</em>. The contents of a newly created <code>SlowBuffer</code> are unknown and could contain sensitive data. Use <a href="#buffer_buf_fill_value_offset_end"><code>buf.fill(0)</code></a> to initialize a <code>SlowBuffer</code> to zeroes.</p> <pre data-language="js">const SlowBuffer = require('buffer').SlowBuffer;
const buf = new SlowBuffer(5);
console.log(buf);
  // &lt;Buffer 78 e0 82 02 01&gt;
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // &lt;Buffer 00 00 00 00 00&gt;
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © Joyent, Inc. and other Node contributors<br>Licensed under the MIT License.<br>Node.js is a trademark of Joyent, Inc. and is used with its permission.<br>We are not endorsed by or affiliated with Joyent.<br>
    <a href="https://nodejs.org/dist/latest-v4.x/docs/api/buffer.html" class="_attribution-link" target="_blank">https://nodejs.org/dist/latest-v4.x/docs/api/buffer.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
