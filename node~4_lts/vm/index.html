
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Vm - Node.js 4 LTS - W3cubDocs</title>
  
  <meta name="description" content=" You can access this module with&#58; ">
  <meta name="keywords" content="vm, executing, javascript, -, node, js, lts, node~4_lts">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/node~4_lts/vm/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/node~4_lts.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/node~4_lts/" class="_nav-link" title="" style="margin-left:0;">Node.js 4 LTS</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _node">
				
				
<h1 id="vm_vm_executing_javascript">VM (Executing JavaScript)</h1> <div class="api_stability api_stability_2">Stability: 2 - Stable</div> <p>You can access this module with:</p> <pre data-language="js">const vm = require('vm');
</pre> <p>JavaScript code can be compiled and run immediately or compiled, saved, and run later.</p> <h2 id="vm_class_script">Class: Script</h2> <div class="api_metadata"> <span>Added in: v0.3.1</span> </div>
<p>A class for holding precompiled scripts, and running them in specific sandboxes.</p> <h3 id="vm_new_vm_script_code_options">new vm.Script(code, options)</h3> <div class="api_metadata"> <span>Added in: v0.3.1</span> </div>
<p>Creating a new <code>Script</code> compiles <code>code</code> but does not run it. Instead, the created <code>vm.Script</code> object represents this compiled code. This script can be run later many times using methods below. The returned script is not bound to any global object. It is bound before each run, just for that run.</p> <p>The options when creating a script are:</p> <ul> <li>
<code>filename</code>: allows you to control the filename that shows up in any stack traces produced from this script.</li> <li>
<code>lineOffset</code>: allows you to add an offset to the line number that is displayed in stack traces</li> <li>
<code>columnOffset</code>: allows you to add an offset to the column number that is displayed in stack traces</li> <li>
<code>displayErrors</code>: whether or not to print any errors to stderr, with the line of code that caused them highlighted, before throwing an exception. Applies only to syntax errors compiling the code; errors while running the code are controlled by the options to the script's methods.</li> <li>
<code>timeout</code>: a number of milliseconds to execute <code>code</code> before terminating execution. If execution is terminated, an <a href="../errors/#errors_class_error"><code>Error</code></a> will be thrown.</li> </ul> <h3 id="vm_script_runincontext_contextifiedsandbox_options">script.runInContext(contextifiedSandbox[, options])</h3> <div class="api_metadata"> <span>Added in: v0.3.1</span> </div>
<p>Similar to <a href="#vm_vm_runincontext_code_contextifiedsandbox_options"><code>vm.runInContext()</code></a> but a method of a precompiled <code>Script</code> object. <code>script.runInContext()</code> runs <code>script</code>'s compiled code in <code>contextifiedSandbox</code> and returns the result. Running code does not have access to local scope.</p> <p><code>script.runInContext()</code> takes the same options as <a href="#vm_script_runinthiscontext_options"><code>script.runInThisContext()</code></a>.</p> <p>Example: compile code that increments a global variable and sets one, then execute the code multiple times. These globals are contained in the sandbox.</p> <pre data-language="js">const util = require('util');
const vm = require('vm');

var sandbox = {
  animal: 'cat',
  count: 2
};

var context = new vm.createContext(sandbox);
var script = new vm.Script('count += 1; name = "kitty"');

for (var i = 0; i &lt; 10; ++i) {
  script.runInContext(context);
}

console.log(util.inspect(sandbox));

// { animal: 'cat', count: 12, name: 'kitty' }
</pre> <p>Note that running untrusted code is a tricky business requiring great care. <code>script.runInContext()</code> is quite useful, but safely running untrusted code requires a separate process.</p> <h3 id="vm_script_runinnewcontext_sandbox_options">script.runInNewContext([sandbox][, options])</h3> <div class="api_metadata"> <span>Added in: v0.3.1</span> </div>
<p>Similar to <a href="#vm_vm_runinnewcontext_code_sandbox_options"><code>vm.runInNewContext()</code></a> but a method of a precompiled <code>Script</code> object. <code>script.runInNewContext()</code> contextifies <code>sandbox</code> if passed or creates a new contextified sandbox if it's omitted, and then runs <code>script</code>'s compiled code with the sandbox as the global object and returns the result. Running code does not have access to local scope.</p> <p><code>script.runInNewContext()</code> takes the same options as <a href="#vm_script_runinthiscontext_options"><code>script.runInThisContext()</code></a>.</p> <p>Example: compile code that sets a global variable, then execute the code multiple times in different contexts. These globals are set on and contained in the sandboxes.</p> <pre data-language="js">const util = require('util');
const vm = require('vm');

const sandboxes = [{}, {}, {}];

const script = new vm.Script('globalVar = "set"');

sandboxes.forEach((sandbox) =&gt; {
  script.runInNewContext(sandbox);
});

console.log(util.inspect(sandboxes));

// [{ globalVar: 'set' }, { globalVar: 'set' }, { globalVar: 'set' }]
</pre> <p>Note that running untrusted code is a tricky business requiring great care. <code>script.runInNewContext()</code> is quite useful, but safely running untrusted code requires a separate process.</p> <h3 id="vm_script_runinthiscontext_options">script.runInThisContext([options])</h3> <div class="api_metadata"> <span>Added in: v0.3.1</span> </div>
<p>Similar to <a href="../vm/"><code>vm.runInThisContext()</code></a> but a method of a precompiled <code>Script</code> object. <code>script.runInThisContext()</code> runs <code>script</code>'s compiled code and returns the result. Running code does not have access to local scope, but does have access to the current <code>global</code> object.</p> <p>Example of using <code>script.runInThisContext()</code> to compile code once and run it multiple times:</p> <pre data-language="js">const vm = require('vm');

global.globalVar = 0;

const script = new vm.Script('globalVar += 1', { filename: 'myfile.vm' });

for (var i = 0; i &lt; 1000; ++i) {
  script.runInThisContext();
}

console.log(globalVar);

// 1000
</pre> <p>The options for running a script are:</p> <ul> <li>
<code>filename</code>: allows you to control the filename that shows up in any stack traces produced.</li> <li>
<code>lineOffset</code>: allows you to add an offset to the line number that is displayed in stack traces</li> <li>
<code>columnOffset</code>: allows you to add an offset to the column number that is displayed in stack traces</li> <li>
<code>displayErrors</code>: whether or not to print any errors to stderr, with the line of code that caused them highlighted, before throwing an exception. Applies only to runtime errors executing the code; it is impossible to create a <code>Script</code> instance with syntax errors, as the constructor will throw.</li> <li>
<code>timeout</code>: a number of milliseconds to execute the script before terminating execution. If execution is terminated, an <a href="../errors/#errors_class_error"><code>Error</code></a> will be thrown.</li> </ul> <h2 id="vm_vm_createcontext_sandbox">vm.createContext([sandbox])</h2> <div class="api_metadata"> <span>Added in: v0.3.1</span> </div>
<p>If given a <code>sandbox</code> object, will "contextify" that sandbox so that it can be used in calls to <a href="#vm_vm_runincontext_code_contextifiedsandbox_options"><code>vm.runInContext()</code></a> or <a href="#vm_script_runincontext_contextifiedsandbox_options"><code>script.runInContext()</code></a>. Inside scripts run as such, <code>sandbox</code> will be the global object, retaining all its existing properties but also having the built-in objects and functions any standard <a href="https://es5.github.io/#x15.1" target="_blank">global object</a> has. Outside of scripts run by the vm module, <code>sandbox</code> will be unchanged.</p> <p>If not given a sandbox object, returns a new, empty contextified sandbox object you can use.</p> <p>This function is useful for creating a sandbox that can be used to run multiple scripts, e.g. if you were emulating a web browser it could be used to create a single sandbox representing a window's global object, then run all <code>&lt;script&gt;</code> tags together inside that sandbox.</p> <h2 id="vm_vm_iscontext_sandbox">vm.isContext(sandbox)</h2> <div class="api_metadata"> <span>Added in: v0.11.7</span> </div>
<p>Returns whether or not a sandbox object has been contextified by calling <a href="#vm_vm_createcontext_sandbox"><code>vm.createContext()</code></a> on it.</p> <h2 id="vm_vm_runincontext_code_contextifiedsandbox_options">vm.runInContext(code, contextifiedSandbox[, options])</h2> <p><code>vm.runInContext()</code> compiles <code>code</code>, then runs it in <code>contextifiedSandbox</code> and returns the result. Running code does not have access to local scope. The <code>contextifiedSandbox</code> object must have been previously contextified via <a href="#vm_vm_createcontext_sandbox"><code>vm.createContext()</code></a>; it will be used as the global object for <code>code</code>.</p> <p><code>vm.runInContext()</code> takes the same options as <a href="#vm_vm_runinthiscontext_code_options"><code>vm.runInThisContext()</code></a>.</p> <p>Example: compile and execute different scripts in a single existing context.</p> <pre data-language="js">const util = require('util');
const vm = require('vm');

const sandbox = { globalVar: 1 };
vm.createContext(sandbox);

for (var i = 0; i &lt; 10; ++i) {
    vm.runInContext('globalVar *= 2;', sandbox);
}
console.log(util.inspect(sandbox));

// { globalVar: 1024 }
</pre> <p>Note that running untrusted code is a tricky business requiring great care. <code>vm.runInContext()</code> is quite useful, but safely running untrusted code requires a separate process.</p> <h2 id="vm_vm_runindebugcontext_code">vm.runInDebugContext(code)</h2> <div class="api_metadata"> <span>Added in: v0.11.14</span> </div>
<p><code>vm.runInDebugContext()</code> compiles and executes <code>code</code> inside the V8 debug context. The primary use case is to get access to the V8 debug object:</p> <pre data-language="js">const vm = require('vm');
const Debug = vm.runInDebugContext('Debug');
console.log(Debug.findScript(process.emit).name);  // 'events.js'
console.log(Debug.findScript(process.exit).name);  // 'internal/process.js'
</pre> <p>Note that the debug context and object are intrinsically tied to V8's debugger implementation and may change (or even get removed) without prior warning.</p> <p>The debug object can also be exposed with the <code>--expose_debug_as=</code> switch.</p> <h2 id="vm_vm_runinnewcontext_code_sandbox_options">vm.runInNewContext(code[, sandbox][, options])</h2> <div class="api_metadata"> <span>Added in: v0.3.1</span> </div>
<p><code>vm.runInNewContext()</code> compiles <code>code</code>, contextifies <code>sandbox</code> if passed or creates a new contextified sandbox if it's omitted, and then runs the code with the sandbox as the global object and returns the result.</p> <p><code>vm.runInNewContext()</code> takes the same options as <a href="#vm_vm_runinthiscontext_code_options"><code>vm.runInThisContext()</code></a>.</p> <p>Example: compile and execute code that increments a global variable and sets a new one. These globals are contained in the sandbox.</p> <pre data-language="js">const util = require('util');
const vm = require('vm');

const sandbox = {
  animal: 'cat',
  count: 2
};

vm.runInNewContext('count += 1; name = "kitty"', sandbox);
console.log(util.inspect(sandbox));

// { animal: 'cat', count: 3, name: 'kitty' }
</pre> <p>Note that running untrusted code is a tricky business requiring great care. <code>vm.runInNewContext()</code> is quite useful, but safely running untrusted code requires a separate process.</p> <h2 id="vm_vm_runinthiscontext_code_options">vm.runInThisContext(code[, options])</h2> <div class="api_metadata"> <span>Added in: v0.3.1</span> </div>
<p><code>vm.runInThisContext()</code> compiles <code>code</code>, runs it and returns the result. Running code does not have access to local scope, but does have access to the current <code>global</code> object.</p> <p>Example of using <code>vm.runInThisContext()</code> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank"><code>eval()</code></a> to run the same code:</p> <pre data-language="js">const vm = require('vm');
var localVar = 'initial value';

const vmResult = vm.runInThisContext('localVar = "vm";');
console.log('vmResult:', vmResult);
console.log('localVar:', localVar);

const evalResult = eval('localVar = "eval";');
console.log('evalResult:', evalResult);
console.log('localVar:', localVar);

// vmResult: 'vm', localVar: 'initial value'
// evalResult: 'eval', localVar: 'eval'
</pre> <p><code>vm.runInThisContext()</code> does not have access to the local scope, so <code>localVar</code> is unchanged. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank"><code>eval()</code></a> does have access to the local scope, so <code>localVar</code> is changed.</p> <p>In this way <code>vm.runInThisContext()</code> is much like an <a href="https://es5.github.io/#x10.4.2" target="_blank">indirect <code>eval()</code> call</a>, e.g. <code>(0,eval)('code')</code>. However, it also has the following additional options:</p> <ul> <li>
<code>filename</code>: allows you to control the filename that shows up in any stack traces produced.</li> <li>
<code>lineOffset</code>: allows you to add an offset to the line number that is displayed in stack traces</li> <li>
<code>columnOffset</code>: allows you to add an offset to the column number that is displayed in stack traces</li> <li>
<code>displayErrors</code>: whether or not to print any errors to stderr, with the line of code that caused them highlighted, before throwing an exception. Will capture both syntax errors from compiling <code>code</code> and runtime errors thrown by executing the compiled code. Defaults to <code>true</code>.</li> <li>
<code>timeout</code>: a number of milliseconds to execute <code>code</code> before terminating execution. If execution is terminated, an <a href="../errors/#errors_class_error"><code>Error</code></a> will be thrown.</li> </ul> <h2 id="vm_example_run_a_server_within_a_vm">Example: Run a Server within a VM</h2> <p>The context of <code>.runInThisContext()</code> refers to the V8 context. The code passed to this VM context will have it's own isolated scope. To run a simple web server using the <code>http</code> module, for instance, the code passed to the context must either call <code>require('http')</code> on its own, or have a reference to the <code>http</code> module passed to it. For instance:</p> <pre data-language="js">'use strict';
const vm = require('vm');

let code =
`(function(require) {

   const http = require('http');

   http.createServer( (request, response) =&gt; {
     response.writeHead(200, {'Content-Type': 'text/plain'});
     response.end('Hello World\\n');
   }).listen(8124);

   console.log('Server running at http://127.0.0.1:8124/');
 })`;

 vm.runInThisContext(code)(require);
</pre> <p><em>Note: <code>require()</code> in the above case shares the state with context it is passed from. This might introduce risks when unknown code is executed, e.g. altering objects from the calling thread's context in unwanted ways. It is advisable to run <code>vm</code> code in a separate process.</em></p>
<div class="_attribution">
  <p class="_attribution-p">
    © Joyent, Inc. and other Node contributors<br>Licensed under the MIT License.<br>Node.js is a trademark of Joyent, Inc. and is used with its permission.<br>We are not endorsed by or affiliated with Joyent.<br>
    <a href="https://nodejs.org/dist/latest-v4.x/docs/api/vm.html" class="_attribution-link" target="_blank">https://nodejs.org/dist/latest-v4.x/docs/api/vm.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
