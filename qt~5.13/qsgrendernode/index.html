
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>QSGRenderNode (Class) - Qt 5.13 - W3cubDocs</title>
  
  <meta name="description" content=" The QSGRenderNode class represents a set of custom rendering commands targeting the graphics API that is in use by the scenegraph. More... ">
  <meta name="keywords" content="qsgrendernode, class, -, qt, qt~5.13">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/qt~5.13/qsgrendernode/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/qt~5.13.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/qt~5.13/" class="_nav-link" title="" style="margin-left:0;">Qt 5.13</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _qt">
				
				
<h1 class="title">QSGRenderNode Class</h1>  <p>The <a href="../qsgrendernode/">QSGRenderNode</a> class represents a set of custom rendering commands targeting the graphics API that is in use by the scenegraph. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QSGRenderNode&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += quick</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.8</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> <a href="../qsgnode/">QSGNode</a>
</td>
</tr>
</table>
<p>This class was introduced in Qt 5.8.</p> <ul> <li><a href="https://doc.qt.io/qt-5.13/qsgrendernode-members.html" target="_blank">List of all members, including inherited members</a></li> </ul>  <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="../qsgrendernode/#RenderingFlag-enum">RenderingFlag</a></b> { BoundedRectRendering, DepthAwareRendering, OpaqueRendering }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> flags </td>
<td class="memItemRight bottomAlign"><b><a href="../qsgrendernode/#RenderingFlag-enum">RenderingFlags</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="../qsgrendernode/#StateFlag-enum">StateFlag</a></b> { DepthState, StencilState, ScissorState, ColorState, ..., RenderTargetState }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> flags </td>
<td class="memItemRight bottomAlign"><b><a href="../qsgrendernode/#StateFlag-enum">StateFlags</a></b></td>
</tr> </table>  <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual </td>
<td class="memItemRight bottomAlign">
<b><a href="../qsgrendernode/#dtor.QSGRenderNode">~QSGRenderNode</a></b>() override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual QSGRenderNode::StateFlags </td>
<td class="memItemRight bottomAlign">
<b><a href="../qsgrendernode/#changedStates">changedStates</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const QSGClipNode *</td>
<td class="memItemRight bottomAlign">
<b><a href="../qsgrendernode/#clipList">clipList</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual QSGRenderNode::RenderingFlags </td>
<td class="memItemRight bottomAlign">
<b><a href="../qsgrendernode/#flags">flags</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qreal </td>
<td class="memItemRight bottomAlign">
<b><a href="../qsgrendernode/#inheritedOpacity">inheritedOpacity</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const QMatrix4x4 *</td>
<td class="memItemRight bottomAlign">
<b><a href="../qsgrendernode/#matrix">matrix</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual QRectF </td>
<td class="memItemRight bottomAlign">
<b><a href="../qsgrendernode/#rect">rect</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="../qsgrendernode/#releaseResources">releaseResources</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="../qsgrendernode/#render">render</a></b>(const QSGRenderNode::RenderState *<i>state</i>) = 0</td>
</tr> </table>    <h2 id="details">Detailed Description
</h2>    <h2>Member Type Documentation</h2>  <h3 class="flags" id="RenderingFlag-enum">
enum QSGRenderNode::<span class="name">RenderingFlag</span>flags QSGRenderNode::<span class="name">RenderingFlags</span>
</h3> <p>Possible values for the bitmask returned from <a href="../qsgrendernode/#flags">flags</a>().</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QSGRenderNode::BoundedRectRendering</code></td>
<td class="topAlign tblval"><code>0x01</code></td>
<td class="topAlign">Indicates that the implementation of <a href="../qsgrendernode/#render">render</a>() does not render outside the area reported from <a href="../qsgrendernode/#rect">rect</a>() in item coordinates. Such node implementations can lead to more efficient rendering, depending on the scenegraph backend. For example, the software backend can continue to use the more optimal partial update path when all render nodes in the scene have this flag set.</td>
</tr> <tr>
<td class="topAlign"><code>QSGRenderNode::DepthAwareRendering</code></td>
<td class="topAlign tblval"><code>0x02</code></td>
<td class="topAlign">Indicates that the implementations of <a href="../qsgrendernode/#render">render</a>() conforms to scenegraph expectations by only generating a Z value of 0 in scene coordinates which is then transformed by the matrices retrieved from <a href="../qsgrendernode-renderstate/#projectionMatrix">RenderState::projectionMatrix</a>() and <a href="../qsgrendernode/#matrix">matrix</a>(), as described in the notes for <a href="../qsgrendernode/#render">render</a>(). Such node implementations can lead to more efficient rendering, depending on the scenegraph backend. For example, the batching OpenGL renderer can continue to use a more optimal path when all render nodes in the scene have this flag set.</td>
</tr> <tr>
<td class="topAlign"><code>QSGRenderNode::OpaqueRendering</code></td>
<td class="topAlign tblval"><code>0x04</code></td>
<td class="topAlign">Indicates that the implementation of <a href="../qsgrendernode/#render">render</a>() writes out opaque pixels for the entire area reported from <a href="../qsgrendernode/#rect">rect</a>(). By default the renderers must assume that <a href="../qsgrendernode/#render">render</a>() can also output semi or fully transparent pixels. Setting this flag can improve performance in some cases.</td>
</tr> </table> <p>The RenderingFlags type is a typedef for <a href="../qflags/">QFlags</a>&lt;RenderingFlag&gt;. It stores an OR combination of RenderingFlag values.</p> <p><b>See also </b><a href="../qsgrendernode/#render">render</a>() and <a href="../qsgrendernode/#rect">rect</a>().</p>   <h3 class="flags" id="StateFlag-enum">
enum QSGRenderNode::<span class="name">StateFlag</span>flags QSGRenderNode::<span class="name">StateFlags</span>
</h3> <p>This enum is a bit mask identifying several states.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QSGRenderNode::DepthState</code></td>
<td class="topAlign tblval"><code>0x01</code></td>
<td class="topAlign">Depth</td>
</tr> <tr>
<td class="topAlign"><code>QSGRenderNode::StencilState</code></td>
<td class="topAlign tblval"><code>0x02</code></td>
<td class="topAlign">Stencil</td>
</tr> <tr>
<td class="topAlign"><code>QSGRenderNode::ScissorState</code></td>
<td class="topAlign tblval"><code>0x04</code></td>
<td class="topAlign">Scissor</td>
</tr> <tr>
<td class="topAlign"><code>QSGRenderNode::ColorState</code></td>
<td class="topAlign tblval"><code>0x08</code></td>
<td class="topAlign">Color</td>
</tr> <tr>
<td class="topAlign"><code>QSGRenderNode::BlendState</code></td>
<td class="topAlign tblval"><code>0x10</code></td>
<td class="topAlign">Blend</td>
</tr> <tr>
<td class="topAlign"><code>QSGRenderNode::CullState</code></td>
<td class="topAlign tblval"><code>0x20</code></td>
<td class="topAlign">Cull</td>
</tr> <tr>
<td class="topAlign"><code>QSGRenderNode::ViewportState</code></td>
<td class="topAlign tblval"><code>0x40</code></td>
<td class="topAlign">View poirt</td>
</tr> <tr>
<td class="topAlign"><code>QSGRenderNode::RenderTargetState</code></td>
<td class="topAlign tblval"><code>0x80</code></td>
<td class="topAlign">Render target</td>
</tr> </table> <p>The StateFlags type is a typedef for <a href="../qflags/">QFlags</a>&lt;StateFlag&gt;. It stores an OR combination of StateFlag values.</p>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="dtor.QSGRenderNode">
<code>[override virtual] </code>QSGRenderNode::<span class="name">~QSGRenderNode</span>()
</h3> <p>Destructs the render node. Derived classes are expected to perform cleanup similar to <a href="../qsgrendernode/#releaseResources">releaseResources</a>() in here.</p> <p>When a low-level graphics API is in use, the scenegraph will make sure there is a CPU-side wait for the GPU to complete all work submitted to the scenegraph's graphics command queue before the scenegraph's nodes are deleted. Therefore there is no need to issue additional waits here, unless the <a href="../qsgrendernode/#render">render</a>() implementation is using additional command queues.</p> <p><b>See also </b><a href="../qsgrendernode/#releaseResources">releaseResources</a>().</p>   <h3 class="fn" id="changedStates">
<code>[virtual] </code><span class="type"><a href="../qsgrendernode/#StateFlag-enum">QSGRenderNode::StateFlags</a></span> QSGRenderNode::<span class="name">changedStates</span>() const
</h3> <p>This function should return a mask where each bit represents graphics states changed by the <a href="../qsgrendernode/#render">render</a>() function:</p> <ul> <li>
<a href="../qsgrendernode/#StateFlag-enum">DepthState</a> - depth write mask, depth test enabled, depth comparison function</li> <li>
<a href="../qsgrendernode/#StateFlag-enum">StencilState</a> - stencil write masks, stencil test enabled, stencil operations, stencil comparison functions</li> <li>
<a href="../qsgrendernode/#StateFlag-enum">ScissorState</a> - scissor enabled, scissor test enabled</li> <li>
<a href="../qsgrendernode/#StateFlag-enum">ColorState</a> - clear color, color write mask</li> <li>
<a href="../qsgrendernode/#StateFlag-enum">BlendState</a> - blend enabled, blend function</li> <li>
<a href="../qsgrendernode/#StateFlag-enum">CullState</a> - front face, cull face enabled</li> <li>
<a href="../qsgrendernode/#StateFlag-enum">ViewportState</a> - viewport</li> <li>
<a href="../qsgrendernode/#StateFlag-enum">RenderTargetState</a> - render target</li> </ul> <p>The function is called by the renderer so it can reset the states after rendering this node. This makes the implementation of <a href="../qsgrendernode/#render">render</a>() simpler since it does not have to query and restore these states.</p> <p>The default implementation returns 0, meaning no relevant state was changed in <a href="../qsgrendernode/#render">render</a>().</p> <p>With APIs other than OpenGL the relevant states are only those that are set via the command list (for example, OMSetRenderTargets, RSSetViewports, RSSetScissorRects, OMSetBlendFactor, OMSetStencilRef in case of D3D12), and only when such commands were added to the scenegraph's command list queried via the QSGRendererInterface::CommandList resource enum. States set in pipeline state objects do not need to be reported here. Similarly, draw call related settings (root signature, descriptor heaps, etc.) are always set again by the scenegraph so <a href="../qsgrendernode/#render">render</a>() can freely change them.</p> <p>The software backend exposes its <a href="../qpainter/">QPainter</a> and saves and restores before and after invoking <a href="../qsgrendernode/#render">render</a>(). Therefore reporting any changed states from here is not necessary.</p> <p><b>Note: </b>This function may be called before <a href="../qsgrendernode/#render">render</a>().</p>  <h3 class="fn" id="clipList">
const <span class="type"><a href="../qsgclipnode/">QSGClipNode</a></span> *QSGRenderNode::<span class="name">clipList</span>() const
</h3> <p>Returns the current clip list.</p>   <h3 class="fn" id="flags">
<code>[virtual] </code><span class="type"><a href="../qsgrendernode/#RenderingFlag-enum">QSGRenderNode::RenderingFlags</a></span> QSGRenderNode::<span class="name">flags</span>() const
</h3> <p>Returns flags describing the behavior of this render node.</p> <p>The default implementation returns 0.</p> <p><b>See also </b><a href="../qsgrendernode/#RenderingFlag-enum">RenderingFlag</a> and <a href="../qsgrendernode/#rect">rect</a>().</p>   <h3 class="fn" id="inheritedOpacity">
<span class="type"><a href="#qreal-typedef">qreal</a></span> QSGRenderNode::<span class="name">inheritedOpacity</span>() const
</h3> <p>Returns the current effective opacity.</p>   <h3 class="fn" id="matrix">
const <span class="type"><a href="../qmatrix4x4/">QMatrix4x4</a></span> *QSGRenderNode::<span class="name">matrix</span>() const
</h3> <p>Returns pointer to the current model-view matrix.</p>   <h3 class="fn" id="rect">
<code>[virtual] </code><span class="type"><a href="../qrectf/">QRectF</a></span> QSGRenderNode::<span class="name">rect</span>() const
</h3> <p>Returns the bounding rectangle in item coordinates for the area <a href="../qsgrendernode/#render">render</a>() touches. The value is only in use when <a href="../qsgrendernode/#flags">flags</a>() includes <a href="../qsgrendernode/#RenderingFlag-enum">BoundedRectRendering</a>, ignored otherwise.</p> <p>Reporting the rectangle in combination with <a href="../qsgrendernode/#RenderingFlag-enum">BoundedRectRendering</a> is particularly important with the <code>software</code> backend because otherwise having a rendernode in the scene would trigger fullscreen updates, skipping all partial update optimizations.</p> <p>For rendernodes covering the entire area of a corresponding <a href="../qquickitem/">QQuickItem</a> the return value will be (0, 0, item-&gt;width(), item-&gt;height()).</p> <p><b>Note: </b>Nodes are also free to render outside the boundaries specified by the item's width and height, since the scenegraph nodes are not bounded by the <a href="../qquickitem/">QQuickItem</a> geometry, as long as this is reported correctly from this function.</p>
<p><b>See also </b><a href="../qsgrendernode/#flags">flags</a>().</p>   <h3 class="fn" id="releaseResources">
<code>[virtual] </code><span class="type">void</span> QSGRenderNode::<span class="name">releaseResources</span>()
</h3> <p>This function is called when all custom graphics resources allocated by this node have to be freed immediately. In case the node does not directly allocate graphics resources (buffers, textures, render targets, fences, etc.) through the graphics API that is in use, there is nothing to do here.</p> <p>Failing to release all custom resources can lead to incorrect behavior in graphics device loss scenarios on some systems since subsequent reinitialization of the graphics system may fail.</p> <p><b>Note: </b>Some scenegraph backends may choose not to call this function. Therefore it is expected that <a href="../qsgrendernode/">QSGRenderNode</a> implementations perform cleanup both in their destructor and in releaseResources().</p>
<p>Unlike with the destructor, it is expected that <a href="../qsgrendernode/#render">render</a>() can reinitialize all resources it needs when called after a call to releaseResources().</p> <p>With OpenGL, the scenegraph's OpenGL context will be current both when calling the destructor and this function.</p>   <h3 class="fn" id="render">
<code>[pure virtual] </code><span class="type">void</span> QSGRenderNode::<span class="name">render</span>(const <span class="type">QSGRenderNode::RenderState</span> *<i>state</i>)
</h3> <p>This function is called by the renderer and should paint this node with directly invoking commands in the graphics API (OpenGL, Direct3D, etc.) currently in use.</p> <p>The effective opacity can be retrieved with <a href="../qsgrendernode/#inheritedOpacity">inheritedOpacity</a>().</p> <p>The projection matrix is available through <i>state</i>, while the model-view matrix can be fetched with <a href="../qsgrendernode/#matrix">matrix</a>(). The combined matrix is then the projection matrix times the model-view matrix. The correct stacking of the items in the scene is ensured by the projection matrix.</p> <p>When using the provided matrices, the coordinate system for vertex data follows the usual <a href="../qquickitem/">QQuickItem</a> conventions: top-left is (0, 0), bottom-right is the corresponding <a href="../qquickitem/">QQuickItem</a>'s width() and height() minus one. For example, assuming a two float (x-y) per vertex coordinate layout, a triangle covering half of the item can be specified as (width - 1, height - 1), (0, 0), (0, height - 1) using counter-clockwise direction.</p> <p><b>Note: </b><a href="../qsgrendernode/">QSGRenderNode</a> is provided as a means to implement custom 2D or 2.5D Qt Quick items. It is not intended for integrating true 3D content into the Qt Quick scene. That use case is better supported by <a href="../qquickframebufferobject/">QQuickFramebufferObject</a>, <a href="../qquickwindow/#beforeRendering">QQuickWindow::beforeRendering</a>(), or the equivalents of those for APIs other than OpenGL.</p>
<p>Clip information is calculated before the function is called, it is however not enabled. Implementations wishing to take clipping into account can set up scissoring or stencil based on the information in <i>state</i>. Some scenegraph backends, software in particular, use no scissor or stencil. There the clip region is provided as an ordinary <a href="../qregion/">QRegion</a>.</p> <p>For OpenGL the following states are set on the render thread's context before this function is called:</p> <ul> <li>glDepthMask(false)</li> <li>glDisable(GL_DEPTH_TEST)</li> <li>glStencilFunc(GL_EQUAL, state.stencilValue, 0xff) depending on clip</li> <li>glScissor(state.scissorRect.x(), state.scissorRect.y(), state.scissorRect.width(), state.scissorRect.height()) depending on clip</li> <li>glEnable(GL_BLEND)</li> <li>glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA)</li> <li>glDisable(GL_CULL_FACE)</li> </ul> <p>States that are not listed above, but are included in <a href="../qsgrendernode/#StateFlag-enum">StateFlags</a>, can have arbitrary values.</p> <p><a href="../qsgrendernode/#changedStates">changedStates</a>() should return which states this function changes. If a state is not covered by <a href="../qsgrendernode/#StateFlag-enum">StateFlags</a>, the state should be set to the default value according to the OpenGL specification. For other APIs, see the documentation for <a href="../qsgrendernode/#changedStates">changedStates</a>() for more information.</p> <p><b>Note: </b>Depth writes are disabled when this function is called (for example, glDepthMask(false) in case of OpenGL). Enabling depth writes can lead to unexpected results, depending on the scenegraph backend in use, so nodes should avoid this.</p>
<p>For APIs other than OpenGL, it will likely be necessary to query certain API-specific resources (for example, the graphics device or the command list/buffer to add the commands to). This is done via <a href="../qsgrendererinterface/">QSGRendererInterface</a>.</p> <p><b>See also </b><a href="../qsgrendererinterface/">QSGRendererInterface</a> and <a href="../qquickwindow/#rendererInterface">QQuickWindow::rendererInterface</a>().</p>
<div class="_attribution">
  <p class="_attribution-p">
    © The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-5.13/qsgrendernode.html" class="_attribution-link" target="_blank">https://doc.qt.io/qt-5.13/qsgrendernode.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
